package annot.textio;

import java.util.Vector;

import org.antlr.runtime.ANTLRStringStream;
import org.antlr.runtime.CharStream;
import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.RecognitionException;
import org.apache.bcel.generic.InstructionHandle;

import annot.attributes.BCPrintableAttribute;
import annot.bcclass.BCClass;
import annot.bcclass.BCMethod;
import annot.bcclass.MLog;

/**
 * Class used for parsing BML annotations (real parser has been
 * generated by antlr tool to <code>antlr3-generated</code>
 * package). It contains also some methods for String
 * opetarions on BML annotations.
 *
 * @author Tomasz Batkiewicz (tb209231@students.mimuw.edu.pl)
 * @version a-01
 */
public class Parsing {

  /**
   * The number of tokens to show in case {@link #GO_SHOW_TOKENS} is true.
   */
  private static final int TOKENS_TO_SHOW = 100;

  /**
   * Shows token list (from lexer) before parsing each
   * BCPrintableAttribute. Useful when parser crashes.
   */
  private static final boolean GO_SHOW_TOKENS = false;

  /**
   * BCClass of all BML annotations parsing here.
   */
  private final BCClass bcc;

  /**
   * The content of the last error message.
   */
  private String my_errmsg = "";

  /**
   * The vector with positions of BML regions.
   */
  private Vector < PosInCode > bml_positions;

  /**
   * A standard constructor.
   *
   * @param abcc - BCClass of all BML annotations
   *     to be parsed here.
   */
  public Parsing(final BCClass abcc) {
    this.bcc = abcc;
  }

  /**
   * Surrounds given BML annotation's code with comment.
   *
   * @param acode - String representation of one or more
   *     BML annotations (after line-breaing).
   * @return <code>code</code> surrounded by common comment.
   */
  public static String addComment(final String acode) {
    String code = acode;
    if (code.length()  <  1) {
      return "";
    }
    //    if (code.lastIndexOf("\n") == code.length() - 1)
    //      code = code.substring(0, code.length() - 1);
    if (code.lastIndexOf("\n")  >= 0 ||
        code.length()  >  DisplayStyle.MAX_TOTAL_LINE_WIDTH -
              DisplayStyle.BML_COMMENT_START.length() -
              DisplayStyle.BML_COMMENT_END_WITH_SPACES.length()) {
      final String[] lines = code.split("\n");
      code = "";
      for (int i = 0; i  <  lines.length; i++) {
        if (!lines[i].startsWith(DisplayStyle.BML_COMMENT_NEXT)) {
          lines[i] = DisplayStyle.BML_COMMENT_NEXT + lines[i];
        }
        if (lines[i].equals(DisplayStyle.BML_COMMENT_NEXT)) {
          continue;
        }
        code += lines[i] + "\n";
      }
      return DisplayStyle.BML_COMMENT_START + " \n" + code +
             DisplayStyle.BML_COMMENT_END_WITH_SPACES + "\n";
    } else {
      return DisplayStyle.BML_COMMENT_START + " " + code +
        DisplayStyle.BML_COMMENT_END_WITH_SPACES +
        "\n";
    }
  }

  /**
   * Escapes given String, for use as a regexp pattern.
   *
   * @param astr - string to escape characters in
   * @return escaped <code>str</code>, to use as regexp
   *     pattern to match <code>str</code> literally.
   */
  public static String escape(final String astr) {
    String str = astr;
    str = str.replaceAll("\\\\", "\\\\\\\\");
    str = str.replaceAll("\\*", "\\\\\\*");
    str = str.replaceAll("\\{", "\\\\\\{");
    str = str.replaceAll("\\}", "\\\\\\}");
    return str;
  }

  /**
   * Returns fragment of given code.
   *
   * @param code - multi line String,
   * @param start - start line number,
   * @param end - end line number,
   * @return substring of <code>code</code>, from line
   *     no.  <code>start</code> to line no.  <code>end</code>
   *     (including both start and end lines).
   */
  public static String getLines(final String code, final int start,
                                final int end) {
    String ret = "";
    final String[] lines = code.split("\n");
    for (int i = start; i  <= end; i++) {
      ret += lines[i];
    }
    return ret;
  }

  /**
   * Returns line of given number of given String.
   *
   * @param code - multi line String,
   * @param pos - number of line in <code>code</code>.
   * @return <code>pos</code>'s line of <code>code</code>.
   */
  public static int lineAt(final String code, final int pos) {
    return code.substring(0, pos).split("\n").length - 1;
  }

  /**
   * Removes comment, line-breaks and stray spaces from
   * given BML annotation. Can be used to compare BML
   * annotation (eg. in parser test).
   *
   * @param attr - String representation of an BML
   *     annotation.
   * @return <code>attr</code> with unnessesery characters
   *     removed.
   */
  public static String purge(final String attr) {
    String lattr = removeComment(attr);
    lattr = lattr.replaceAll("\n", "");
    while (lattr.lastIndexOf("  ")  >= 0) {
      lattr = lattr.replaceAll("  ", " ");
    }
    lattr = lattr.replaceAll("~ ", "~");
    return lattr;
  }

  /**
   * Removes comment surrounding given BML annotation.
   *
   * @param attr - String representation of an BML
   *     annotation.
   * @return <code>attr</code> without surrounding comment.
   */
  public static String removeComment(final String attr) {
    String lattr = attr;
    if (lattr.startsWith(DisplayStyle.BML_COMMENT_NEXT)) {
      lattr = lattr.substring(DisplayStyle.COMMENT_LENGTH);
    }
    lattr = lattr.replaceAll(escape(DisplayStyle.BML_COMMENT_START), "");
    lattr = lattr.replaceAll(escape("\n" +
                                    DisplayStyle.BML_COMMENT_NEXT), "\n");
    lattr = lattr.replaceAll(escape(DisplayStyle.BML_COMMENT_END_WITH_SPACES),
                             "");
    return lattr;
  }

  /**
   * Perform syntax and (basic) semantics checks of given
   * BML annotation String.
   *
   * @param m - parsing annotation's method (or null for
   *     class annotations),
   * @param ih - instructionHandle of parsing annotation,
   * @param minor - minor number of parsing annotation,
   * @param str - new String representation to be parsed
   *     (without surrounding comment - use
   *     {@link #purge(String)} method to remove comment),
   * @return true iff <code>str</code> is correct, false
   *     otherwise.
   */
  public BCPrintableAttribute checkSyntax(final BCMethod m,
                                          final InstructionHandle ih,
                                          final int minor, final String str) {
    try {
      final BCPrintableAttribute newattr = parseAttribute(m, ih, minor, str);
      return newattr;
    } catch (final RecognitionException e) {
      return null;
    }
  }

  /**
   * Returns the error message for the last parsing.
   *
   * @return the error message
   */
  public String getErrMsg() {
    return this.my_errmsg;
  }

  /**
   * Parse an BML annotation using parser generated from
   * <code>BML.g3</code> grammar.
   *
   * @param m - parsing annotation's method (or null for
   *     class annotations),
   * @param ih - instructionHandle of parsing annotation,
   * @param minor - minor number of parsing annotation,
   * @param str - new String representation to be parsed
   *     (without surrounding comment - use
   *     {@link #purge(String)} method to remove comment),
   * @return new BCPrintableAttribute parsed from
   *     <code>str</code>.
   * @throws RecognitionException - if <code>str</code>
   *     isn't correct BML annotation.
   */
  public BCPrintableAttribute parseAttribute(final BCMethod m,
                                     final InstructionHandle ih,
                                     final int minor, final String str)
    throws RecognitionException {
    final CharStream chstr = new ANTLRStringStream(str);
    final BMLLexer lex = new BMLLexer(chstr);
    final CommonTokenStream tokens = new CommonTokenStream(lex);
    if (GO_SHOW_TOKENS) {
      MLog.putMsg(MLog.LEVEL_PINFO, "tokens:");
      for (int i = 0; i  <  TOKENS_TO_SHOW; i++) {
        MLog.putBitOfMsg(MLog.LEVEL_PINFO, " " + tokens.toString(i, i));
      }
      MLog.putMsg(MLog.LEVEL_PINFO, "");
    }
    final BMLParser parser = new BMLParser(tokens);
    parser.init(this.bcc, m, this.bcc.getCp(), ih, minor);
    final BCPrintableAttribute result = parser.printableAttribute().ast;
    if (lex.lastE != null) {
      throw lex.lastE;
    }
    if (parser.lastE != null) {
      throw parser.lastE;
    }
    return result;
  }

  /**
   * Parses a whole class.
   * Should be called with <code>affectBCC = false</code>
   * first (for error-checking) and, if it returns true,
   * then with <code>affectBcc = true</code> to parse
   * the same code into its BCClass.
   * Adding / removing / replacing methods is currently
   * unsupported.
   *
   * @param code - preprocessed class's code to be parsed.
   *     Should have all bytecode lines and unaffected
   *     fragments collapsed to proper stubs,
   * @param affectBcc - whether to affect bcclass or not.
   *     if it is set to false, parser will perform
   *     error-check only, without affecting BCClass.
   * @return whether <code>code</code> is correct String
   *     representation for current BCClass.
   *     Crashes if <code>affectBcc</code> is true
   *     and given code is incorrect.
   */
  public boolean parseClass(final String code, final boolean affectBcc) {
    //TODO FIXME we should strip off the comments first

    final CharStream chstr = new ANTLRStringStream(code);
    final BMLLexer lex = new BMLLexer(chstr);
    final CommonTokenStream tokens = new CommonTokenStream(lex);
    final BMLParser parser = new BMLParser(tokens);
    parser.initClass(this.bcc, affectBcc);
    try {
      parser.parseClass();
      if (lex.lastE != null) {
        throw lex.lastE;
      }
      if (parser.lastE != null) {
        MLog.putMsg(MLog.LEVEL_PINFO, Integer.toString(parser.lastE.line));
        throw parser.lastE;
      }
      bml_positions = parser.getBMLPositions();
    } catch (final RecognitionException e) {
      if (affectBcc) {
        throw new RuntimeException("parsing failed while updating BCClass");
      }
      this.my_errmsg = "error in " + e.line + " : " +
                        (e.charPositionInLine + 1);
//                       (calculatePosInLine(code, e.charPositionInLine) + 1);
      return false;
    }
    this.my_errmsg = "";
    return true;
  }

//  private int calculatePosInLine(String code, int charPositionInLine) {
//    final String[] lines = code.split("\n");
//    int charstilnow = 0;
//    for (int i = 0; i < lines.length; i++) {
//      if (charstilnow + lines[i].length() + 1 < charPositionInLine) {
//        charstilnow += lines[i].length() + 1;
//      } else {
//        break;
//      }
//    }
//    return charPositionInLine - charstilnow;
//  }

  /**
   * Returns the structure with BML specification areas markers (i.e. / *@,
   * @* / and / /@).
   *
   * @return a vector with positions of BML markers
   */
  public Vector < PosInCode > getBMLPositions() {
    return bml_positions;
  }
}
