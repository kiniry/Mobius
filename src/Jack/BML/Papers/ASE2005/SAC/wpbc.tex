
\section{Weakest Precondition Calculus For Java Bytecode}\label{wpbc}
In this section, we define a bytecode logic in terms of a weakest precondition calculus. The proposed weakest precondition \wpi \ supports all Java bytecode sequential instructions except for floating point arithmetic instructions and 64 bit data (\java{long} and \java{double} types), including exceptions, object creation,
 references and subroutines. The calculus is defined over the method control flow graph and supports BCSL annotation,
 i.e. bytecode method's specification like preconditions, normal and exceptional postconditions, class invariants,
 assertions at particular program point among which loop invariants. The verification condition generator applied to a method 
bytecode generates a proof obligation for every execution path
 by applying first the weakest predicate transformer to every \instr{return} instruction,
 \instr{athrow} instruction and end of a loop instruction and then following in a backwards direction the control
 flow up to reaching the entry point instruction.
%The function $\wpi$ must satisfy the following property: if the instruction $\instr{ins}$ starts execution in a state where the predicate
%$\wpi(\instr{ins}, \ \psi, \ \excPost)$ holds then if it terminates normally then the poststate must satisfy the predicate $\psi$  
%and if terminates on exception \texttt{Exc} then  the poststate must satisfy $\excPost(\texttt{Exc})$.
 In an extended version of the present paper \cite{JBL05MP}, we show that the $\wpi$ function is correct.

%We give here the \wpi \ rule of the  \instr{Type\_load i} instruction:
%\begin{frameit}
%\[\wpi(\instr{Type\_load \ i}, \psi, \excPost) = \psi\substitution{\counter }{\counter+1} \substitution{\stack{\counter+1}}{\register{i}}
%\] \end{frameit}
 In Fig.~\ref{instrWP}, we show the \wpi \ rule for the \instr{Type\_load i} instruction.
 As the example shows the \wpi \ function takes three arguments:
the instruction for which we calculate the precondition, 
the instruction's postcondition $\psi$ and the exceptional postcondition function $\excPost$ which for any exception \texttt{Exc} and 
instruction index \texttt{ind} returns the
corresponding exceptional postcondition $\excPost(\texttt{Exc}, \tt{ind})$. One can also notice that the rule involves the stack expressions \counter 
(stands for the counter of the method execution stack) \ and \stack{ i } (stands for the element at ind \texttt{i} from the stack top).
 This is because the JVM is stack based and the instructions take their arguments from the method execution stack and 
 put the result on the stack.
 The \wpi \ rule for  \instr{Type\_load i} increments the stack counter \counter \ and loads on the stack top the contents
 of the local variable $\register{i}$. 




% The calculus is defined over the control flow graph of the program and has two levels of definitions --- the first one is the set of rules for sequential Java bytecode instructions (discussed in subsection~\ref{wpInstr} ) and the second one takes into account how control flows in the bytecode (subsection~\ref{wpGraph}).
%Loops are treated by transforming the control flow graph into an abstract acyclic graph (by eliminating the backedges). As we mentioned earlier we assume that every method is specified enough, i.e. for each loop, the corresponding invariant is present. Thus, the eliminated edges are replaced by the corresponding loop invariant. 
% The verification conditions are generated over the abstract control flow graph. Subsection~\ref{abstrCntrFlow} discusses 
%how the abstract control flow graph is generated.

%We have the proof of soundness of the \wpi \ predicate transformer. The proof is done w.r.t. to the operational semantics of the sequential Java bytecode
%subset and establishes that if the verification conditions are provable this means that the method implementation respects the method specification.
\begin{figure}[t]
\begin{frameit}
\[
\small{
\begin{array}{l}
\wpi(\instr{Type\_load \ i}, \ \psi, \ \excPost)  = \\
\begin{array}{l}  \psi\substitution{\counter }{\counter+1} \substitution{\stack{\counter+1}}{\register{i}} \end{array} \\
\\
\\

%where \texttt{i} is a valid local variable index   \\





 \wpi(\instr{putField} \ \texttt{Cl.f}, \ \psi, \ \excPost)  = \\
%\biggl( 
\begin{array}{l}

   		\stack{\counter -1} \not= \Mynull\Rightarrow   
	 \psi\begin{array}{l} \substitution{\counter}{ \counter-2 } \\[0 mm] 
   	                   \substitution{\texttt{Cl.f} }{ \texttt{Cl.f}\oplus [\stack{\counter -1} \rightarrow \stack{\counter}] } \\
		\end{array}\\

   \wedge \\
   	\stack{\counter-1} = \Mynull 	\Rightarrow \excPost(\tt{NullPointerExc})
        \begin{array}{l}
          \substitution{ \counter }{ 0} \\
          \substitution{\stack{0}}{ \stack{\counter}} 
	\end{array}
    \end{array} %\biggr. & \\
\end{array}}
 \]	  \\
  % where  the   predicate   $\phi$    is   the   precondition   of   the
  % exception   handler   protecting   the   instruction    against 
  % \texttt{NullPointerException} if  it exists,  otherwise 
  % if \texttt{ NullPointerException}  is not  handled    
   %   $\phi = \excPost(\tt{NullPointerException})[ \jmlKey{EXC} \leftarrow \stack{\counter}]$


%\texttt{wp(if\_acmpeq n , $\psi$)} =  \texttt{(Stack(t)==Stack(t-1)} $\Rightarrow$ $\psi(n)$ \texttt{[t$\leftarrow$t-2]\\
%                $\phantom{ texttt{wp} textttifacmpeq n } $   $\wedge$ } \\
%                $\phantom{ texttt{wp} textttifacmpeq n } $   \texttt{Stack(t)$\neq$Stack(t-1)} $\Rightarrow$ $\psi$\texttt{(index(if\_acmpeq n) + 1% ) } %                $\phantom{ texttt{wp} textttifacmpeq nnnnnnnnnnnnnn} $   \texttt{[t$\leftarrow$t-2]} \\\\

 \end{frameit}
\caption{\sc Examples for bytecode wp rules}
 \label{instrWP}

\end{figure}

In the following, we consider how instance fields, %method invocations, 
loops exception handling and subroutines are treated. We omit here aspects like method invocation and object creation because of space limitations but a detailed explanation can be found in~\cite{JBL05MP}. 
\input wpSingleInstr.tex
%\input ctrlFlowWp.tex





