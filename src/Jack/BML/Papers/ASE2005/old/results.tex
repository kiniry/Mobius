
\subsection{Results}  \label{results}


We have an implementation of the JML compiler ( subsection \ref{comJML}) and the bytecode verification condition generator based on the weakest precondition calculus (Section \ref{wpbc}) which are integrated in JACK. Both of the verification condition generators perform the same simplifications over the verification conditions 
, e.g. eliminate verification conditions that contain contradictory hypothesis or trivial goals (equal to true). 

The performed tests show that JML compilation augments around twice the file size. 
For the example in Fig.~\ref{replaceSrc}, the class file without the specification extensions is 548 bytes, 
and the class with the BCSL extension BCSL is 954 bytes. 
The size of the bytecode specification is proportional to the source specification: 
the bigger is the source specification, the greater will be the size of the class file. 


We studied the relationship between the source code proof obligations generated 
by the standard feature of JACK and the bytecode proof obligations generated by our implementation over the corresponding bytecode
 produced by a non optimizing compiler. Basically, they are the same modulo the names of the program variables. Another issue that
 deserves the attention is that even non optimizing compilers perform optimizations, as for example dead code elimination of
 a conditional branch which is never taken.
In this case, the compiler does not generate the dead code and the bytecode verification condition generator will neither ``see'' it. 
Even though the source contains the never taken branch as the condition is equivalent to false, this will result in a trivially true
verification condition which the JACK source verification condition generator will discard.
% \begin{figure}
%\begin{verbatim}
%
%//@ensures \result == 1;
%void m() {
%  if (false ) {
%    return -1;
%  } else {
%    return 1;
%  }
%}
%
%\end{verbatim}
%\end{figure}

 We return now to our example from the previous sections and give the proof obligations on source and bytecode level respectively. 
In particular, in Fig. \ref{vcEnsures} compares the source and bytecode proof obligation concerning the postcondition correctness (as there are several return instructions).

The verification conditions on bytecode and source level for the postcondition  correctness given in Fig. \ref{vcEnsures}
 have the same shape modulo names (see Section \ref{comJML} for how method local variables and field names are compiled). 
 In Section \ref{comJML} we showed that postcondition in the example was compiled by performing structural transformations 
in an equivalent specification expression and we gave it in Fig. \ref{postCompile}. 

Despite those changes, the source and bytecode goal respectively (which are actually the postcondition) on bytecode and source level are not only
semantically equivalent but syntactically the same (except for the variable names ). Still, in the bytecode proof obligation we have one more hypothesis than on source level. The extra hypothesis in the bytecode proof obligation is related to the fact that the result type is boolean but the JVM encodes boolean expressions as integers (which is trivially true).


One of the future directions is to formally give evidence that the proof obligations on non optimized bytecode and source programs are syntactically the same (modulo names and types). 

%Fig. \ref{vcLoopPreserv} shows the proof obligations for the loop preservation. As you can see the hypothesis and the goal have the same ``shape'' on bytecode and source code and the differences are due to the variable names.



% \begin{figure}{!h}

% $$\begin{array}{ll}
%Hypothesis \ on \ bytecode:  & Hypothesis \ on \ source \ level:  \\
%% & \\

%
%\begin{array}{l}
% \register{1} \neq \\
%\#19 (\register{0})[\register{2}\_at\_ins\_22]
%\end{array}  
%
%&  
%\begin{array}{l}
% \srcVar{obj} \neq \\
%  ListArray.list(\this)[\srcVar{i}\_at\_ins\_26] 
%\end{array}   \\
%
%
%
% & \\
%
%\#19(\register{0}) \neq \Mynull &  ListArray.list( \this) \neq \Mynull\\
%
%
%& \\
%
%\begin{array}{l}
%  len(\#19 (\register{0})) > \\
% \register{2}\_at\_ins\_22 
%\end{array}
%%& 
%\begin{array}{l}
%  len(ListArray.list(\this)) > \\
%\srcVar{i}\_at\_ins\_26
%\end{array}         \\ 

%

% & \\
%
% \register{2}\_at\_ins\_22 \geq 0 &   \srcVar{i}\_at\_ins\_26    \geq 0    \\
%
%
% & \\
%\begin{array}{l}
%  \register{2}\_at\_ins\_22 < \\
%  len(\#19(\register{0}))
%\end{array} &
%
%\begin{array}{l}
%  \srcVar{i}\_at\_ins\_26 <\\
%  len(ListArray.list(\this))
%\end{array}   \\
%
%
% & \\
%\begin{array}{l}
%  \register{2}\_at\_ins\_22 \leq \\
%  len( \#19(\register{0}))
%\end{array} 
%&  
%\begin{array}{l} 
%  \srcVar{i}\_at\_ins\_26 \leq \\
%  len(ListArray.list(\this))
%\end{array}   \\
%
%
% &\\
%% \register{2}\_at\_ins\_22 \geq 0 &   \srcVar{i}\_at\_ins\_26 \geq 0 \\
%
%
%
%% &\\
% \begin{array}{l} 
%         \forall  var(0). \ 0 \leq var(0) \wedge var(0) < (\register{2}\_at\_ins\_22) \Rightarrow \\
%                \Myspace    \#19(\register{0})[var(0)] \neq \register{1}
%      \end{array} &        
%      \begin{array}{l} 
%             \forall  var(0). \ 0 \leq var(0) \wedge var(0) < (\srcVar{i}\_at\_ins\_26) \Rightarrow \\
%                 \Myspace       ListArray.list(\this)[var(0)] \neq \srcVar{obj}
%      \end{array}  \\
%%
% typeof(\register{0}) <: ListArray &    typeof(this) <: ListArray     \\
%
%& \\
%& \\
%Goal \ on \ bytecode: & Goal \ on \ source \ level: \\
%
%& \\
%
%  \begin{array}{l}
%               1 + \register{2}\_at\_ins\_22 \leq  len(ListArray.list(\register{0}))  \\
%
%               1 + \register{2}\_at\_ins\_22 \geq 0 \\
%
%               \forall  var(0). 0 \leq var(0) \wedge var(0) < 1 + \register{2}\_at\_ins\_22 \Rightarrow \\
%                   \Myspace  ListArray.list(\register{0})[var(0)] \neq \register{1} 
%
%       \end{array}
%& 
%
%       \begin{array}{l}
%             1 + \srcVar{i}\_at\_ins\_26 \leq  len(ListArray.list(this))  \\
%	     \\
%             1 + \srcVar{i}\_at\_ins\_26 \geq 0 \\
%	     \\
%             \forall  var(0). 0 \leq var(0) \wedge\\
%	     \Myspace  var(0) < 1 + \srcVar{i}\_at\_ins\_26 \Rightarrow \\
%                  \Myspace  ListArray.list(this)[var(0)] \neq \srcVar{obj} 
%       \end{array}   
%
 
%\end{array}$$



%\caption{Source and Bytecode verification condition for loop preservation for method \texttt{ListArray.isElem} }
%\label{vcLoopPreserv}
%\end{figure}








\begin{figure}[!h]


\begin{tabular}{|l|l|}
\hline
Hypothesis \ on \ bytecode:  & Hypothesis \ on \ source \ level:  \\
\hline 
$\register{2}\_at\_ins\_20 \geq len(\#19(\register{0}))$ 
& $ \srcVar{i}\_at\_ins\_26 \geq len(ListArray.list(\this))$ \\
\hline 

$\#19(\register{0}) \neq \Mynull$ 
& $ ListArray.list(\this) \neq \Mynull$ \\

\hline 
$ \register{2}\_at\_ins\_20) \leq len(\#19(\register{0})) $ 
&  $  \srcVar{i}\_at\_ins\_26  \leq  len(ListArray.list(\this))  $ \\
\hline

$\register{2}\_at\_ins\_20 \geq 0  $ 
& $ \srcVar{i}\_at\_ins\_26  \geq 0 $ \\

\hline

$\forall  var(0). \  0 \leq var(0) \wedge 
   var(0) < \register{2}\_at\_ins\_20 \Rightarrow $ 
& $\forall  var(0). \  0 \leq var(0) \wedge 
    var(0) < \srcVar{i}\_at\_ins\_26 \Rightarrow $ \\

$ \#19(\register{0})[var(0)] = \register{1}   $ 
& $  ListArray.list(\this)[var(0)] = \srcVar{obj}  $ \\

\hline

 $typeof(\register{0}) <: ListArray$ & $typeof( \this) <:  ListArray$  \\
\hline

$0=0 \vee 0=1$ & \\

& \\

\hline
Goal on bytecode: & Goal on source level: \\
\hline
 $\Myfalse  \iff \exists  var(0) . \ 0 \leq var(0) \wedge$ 
& $ \Myfalse \iff \exists  var(0) . \ 0 \leq var(0) \wedge$ \\

$\Myspace \Myspace var(0) < len(\#19(\register{0})) \wedge$ 
& $\Myspace \Myspace  var(0) < len(ListArray.List(this)) \wedge $\\
       
$\Myspace \Myspace \#19(\register{0})[var(0)] = \register{1} $ 
&$\Myspace \Myspace  ListArray.List(this)[var(0)] = \srcVar{obj}  $ \\

\hline
\end{tabular}
\\
Note: $\expression\_at\_ins\_n$ denotes the value of  
expression $\expression$ at the bytecode instruction at index (source line)  $n$ \\

\caption{Source and Bytecode verification condition for one case of the postcondition correctness }
\label{vcEnsures}
\end{figure}
 















%\subsubsection{Example}
% We give a simple example of how the \wpi \ works. Block $\blockm{6}$ (starts at instr. \texttt{6}) in Fig.~\ref{blockBC} ends with a branching instruction and in the case when the condition is true (the current element of the array is not equal to the first parameter of the method \texttt{replace}) the execution will continue at $\blockm{19}$. Below we give the part of the weakest precondition for block $\blockm{6}$ in case the control flows to block $\blockm{19}$( the condition of its last instruction holds and in this case 
%the predicate $pre(b^{6}, b^{19})$ is $\wpi(\blockm{19})$).  The implications with conclusion \Myfalse \ stand for the possible exceptions \texttt{NullPointer} and \texttt{ArrayIndexOutOfBound} exceptions that may be thrown (as no postcondition is specified explicitly for these cases of abnormal termination, the one by default is taken). 

%\input wpExample.tex
