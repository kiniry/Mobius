\begin{abstract} 

We present the Bytecode Modeling Language (BML), the Java bytecode
cousin of JML. BML allows the application developer to specify the
behaviour of an application in the form of annotations,
\emph{directly} at the level of the bytecode. An extension of the class file
format is defined to store the specification directly with the
bytecode. This is a first step towards the development of a platform
for Proof Carrying Code, where applications come together with their
specification and a proof of correctness. BML is designed to be
closely related with JML. In particular, JML specifications can be
compiled into BML specifications. We briefly discuss the tools that
are currently being developed for BML, and that will result in a tool
set where an application can be validated throughout its development,
both at source code and at bytecode level.

\end{abstract}

\section{Introduction}\label{IntroSectLab}

The use of formal methods to show conformance of an implementation
\emph{w.r.t.}\ a specification has become an accepted technique 
for the development of security-critical applications. Various tools
exist that allow to specify and validate complex functional or
security properties, using different techniques such as runtime
assertion checking, testing and verification condition generation.
However, often these techniques are restricted to source code level
programs, while for many applications, and in particular for mobile
code, one needs to be able to also specify and verify the executable
(or interpreted) code.

Different possible reasons for this exist: the executable code may not
be accompanied by its (specified) source, or one simply does not trust
the compiler. And in an attempt to avoid \emph{all} possible security
threats, sometimes security-critical applications are directly
developed at the executable level. Thus, it is essential to have the
means to specify \emph{and} to verify an application directly at this
level, without the use of a compiler, and both specification and
verification techniques should be tailored directly to the
particularities of executable code. Moreover, in order to capture all
relevant security requirements, the specification language used should
be expressive enough for this.

Proof Carrying Code (PCC) is a typical example where the need to
specify and verify executable code directly is imperative, in
particular when one wishes to capture complex security policies that
cannot be checked with a type checker.  PCC is a possible solution to
support the secure downloading of applications on a mobile device. The
executable code of an application comes together with a specification,
and the necessary evidence from which the code client can easily
establish that the application respects its specification. In such a
scenario, the code producer, who \emph{has} to produce a correctness
proof, will often prefer to do the verification at source code level,
and then compile the specification and the proof into the level of
executable code. Realising a platform to support this scenario is one
of the goals of the \mobius project (see
\texttt{http://mobius.inria.fr}).

This paper describes the low-level specification language that we
propose to specify the security requirements for mobile device
applications. Since the most common execution framework for mobile
devices is the J2ME platform, our language is tailored to Java
bytecode, and thus to the verification of \emph{unstructured}
code. To be able to translate source code level specifications
into bytecode level specifications, our specification language is also
designed to be closely related to the Java Modeling Language (JML)
(see
\texttt{http://www.jmlspecs.org}).


Over the last few years, JML has become the \emph{de facto}
specification language for Java source code programs. Different tools
exist that allow to validate, verify or generate JML specifications
(see~\cite{BurdyCCEKLLP05} for an overview). Several case studies have
demonstrated that JML can be used to specify and improve realistic
industrial examples (see \emph{e.g.}~\cite{BreunesseCHJ04}). One of
the reasons for its success is that JML uses a Java-like
syntax. Specifications are written using preconditions, postcondition,
class invariants and other annotations, where the different predicates
are side-effect-free Java expressions, extended with
specification-specific keywords (\emph{e.g.}\ logical quantifiers and
a keyword to refer to the return value of a method). Other important
factors for the success of JML are its expressiveness and flexibility,
and its ability to characterise typical security requirements.

% JML is in particular suited to express many of the
%different security requirements that have been identified to be of
%interest for mobile device applications.%~\cite{Deliverable1.2}.


Therefore, we define a variation of JML especially tailored to
bytecode, called BML, short for Bytecode Modeling Language.
BML supports the most important features of JML. Thus, we can express
functional properties of Java bytecode programs in the form of
\emph{e.g.}\ pre- and postconditions, class and object invariants, and
assertions for particular program points like loop invariants. Because
of the close connection with JML, JML source code level specifications
can be compiled into BML bytecode level specifications without too
much difficulty, basically by compiling the source code predicates
into bytecode predicates.  This allows to do development and
verification at source code level, while still being able to ship
bytecode level proofs.  To the best of our knowledge, no other
specification language with similar design goals exists for Java
bytecode. Notice that, even though the design of BML was motivated by
the need to specify security requirements for mobile device
applications, just as JML, BML is a general specification language
that can be used for different kinds of applications and analyses.

Section~\ref{SecJMLOverview} quickly summarises the relevant features
of JML. Section~\ref{SecBML} gives a detailed account of BML,
describing its syntax and semantics, while Section~\ref{SecClassfile}
proposes a format to store BML specifications in a class
file. Section~\ref{SecJMLtoBML} discusses the compilation from JML to
BML, while Section~\ref{SecConcl} wraps up and discusses tool support
and related and future work.


