\section{Compiling JML Specifications into BML Specifications}\label{SecJMLtoBML} 

Since it is often easier and more intuitive to specify and verify at
source code level, we have defined a compiler from JML to BML:
\JMLtoBML. BML is designed to be very close to JML, so the
correspondence between the original and the compiled specification
is straightforward. Notice that in principle, the same can be
done for the proofs,
\emph{i.e.}\ a source code level proof can be compiled into a
bytecode level proof. It is future work to define this in full detail,
but some work in this direction has already been
done~\cite{BartheRS05}.

The JML specification is compiled separately from the Java source
code. In fact, \JMLtoBML takes as input an annotated Java source file
\emph{and} the Java class file produced by a non-optimising compiler
with the debug flag set. %This debug information helps us to compile
%the annotations correctly.

From the debug information, we use in particular the
\textbf{Line\_ Number\_Table} and the \textbf{Local\_Variable\_Table}
attributes. The presence of these attributes is
optional~\cite{JVMspec}, but almost all standard non-optimising
compilers can generate them. The \textbf{Line\_Number\_Table} links
line numbers in the Java source code with the Java bytecode
instructions.  The
\textbf{Local\_Variable\_Table} describes the local variables that
appear in a method.  

To compile loop invariants appropriately, the control flow graph
corresponding to the list of bytecode instructions resulting from the
compilation of a method body must be a
\emph{reducible control flow graph}, \emph{i.e.}\ every 
cycle in the graph must have exactly one entry point
(see~\cite{AhoSU86}). Note that this is not a serious restriction; all
non-optimising Java compilers produce reducible control flow graphs
and in practice even most hand-written bytecode is reducible.

The compilation from JML specifications into BML is defined in several
steps. As mentioned above, we assume that the Java source code has
been compiled with the debug flag set, and that we have access to the
generated class file.

\begin{description}

\item[Compilation of ghost and model field declarations] 
Ghost and model variables declared in the specification are
compiled into the special class attributes that contain all ghost
variable and model variable declarations. 
%entries are added in the constant pool. 

%\item [Desugaring of the JML specification] This is an optional step,
%to achieve more compact specifications directly. Here one would use
%the standard JML procedure for desugaring~\cite{RaghavanL00}. This
%desugaring can also be applied later on the BML specification directly.

\item[Linking and resolving of source data structures]
The JML specification is transformed into an intermediate format,
where the identifiers are resolved to their corresponding data
structures in the class file.  The Java and JML source identifiers are
linked to their identifiers on bytecode level, \emph{i.e.}\ the
corresponding indexes either from the second constant pool or from the
\textbf{Local\_Variable\_Table} attribute. This is similar to the
linking and resolving stage of the Java source code compiler.

\item[Locating instructions for annotation statements] 
Annotation statements, like loop specifications and asserts are
associated with the appropriate point in the bytecode program, using
the \textbf{Line\_Number\_Table} attribute.

A problem is that a source line may correspond to more than one
instruction in the \textbf{Line\_Number\_Table}. This makes it
complicated to identify the exact loop entry instruction in the
bytecode, and thus to know to which instruction the compiled loop
specification should be associated. To solve this, we use the
following heuristics: if the control flow graph of the bytecode is
reducible and we search from an index in the \textbf{Line\_Number\_
Table} that corresponds to the first line of a source loop, then the
first loop entry instruction found will be the loop entry
corresponding to this source loop.  We do not have a formal
correctness proof for this algorithm, because it depends on the
particular implementation of the compiler, but experiments show that
the heuristic works successfully for Sun's non-optimising Java
compiler.
 
\item[Compilation of JML predicates]
JML predicates are Java boolean expressions. However, the JVM does not
provide direct support for several integral types, such as byte,
short, char, or for booleans. Instead, they are encoded as integers.
Therefore, the compiler wraps up the boolean expressions in the JML
specification by a conditional function, returning 1 if the predicate
is true, 0 otherwise.

\item[Generation of user-specific class attributes]
Finally, the complete specification is compiled into appropriate
user-specific attributes, using the format defined in the previous
section. 
    
\end{description}

