\section{Related Work} \label{relWork}


We now review research works which treat similar problematic.
%: logic for unstructured program languages, 
%compiling specification, architecture for checking untrusted components.

% Bytecode verification is concerned with establishing that a bytecode is well typed 
%(every instruction is applied to operands of the correct type) and well formed 
%(e.g. no jumps to an un-existing bytecode index), differently from the goals of the present
%work where program correctness is defined in terms of functional correctness. The Java Virtual Machine (JVM), for example, is provided with a bytecode verifier. 
%The field is well researched and for more information one can look at~\cite{Ljbc}.  

%Floyd is among the first to work on program verification for unstructured languages (see \cite{F67amp}).
%Few works have been dedicated to the definition of a bytecode logic. In \cite{Quigley}, Quigley defines a Hoare logics for bytecode programs. 
% This work is limited to a subset of the Java virtual machine instructions and does not treat for example method calls, 
% neither exceptional termination. The logic is defined by searching a structure in the bytecode control flow graph, 
% which gives an issue to complex rules.
JVer \cite{DBLP:conf/cav/ChanderEILN05} is a tool for verifying that downloaded Java bytecode programs do not abuse client computational resources. The bytecode programs are annotated with pre and postconditions written in a subset of JML specification language. The tool, however, doesnot support a compiler from high level specification annotations into bytecode annotations.  

 
In~\cite{BM05plb}, P.Muller and F.Bannwart define a Hoare logic over a 
bytecode language with objects and  exceptions. A compiler from source proofs into bytecode proofs is also defined.
 To our knowledge, subroutines are not treated. Invariants are inferred by fixpoint calculation, differently 
from the approach presented here, where all specification clauses including
loop invariants are compiled from the high level JML specification (see section \ref{comJML}). 
%However, inferring invariants is not a decidable problem.% The work of P.Muller and F.Bannwart is inspired by the Nick Benton's work (see ~\cite{B04tlsj}). 
%In the latter a bytecode logic for a stack based language is defined which checks programs both for well --- typedness and functional correctness. 
% The language does not support objects, references, exceptions neither subroutines.
%In ~\cite{WildmoserN-ESOP05}, M. Wildmoser and T. Nipkow describe a framework for verifying Jinja (a Java subset) bytecode 
%against arithmetic overflow.  The annotation is written manually, which is not comfortable, especially on bytecode. 
%Here we propose a way to compile a specification written in a high level language, allowing specification to be written at source level, which we consider as more convenient.
 
%The Spec\# \cite{BLS04sp} programming system developed at Microsoft proposes a static verification framework where 
% the method and class contracts are inserted in the intermediate code. Spec\# is a superset of the C\# programming language, with a built-in  specification language,
%which proposes a verification framework (supports both runtime and static checking). The static verification procedure  involves translation of the contract specification into metadata which is attached to the intermediate code and the verification is performed over the bytecode by the Boogie theorem prover.

 The traditional PCC and the certifying compiler proposed by Necula (see \cite{ComNec,DesNecLee98}) is an architecture for 
 establishing trust in unknown code in which the code producer accompanies the code with a proof certificate. Differently from our approach,
  as the certifying compiler infers automatically a type specification such as loop invariants and generates automatically
 the proof certificate it is not applicable for complex security policies.

There are also other close areas to our work, but we do not describe them because of space limitations.
Among them are bytecode verification for which Xavier Leroy in  ~\cite{Ljbc} gives detailed overview, 
the definition of bytecode logic e.g. the work of C. Quigley \cite{Quigley} where a Hoare style bytecode logic is defined and
the research of Nick Benton (see ~\cite{B04tlsj}) which combines both functional correctness and well typedness for a stack based bytecode language. 
The curious reader may also take a look at Spec\# \cite{BLS04sp} which is a static verification framework and
 where the method and class contracts are inserted in the intermediate code and the verification is done over the intermediate code. 



 
