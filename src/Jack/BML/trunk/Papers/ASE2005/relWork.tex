\section{Related Work} \label{relWork}
    
There are several fields which are related to the present work: bytecode verification, logic for unstructured program languages, attaching specification to the compiled code, architecture for checking untrusted components.

 Bytecode verification is concerned with establishing that a bytecode is well typed 
(every instruction is applied to operands of the correct type) and well formed 
(e.g. no jumps to an un-existing bytecode index), differently from the goals of the present
work where program correctness is defined in terms of functional correctness. The Java Virtual Machine (JVM), for example, is provided with a bytecode verifier. 
The field is well researched and for more information one can look at~\cite{Ljbc}.  

Floyd is among the first to work on program verification for unstructured languages (see \cite{F67amp}).
Few works have been dedicated to the definition of a bytecode logic. In \cite{Quigley}, Quigley defines a Hoare logics for bytecode programs. 
 This work is limited to a subset of the Java virtual machine instructions and does not treat for example method calls, 
 neither exceptional termination. The logic is defined by searching a structure in the bytecode control flow graph, 
 which gives an issue to complex rules.

A work close to ours is presented in~\cite{BM05plb} by P.Muller and F.Bannwart. The authors define a Hoare logic over a 
bytecode language with objects and  exceptions. A compiler from source proofs into bytecode proofs is also defined. 
As in our work, they assume that the bytecode has passed the bytecode verification certification. The bytecode logic aims to 
express functional properties. To our knowledge subroutines are not treated. Invariants are inferred by fixpoint calculation, differently 
from the approach presented here, where invariants are compiled from the high level JML specification (see section \ref{comJML}). 
However, inferring invariants is not a decidable problem. The work of P.Muller and F.Bannwart is inspired by the Nick Benton's work (see ~\cite{B04tlsj}). 
In the latter a bytecode logic for a stack based language is defined which checks programs both for well --- typedness and functional correctness. 
 The language does not support objects, references, exceptions neither subroutines. 

In ~\cite{WildmoserN-ESOP05}, M. Wildmoser and T. Nipkow describe a framework for verifying Jinja (a Java subset) bytecode 
against arithmetic overflow.  The annotation is written manually, which is not comfortable, especially on bytecode. 
Here we propose a way to compile a specification written in a high level language, allowing specification to be written at source level, which we consider as more convenient.

 The Spec\# (\cite{BLS04sp}) programming system developed at Microsoft proposes a static verification framework where 
 the method and class contracts  (pre, post conditions, exceptional postconditions, class invariants) are inserted in the intermediate code . 
 Spec\# is a superset of the C\# programming language, with a built-in  specification language,
which proposes a verification framework (there is a choice to perform the checks either at runtime or statically). 
 The static verification procedure  involves translation of the contract specification into metadata which is attached to the intermediate code 
 and the verification is performed over the bytecode by the Boogie theorem prover.

Another topic related to the present work is PCC.
 PCC and the certifying compiler were proposed by Necula (see \cite{Necula97,ComNec,DesNecLee98}). PCC is an architecture for establishing trust in untrusted code 
in which the code producer supplies a proof for correctness with the code. 
%In this architecture it is the certifying compiler that infers 
%automatically a type specification (e.g. loop invariants) and then generates automatically a proof for the code correctness. 
The initial idea for PCC  was that the producer automatically infers annotation for properties like well typedness, 
correct read/writes and automatically generates the proof for their correctness using the certifying compiler. 
Such properties guarantee that a program do the things correctly and not that it does the right things. The present work is targeting at a
 framework for establishing complex functional and interface properties whose automatic checking is hard and even impossible. 
 From the above cited papers, \cite{BM05plb} is aiming also at building PCC for
 guaranteeing not trivial properties. As we stated in section \ref{architecture}, our framework currently does not support adding proofs to bytecode 
 which but we consider this point as a future work. 
 
