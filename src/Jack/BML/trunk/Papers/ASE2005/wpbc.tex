
\section{Weakest Precondition \\Calculus For Java Bytecode}\label{wpbc}
In this section, we define a bytecode logic in terms of a weakest precondition calculus.
We assume that the bytecode program has passed the bytecode verification procedure,
 thus the calculus is concerned only with program functional properties. We also assume that code is generated by a non optimizing compiler. 

The proposed weakest precondition has those features:
\begin{itemize}
%\item modular, design by contract verification, in particular every method is verified separately method calls being translated to their specification 
\item it supports all Java sequential instructions except for floating point arithmetic instructions and 64 bit data (\java{long} and \java{double} types), including 
exceptions, object creation, references and subroutines. The calculus is defined over the method control flow graph

\item it supports BCSL annotations (section \ref{bcSpecLg}), i.e. bytecode method's specification like pre- and postconditions, class invariants, assertions at particular program point among 
which loop invariants (if there is no explicite specification  the default one is taken into account: preconditions, postconditions and invariants are taken to be true, exceptional postcondition is false) is taken into account. %The verification procedure assumes that the bytecode is specified enough, i.e. we do not try to infer specification, as we assume that they are compiled from the source program
\end{itemize}

The calculus is defined over the control flow graph of the program and has two levels of definitions --- the first one is the set of rules for sequential Java bytecode instructions (discussed in subsection~\ref{wpInstr} ) and the second one takes into account how control
 flows in the bytecode (subsection~\ref{wpGraph}).
Loops are treated by transforming the control flow graph into an abstract acyclic graph (by eliminating the backedges). As we mentioned earlier we assume that every method is specified enough, i.e. for each loop, the corresponding invariant is present. Thus, the eliminated edges are replaced by the corresponding loop invariant. 
 The verification conditions are generated over the abstract control flow graph. Subsection~\ref{abstrCntrFlow} discusses 
how the abstract control flow graph is generated.

We have the proof of soundness of the \wpi \ predicate transformer. The proof is done w.r.t. to the operational semantics of the sequential Java bytecode
subset and establishes that if the verification conditions are provable this means that the method implementation respects the method specification.

%In the rest of the section we describe the bytecode logic  and how the verification conditions are generated:
% the weakest precondition rules for single Java bytecode instructions in subsection \ref{wpInstr}, 
% the method abstract control flow graph is explained in subsection ~\ref{abstrCntrFlow}, 
% the definition of the weakest precondition over the abstract control flow graph is discussed in ~\ref{wpGraph} where how exception handling and subroutines
%are described.



\input wpSingleInstr.tex
\input abstractCntrFlow.tex
\input wpOverGraph.tex

%\begin{center} \texttt{wp} : \texttt{STMT} $\longrightarrow$ \texttt{Predicate} $\longrightarrow$ \texttt{Predicate}\end{center}





