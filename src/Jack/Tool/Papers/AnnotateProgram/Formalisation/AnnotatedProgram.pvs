AnnotatedProgramSemantics[Name : TYPE+] : THEORY
BEGIN

  IMPORTING State[Name]

  % Annoted Program State contains ghost variables, fields and local variables
  APState : TYPE = [# gvs : Store, pstate : PState #]

  IMPORTING SemanticsTypes[Name, Program, APState,
                           id, LAMBDA (s : APState) : pstate(s)],
            SemanticsJMLTypes[Name, APState, LAMBDA (s : APState) : gvs(s)]

  % lifting of program state update
  update_PState : (update_PState_type) = 
    LAMBDA (s : APState, upd : [PState -> PState]) :     
      s WITH [pstate := upd(pstate(s))]

  % lifting of ghost variables update
  update_GhostVars : (update_GhostVars_type) =
    LAMBDA (s : APState, upd : [Store -> Store])  : 
      s WITH [gvs := upd(gvs(s))]

  IMPORTING SemanticsJML[Name, Program, APState, id,
                         LAMBDA (s : APState) : pstate(s),
                         update_PState,
                         LAMBDA (s : APState) : gvs(s),
                         update_GhostVars],
            Semantics[Name, Program, APState, id,
                      LAMBDA (s : APState) : pstate(s),
                      lookup,
                      update_PState,
                      execute_set,
                      execute_assert,
                      execute_CaseJML,
                      on_method_entry,
                      on_method_exit_normal,
                      on_method_exit_exceptional]

  % wf state in annotated program:
  % program state wellformed, and ghost variable state wellformed
  wf_state(p : Program)(sigma : APState) : boolean =
    wf_state(p)(pstate(sigma)) AND
    wf_ghoststate(p)(sigma)

  % initial state of annotated program:
  % intitial program state and all declared ghost variables initialised
  % to their initial value (all non-declared ghost variables map to Bottom
  initial_AP_state(p : Program)(this_val : Val) : APState =
    (# pstate := initial_Program_state(p)(this_val),
       gvs := LAMBDA (n : Name) :
         LET gd = get_GhostDecl(n, p) IN
         IF bottom?(gd)
         THEN Bottom
         ELSE init_val(down(gd))
         ENDIF
    #)


  % a program body has no side-effects if it does not change the state at all
  body_has_no_side_effects(p : Program)(b : (wf_Body(p))) : boolean =
    FORALL (s1, s2 : APState, v : Val, n : nat) :
      wf_state(p)(s1) IMPLIES
      derive(p)(b, s1, v, s2)(n) IMPLIES
        s1 = s2

  % running annotated program: run main method, starting in 
  % initial annotated program state
  run_annotated_program(p : Program)(main : Name, arg : int)
                       (this_val : Val)(final : APState) : boolean =
    run_FullProgram(p)(main, arg)(initial_AP_state(p)(this_val), final)


  IMPORTING SemanticsProofs[Name, Program, APState, id,
                      LAMBDA (s : APState) : pstate(s),
                      lookup,
                      update_PState,
                      execute_set,
                      execute_assert,
                      execute_CaseJML,
                      on_method_entry,
                      on_method_exit_normal,
                      on_method_exit_exceptional]


  % Well-formedness properties

  % all declared variables are either ghost, local or field
  wf_state_vars_tricotomy : LEMMA % :-)
    FORALL (p : Program, s : APState, vn : Name) :
      wf_state(p)(s) IMPLIES
      ext_declared_var_names(p)(vn) IMPLIES
        is_ghost(vn, s) OR
        is_field(vn, pstate(s)) OR
        is_local(vn, pstate(s))

  % ghost variables are not local or fields
  wf_state_ghost_not_local_or_field : LEMMA % :-)
    FORALL (p : Program, s : APState, vn : Name) :
      wf_state(p)(s) IMPLIES
      wf_Program(p) IMPLIES
      is_ghost(vn, s) IMPLIES 
        NOT is_local(vn, pstate(s)) AND NOT is_field(vn, pstate(s))

  % wf_state preserved by update_PState (provided update preserves
  % wf_state on program state)
   wf_update_PState : LEMMA % :-)
     FORALL (p : Program, s1 : APState, 
             upd : [PState[Name] -> PState[Name]]) :
       wf_state(p)(s1) IMPLIES
       LET s2 = update_PState(s1, upd) IN
       (wf_state(p)(pstate(s1)) IMPLIES wf_state(p)(pstate(s2))) IMPLIES
       wf_state(p)(s2)

   % wf_state preserved by update_GhostVars (provided update preserves
   % wf_ghost_state)
   wf_update_GhostVars : LEMMA % :-)
     FORALL (p : Program, s1 : APState, 
             upd : [Store -> Store]) :
       wf_state(p)(s1) IMPLIES
       LET s2 = update_GhostVars(s1, upd) IN
       (wf_ghoststate(p)(s1) IMPLIES wf_ghoststate(p)(s2)) IMPLIES
       wf_state(p)(s2)

  % wf_state preserved by update_stack abbreviation
  % provided all local variables are declared
  wf_state_update_stack : LEMMA % :-)
    FORALL(p : Program, this_val : Val, arg : (getLocalDecls(p)), 
           param_val : Val, lvds : finite_set[Decl], s : APState) : 
      wf_state(p)(s) IMPLIES
      (FORALL (l : Decl) : lvds(l) IMPLIES getLocalDecls(p)(l)) IMPLIES
        wf_state(p)(update_stack(this_val, arg, param_val, lvds, s))

  % initial annotated program state is wellformed
  wf_initial_AP_state : LEMMA % :-)
    FORALL (p : Program)(this_val : (defined?)) :
      wf_Program(p) IMPLIES wf_state(p)(initial_AP_state(p)(this_val))

  % wf_state preserved by derve
  derive_yields_wf_state_AP : LEMMA % :-)
    FORALL (p : Program, b : (wf_Body(p)), v : Val)
           (sigma1, sigma2 : APState, n : nat) :
      wf_Program(p) IMPLIES
      wf_state(p)(sigma1) IMPLIES
      derive(p)(b, sigma1, v, sigma2)(n) IMPLIES
        wf_state(p)(sigma2)

  % on_method_entry preserves wf_state
  on_method_entry_yields_wf_state_AP : LEMMA % :-)
    FORALL (p : Program, m : (wf_Method(p)), a : Val)
           (arg : ValOrExcpt, sigma1, sigma2 : APState, n : nat) :
      wf_Program(p) IMPLIES
      wf_state(p)(sigma1) IMPLIES
        on_method_entry(p, m, a, arg, sigma1, sigma2, n, 
        LAMBDA (k : upto(n))(p : Program)
               (b : (wf_Body(p)), sigma1 : APState, v : Val, 
                sigma2 : APState)(m : below(k)) :
               derive(p)(b, sigma1, v, sigma2)(m)) IMPLIES
        wf_state(p)(sigma2)

  % on_method_exit_normal preserves wf_state
  on_method_exit_normal_yields_wf_state_AP : LEMMA % :-)
    FORALL (p : Program, m : (wf_Method(p)), a : Val)
           (arg : ValOrExcpt, sigma1, sigma2 : APState, n : nat) : 
      wf_Program(p) IMPLIES
      wf_state(p)(sigma1) IMPLIES
        on_method_exit_normal(p, m, a, arg, sigma1, sigma2, n, 
        LAMBDA (k : upto(n))(p : Program)
               (b : (wf_Body(p)), sigma1 : APState, v : Val, 
                sigma2 : APState)(m : below(k)) :
               derive(p)(b, sigma1, v, sigma2)(m)) IMPLIES
        wf_state(p)(sigma2)

  % on_method_exit_exceptional preserves wf_state
  on_method_exit_exceptional_yields_wf_state_AP : LEMMA % :-)
    FORALL (p : Program, m : (wf_Method(p)), a : Val)
           (arg : ValOrExcpt, sigma1, sigma2 : APState, n : nat) : 
      wf_Program(p) IMPLIES
      wf_state(p)(sigma1) IMPLIES
        on_method_exit_exceptional(p, m, a, arg, sigma1, sigma2, n, 
        LAMBDA (k : upto(n))(p : Program)
               (b : (wf_Body(p)), sigma1 : APState, v : Val, 
                sigma2 : APState)(m : below(k)) :
               derive(p)(b, sigma1, v, sigma2)(m)) IMPLIES
        wf_state(p)(sigma2)


  % The following are adapted versions for AP to avoid having to give all the 
  % theory parameters to uniquely identify them.

  on_method_entry_AP : (on_method_event_type) =
    LAMBDA (p : Program, md : (wf_Method(p)), a : Val, 
            arg : ValOrExcpt, s1, s2 : APState, n : nat,
            derive_rec : derive_rec_type(n)) :
      on_method_entry(p, md, a, arg, s1, s2, n, derive_rec)

  determ_step_AP : LEMMA % :-)
    FORALL (p : Program)(n1, n2 : nat)(b : (wf_Body(p)))
           (v1, v2 : Val, sigma, sigma1, sigma2 : APState) :
      derive(p)(b, sigma, v1, sigma1)(n1) IMPLIES
      derive(p)(b, sigma, v2, sigma2)(n2) IMPLIES
        v1 = v2 AND sigma1 = sigma2 AND n1 = n2

  derive_bottom_iff_exception_step_AP : LEMMA % :-)
    FORALL (p : Program)(b : (wf_Body(p)))
           (sigma1, sigma2 : APState, v : Val, n : nat) :
      derive(p)(b, sigma1, v, sigma2)(n) IMPLIES
      Bottom?(v) = up?(ex(pstate(sigma2)))

END AnnotatedProgramSemantics


APSemanticsProperties[Name : TYPE+] : THEORY
BEGIN

  IMPORTING AnnotatedProgramSemantics[Name],
            listfuncs

  % The execution of a set statement that does not have vn as target and whose
  % source expression has no side-effects, does not change the value of vn.
  non_interference_of_set_stmt : LEMMA % :-)
    FORALL (p : Program, c : (Set?)) 
           (s1, s2 : APState, v : Val, n : nat)
           (vn : Name) :
      wf_Body(p)(c) IMPLIES
      wf_state(p)(s1) IMPLIES
      body_has_no_side_effects(p)(source(c)) IMPLIES
      derive(p)(c, s1, v, s2)(n) IMPLIES
      NOT target(c) = vn IMPLIES
        gvs(s1)(vn) = gvs(s2)(vn)

  % Suppose we evaluate a CaseJML instruction, starting in a 
  % non-exceptional state s
  % Suppose there is branch b1 whose condition has no side-effects and holds 
  % in s, and all branches before b1 have no side-effect (and hence do not 
  % throw exceptions), and do not hold in s (i.e., b1 is the first branch
  % where the condition holds).
  % Then the statement associated with b1 will be eventually evaluated 
  % and the resulting state and value (Unit) of this evaluation will be 
  % the same as the respective state and value for the whole CaseJML statement.
  CaseJML_exclusive_branches_semantics : LEMMA % :-)
    FORALL (p : Program, bs : list[[Expr, Stmt]], s1, s2 : APState,
            v : Val, n : nat, b1 : [(wf_Expr(p)), (wf_Stmt(p))]) :
      wf_Branches(p)(bs) IMPLIES
      NOT up?(ex(pstate(s1))) IMPLIES
      member(b1, bs) IMPLIES
      (FORALL (tau : APState, v : Val, m1 : below(n)) :
        (derive(p)(PROJ_1(b1), s1, v, tau)(m1) IMPLIES
          s1 = tau AND v = Bool(TRUE))) IMPLIES
      (FORALL (b2 : [(wf_Expr(p)), (wf_Stmt(p))], tau : APState, 
               v : Val, m2 : below(n)) :
        before(b2, b1, bs) IMPLIES
        (derive(p)(PROJ_1(b2), s1, v, tau)(m2) IMPLIES
          s1 = tau AND v = Bool(FALSE))) IMPLIES
        derive(p)(CaseJML(bs), s1, v, s2)(n) IMPLIES
          EXISTS (n1 : nat) :
            derive(p)(PROJ_2(b1), s1, v, s2)(n1)


END APSemanticsProperties
