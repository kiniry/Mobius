(EventType)
(MVA
 (get_MVAVarDecl_TCC1 0
  (get_MVAVarDecl_TCC1-1 nil 3411366436 3430124165 ("" (subtype-tcc) nil nil)
   proved-complete
   ((member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil))
   23 20 nil nil)))
(WellFormedMVA)
(MVAProperties)
(MVACommonSemantics
 (execute_action_TCC1 0
  (execute_action_TCC1-1 nil 3411366856 3430124165 ("" (subtype-tcc) nil nil)
   proved-complete nil 55 10 nil nil))
 (execute_action_TCC2 0
  (execute_action_TCC2-1 nil 3411366856 3430124165
   ("" (termination-tcc) nil nil) proved-complete
   ((length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   25 20 nil nil))
 (execute_action_yields_wf_state 0
  (execute_action_yields_wf_state-1 nil 3411366948 3430124165
   ("" (induct "l")
    (("1" (skosimp)
      (("1" (expand "execute_action") (("1" (propax) nil nil)) nil)) nil)
     ("2" (skosimp*)
      (("2" (expand "execute_action" 1)
        (("2" (inst?)
          (("2" (assert)
            (("2" (split)
              (("1" (hide -1 -2 2)
                (("1" (expand "wf_Action")
                  (("1" (skosimp)
                    (("1" (inst?)
                      (("1" (expand "member" -2) (("1" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2" (expand* "wf_store" "wf_Action")
                  (("2" (skosimp)
                    (("2" (inst?)
                      (("2" (inst?)
                        (("2" (expand* "member" "update_store")
                          (("2" (lift-if)
                            (("2" (split 1)
                              (("1" (skosimp*)
                                (("1" (use "eval_yields_not_bottom")
                                  (("1" (assert) nil nil)) nil))
                                nil)
                               ("2" (skosimp*)
                                (("2" (split 2)
                                  (("1" (propax) nil nil)
                                   ("2" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved-incomplete
   ((update_store const-decl "Store" State nil)
    (Body type-decl nil Body_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Plus? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (NumVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Neg? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Conj? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Eq? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (BoolVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (RefVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Assign? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (CondExpr? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (MethodCall? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Const? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (eval const-decl "Val" MVACommonSemantics nil)
    (member def-decl "bool" list_props nil)
    (eval_yields_not_bottom formula-decl nil MVACommonSemantics nil)
    (list_induction formula-decl nil list_adt nil)
    (Name formal-nonempty-type-decl nil MVACommonSemantics nil)
    (Expr type-eq-decl nil Body_adt nil)
    (CP formal-nonempty-type-decl nil MVACommonSemantics nil)
    (OneAction type-eq-decl nil MVA nil)
    (execute_action def-decl "Store" MVACommonSemantics nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_PSt const-decl "boolean" MVACommonSemantics nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (wf_store const-decl "boolean" State nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Store type-eq-decl nil State nil) (MVA type-eq-decl nil MVA nil)
    (Decl type-eq-decl nil Program nil) (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Action type-eq-decl nil MVA nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   377 340 t nil))
 (initial_MVA_state_TCC1 0
  (initial_MVA_state_TCC1-1 nil 3411367276 3430124165
   ("" (subtype-tcc) nil nil) proved-complete
   ((member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil))
   82 80 nil nil))
 (wf_initial_MVA_state 0
  (wf_initial_MVA_state-1 nil 3411367324 3430124166
   ("" (skosimp*)
    (("" (expand* "wf_AState" "initial_MVA_state" "wf_MVA")
      (("" (flatten)
        (("" (assert)
          (("" (expand "wf_store")
            (("" (skosimp*)
              (("" (expand "defined?")
                (("" (lift-if)
                  (("" (assert)
                    (("" (split 2)
                      (("1" (skosimp*) (("1" (grind) nil nil)) nil)
                       ("2" (skosimp*)
                        (("2"
                          (typepred
                           "init_val(down(get_MVAVarDecl(vn!1, a!1)))")
                          (("2" (expand "defined?")
                            (("2" (assert)
                              (("2" (expand "get_MVAVarDecl" 2)
                                (("2" (lift-if)
                                  (("2" (assert)
                                    (("2" (split 2)
                                      (("1" (propax) nil nil)
                                       ("2"
                                        (expand "empty?")
                                        (("2"
                                          (expand "member")
                                          (("2"
                                            (skosimp*)
                                            (("2"
                                              (expand "var_names")
                                              (("2"
                                                (inst?)
                                                (("2" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved-incomplete
   ((initial_MVA_state const-decl "AState" MVACommonSemantics nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (finite_intersection1 application-judgement "finite_set" finite_sets nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (subset? const-decl "bool" sets nil) (union const-decl "set" sets nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (disjoint? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (get_MVAVarDecl const-decl "lift[Decl]" MVA nil)
    (CP formal-nonempty-type-decl nil MVACommonSemantics nil)
    (Name formal-nonempty-type-decl nil MVACommonSemantics nil)
    (choose const-decl "(p)" sets nil) (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil) (Val type-decl nil Val_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (JType type-decl nil JType_adt nil) (Decl type-eq-decl nil Program nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (MVA type-eq-decl nil MVA nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (epsilon const-decl "T" epsilons nil)
    (pred type-eq-decl nil defined_types nil)
    (down adt-accessor-decl "[(up?) -> T]" lift_adt nil)
    (up? adt-recognizer-decl "[lift -> boolean]" lift_adt nil)
    (lift type-decl nil lift_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (defined? const-decl "boolean" ValProp nil)
    (wf_store const-decl "boolean" State nil))
   871 760 t nil)))
(MVAPartialSemantics
 (step_TCC1 0
  (step_TCC1-1 nil 3411367277 3430124167 ("" (subtype-tcc) nil nil)
   proved-complete
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Name formal-nonempty-type-decl nil MVAPartialSemantics nil)
    (CP formal-nonempty-type-decl nil MVAPartialSemantics nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (EventType type-decl nil EventType_adt nil)
    (Event type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Transition type-eq-decl nil MVA nil)
    (Val type-decl nil Val_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (JType type-decl nil JType_adt nil) (Decl type-eq-decl nil Program nil)
    (MVA type-eq-decl nil MVA nil) (Store type-eq-decl nil State nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (wf_PSt const-decl "boolean" MVACommonSemantics nil)
    (wf_store const-decl "boolean" State nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil))
   483 440 nil nil))
 (step_yields_wf_state 0
  (step_yields_wf_state-1 nil 3411367568 3430124167
   ("" (skolem-typepred)
    (("" (skosimp*)
      (("" (expand* "wf_AState" "wf_PEvent" "step")
        (("" (lift-if)
          (("" (assert)
            ((""
              (apply (branch (split -4)
                      ((then (flatten) (assert) (flatten) (assert)))))
              ((""
                (apply (branch (split 1)
                        ((then (flatten) (assert) (flatten) (assert)))))
                (("" (hide -2)
                  ((""
                    (name "t1" "choose(LAMBDA (t: Transition):
                                                                  ts(a!1)(t) AND
                                                                  scp(t) = cp(s!1) AND
                                                                  event(t) = event(pe!1) AND
                                                                  guard(t)(stA(s!1), stP(pe!1), arg(pe!1)))")
                    (("1" (replace -1)
                      (("1" (hide -2)
                        (("1" (assert)
                          (("1" (expand "wf_MVA")
                            (("1" (flatten)
                              (("1" (inst -10 "t1")
                                (("1" (assert)
                                  (("1" (expand "wf_Trans")
                                    (("1" (flatten)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (use
                                           "execute_action_yields_wf_state")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (rewrite "nonempty_exists")
                      (("2" (skosimp*)
                        (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved-incomplete
   ((nonempty_exists formula-decl nil sets_lemmas nil) nil nil nil nil
    (execute_action_yields_wf_state formula-decl nil MVACommonSemantics nil)
    (Expr type-eq-decl nil Body_adt nil) (OneAction type-eq-decl nil MVA nil)
    (list type-decl nil list_adt nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (step const-decl "lift[AState]" MVAPartialSemantics nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (Store type-eq-decl nil State nil) (MVA type-eq-decl nil MVA nil)
    (Decl type-eq-decl nil Program nil) (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVAPartialSemantics nil)
    (Name formal-nonempty-type-decl nil MVAPartialSemantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   315 290 t shostak))
 (complete_definedness 0
  (complete_definedness-1 nil 3411708261 3430124167
   ("" (skosimp*)
    (("" (expand "step")
      (("" (lift-if)
        (("" (assert)
          (("" (split 1)
            (("1" (propax) nil nil)
             ("2" (typepred "a!1")
              (("2" (expand "complete")
                (("2" (flatten)
                  (("2" (expand "total")
                    (("2"
                      (inst -5 "cp(s!1)" "event(pe!1)" "stA(s!1)" "stP(pe!1)"
                       "arg(pe!1)")
                      (("2" (typepred "pe!1" "s!1")
                        (("2" (expand* "wf_PEvent" "wf_AState")
                          (("2" (flatten) (("2" (assert) nil nil)) nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved-incomplete
   ((step const-decl "lift[AState]" MVAPartialSemantics nil)
    (complete const-decl "boolean" MVAProperties nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVAPartialSemantics nil)
    (Name formal-nonempty-type-decl nil MVAPartialSemantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Store type-eq-decl nil State nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (total const-decl "boolean" MVAProperties nil))
   92 100 t shostak)))
(MVATotalSemantics
 (step_TCC1 0
  (step_TCC1-2 nil 3411367180 3430124167
   (";;; Proof for formula MVASemantics.step_TCC1" (skosimp*)
    ((";;; Proof for formula MVASemantics.step_TCC1" (typepred "a!1")
      ((";;; Proof for formula MVASemantics.step_TCC1" (expand "total")
        ((";;; Proof for formula MVASemantics.step_TCC1" (typepred "s!1")
          ((";;; Proof for formula MVASemantics.step_TCC1"
            (expand "wf_AState")
            ((";;; Proof for formula MVASemantics.step_TCC1" (flatten)
              ((";;; Proof for formula MVASemantics.step_TCC1"
                (inst -3 "cp(s!1)" "event(pe!1)" "stA(s!1)" "stP(pe!1)"
                 "arg(pe!1)")
                ((";;; Proof for formula MVASemantics.step_TCC1" (assert)
                  ((";;; Proof for formula MVASemantics.step_TCC1"
                    (typepred "pe!1")
                    ((";;; Proof for formula MVASemantics.step_TCC1"
                      (expand "wf_PEvent")
                      ((";;; Proof for formula MVASemantics.step_TCC1"
                        (flatten)
                        ((";;; Proof for formula MVASemantics.step_TCC1"
                          (assert)
                          ((";;; Proof for formula MVASemantics.step_TCC1"
                            (skosimp*)
                            ((";;; Proof for formula MVASemantics.step_TCC1"
                              (rewrite "nonempty_exists")
                              ((";;; Proof for formula MVASemantics.step_TCC1"
                                (inst 1 "t!1")
                                ((";;; Proof for formula MVASemantics.step_TCC1"
                                  (assert) nil))))))))))))))))))))))))))))))
    "")
   proved-complete
   ((total const-decl "boolean" MVAProperties nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVATotalSemantics nil)
    (Name formal-nonempty-type-decl nil MVATotalSemantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (Store type-eq-decl nil State nil)
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (set type-eq-decl nil sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil) nil nil nil nil
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil))
   125 100 nil nil)
  (step_TCC1-1 nil 3411367080 3411367108 ("" (subtype-tcc) nil nil) unfinished
   nil 1421 1420 nil nil))
 (step_yields_wf_state 0
  (step_yields_wf_state-1 nil 3411367156 3430124168
   (";;; Proof for formula MVASemantics.step_yields_wf_state"
    (skolem-typepred)
    ((";;; Proof for formula MVASemantics.step_yields_wf_state"
      (expand* "wf_AState" "wf_PEvent" "step")
      ((";;; Proof for formula MVASemantics.step_yields_wf_state"
        (name "t1" "choose(LAMBDA (t: Transition):
                                                           ts(a!1)(t) AND
                                                           scp(t) = cp(s!1) AND
                                                           event(t) = event(pe!1) AND
                                                           guard(t)(stA(s!1), stP(pe!1), arg(pe!1)))")
        (("1" (replace -1)
          (("1" (skosimp*)
            (("1" (assert)
              (("1" (expand "wf_MVA")
                (("1" (flatten)
                  (("1" (inst -11 "t1")
                    (("1" (assert)
                      (("1" (expand "wf_Trans")
                        (("1" (flatten)
                          (("1" (assert)
                            (("1" (use "execute_action_yields_wf_state")
                              (("1" (assert) nil)))))))))))))))))))))))
         ("2" (use "step_TCC1") nil))))))
    "")
   proved-incomplete
   ((step const-decl "AState" MVATotalSemantics nil)
    (step_TCC1 subtype-tcc nil MVATotalSemantics nil)
    (execute_action_yields_wf_state formula-decl nil MVACommonSemantics nil)
    (Expr type-eq-decl nil Body_adt nil) (OneAction type-eq-decl nil MVA nil)
    (list type-decl nil list_adt nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (Store type-eq-decl nil State nil)
    (total const-decl "boolean" MVAProperties nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVATotalSemantics nil)
    (Name formal-nonempty-type-decl nil MVATotalSemantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   167 120 nil nil)))
(MVAMonitoring
 (guard_to_expression_TCC1 0
  (guard_to_expression_TCC1-2 nil 3411366716 3430124629
   ("" (inst 1 "LAMBDA(g : Guard)(v : ValOrExcpt) : Const(Unit)")
    (("" (expand "defined?") (("" (propax) nil nil)) nil)) nil)
   proved-complete
   ((Unit adt-constructor-decl "(Unit?)" Val_adt nil)
    (Unit? adt-recognizer-decl "[Val -> boolean]" Val_adt nil)
    (Const adt-constructor-decl "[(defined?) -> (Const?)]" Body_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Expr type-eq-decl nil Body_adt nil)
    (Const? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (MethodCall? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (CondExpr? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Assign? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (RefVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (BoolVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Eq? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Conj? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Neg? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (NumVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Plus? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Body type-decl nil Body_adt nil) (Guard type-eq-decl nil MVA nil)
    (CP formal-nonempty-type-decl nil MVAMonitoring nil)
    (boolean nonempty-type-decl nil booleans nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (Store type-eq-decl nil State nil) (Val type-decl nil Val_adt nil)
    (Name formal-nonempty-type-decl nil MVAMonitoring nil))
   8313 20 t nil)
  (guard_to_expression_TCC1-1 nil 3411366569 3411366576
   ("" (existence-tcc) nil nil) unfinished nil 142 140 nil nil)))
(MVACompletion
 (all_guards_TCC1 0
  (all_guards_TCC1-1 nil 3382264515 3433153539
   ("" (skosimp*)
    (("" (typepred "ts(a!1)")
      (("" (expand "is_finite")
        (("" (skosimp*)
          ((""
            (inst 1 "N!1" "LAMBDA(p : ({p: Guard[CP, Name] |
                     EXISTS (t: Transition[CP, Name]):
                       ts(a!1)(t) AND
                        scp(t) = cp!1 AND
                         event(t) = e!1 AND guard(t) = p})) : f!1(choose({t : Transition[CP, Name] | ts(a!1)(t) AND
                        scp(t) = cp!1 AND
                         event(t) = e!1 AND guard(t) = p}))")
            (("1" (expand "injective?")
              (("1" (skosimp*)
                (("1" (inst?)
                  (("1" (assert) nil nil)
                   ("2" (typepred "x2!1")
                    (("2" (rewrite "nonempty_exists")
                      (("2" (skosimp*)
                        (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
                      nil))
                    nil)
                   ("3" (typepred "x1!1")
                    (("3" (rewrite "nonempty_exists")
                      (("3" (skosimp*)
                        (("3" (inst?) (("3" (assert) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skosimp*)
              (("2" (typepred "p!1")
                (("2" (rewrite "nonempty_exists")
                  (("2" (skosimp*)
                    (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Event type-eq-decl nil MVA nil)
    (Action type-eq-decl nil MVA nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVACompletion nil)
    (p!1 skolem-const-decl "({p: Guard[CP, Name] |
    EXISTS (t: Transition[CP, Name]):
      ts(a!1)(t) AND scp(t) = cp!1 AND event(t) = e!1 AND guard(t) = p})"
     MVACompletion nil)
    (injective? const-decl "bool" functions nil)
    (x1!1 skolem-const-decl "({p: Guard[CP, Name] |
    EXISTS (t: Transition[CP, Name]):
      ts(a!1)(t) AND scp(t) = cp!1 AND event(t) = e!1 AND guard(t) = p})"
     MVACompletion nil)
    (x2!1 skolem-const-decl "({p: Guard[CP, Name] |
    EXISTS (t: Transition[CP, Name]):
      ts(a!1)(t) AND scp(t) = cp!1 AND event(t) = e!1 AND guard(t) = p})"
     MVACompletion nil)
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVACompletion nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVACompletion nil)
    (choose const-decl "(p)" sets nil) (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (Store type-eq-decl nil State nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (a!1 skolem-const-decl "MVA[CP, Name]" MVACompletion nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cp!1 skolem-const-decl "CP" MVACompletion nil)
    (e!1 skolem-const-decl "Event[CP, Name]" MVACompletion nil)
    (nonempty? const-decl "bool" sets nil))
   605 570 t nil))
 (big_and_TCC1 0
  (big_and_TCC1-1 nil 3433138744 3433153539 ("" (subtype-tcc) nil nil) proved
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (Val type-decl nil Val_adt nil)
    (Bool? adt-recognizer-decl "[Val -> boolean]" Val_adt nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil))
   65 40 nil nil))
 (big_and_TCC2 0
  (big_and_TCC2-1 nil 3433138744 3433153539
   ("" (skosimp*)
    (("" (rewrite "card_rest[(Bool?)]") (("" (assert) nil nil)) nil)) nil)
   proved
   ((card_rest formula-decl nil finite_sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (Val type-decl nil Val_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Bool? adt-recognizer-decl "[Val -> boolean]" Val_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   37 40 t nil))
 (big_and_is_forall 0
  (big_and_is_forall-1 nil 3433151051 3433151332
   ("" (use "finite_set_induction_rest[(Bool?)]")
    (("" (split -1)
      (("1" (propax) nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)
       ("3" (hide 2)
        (("3" (skosimp*)
          (("3" (expand "big_and" 1)
            (("3" (replace -1 :hide? t)
              (("3" (iff)
                (("3" (prop)
                  (("1" (skosimp*)
                    (("1" (inst -2 "v!1")
                      (("1" (assert)
                        (("1" (auto-rewrite "rest" "remove" "member")
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst?) (("2" (assert) nil nil)) nil)
                   ("3" (skosimp*)
                    (("3" (inst?)
                      (("3" (assert)
                        (("3" (auto-rewrite "rest" "remove" "member")
                          (("3" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set[(Bool?)]" MVACompletion nil)
    (empty? const-decl "bool" sets nil) (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (finite_remove application-judgement "finite_set[(Bool?)]" MVACompletion
     nil)
    (remove const-decl "set" sets nil) (rest const-decl "set" sets nil)
    (finite_rest application-judgement "finite_set[(Bool?)]" MVACompletion
     nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (pred type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (b adt-accessor-decl "[(Bool?) -> bool]" Val_adt nil)
    (big_and def-decl "(Bool?)" MVACompletion nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Bool? adt-recognizer-decl "[Val -> boolean]" Val_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-decl nil Val_adt nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (finite_set_induction_rest formula-decl nil finite_sets_inductions
     "finite_sets/"))
   115362 760 t shostak))
 (big_conj_TCC1 0
  (big_conj_TCC1-1 nil 3430127082 3433153539 ("" (subtype-tcc) nil nil) proved
   ((member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (defined? const-decl "boolean" ValProp nil))
   26 20 nil nil))
 (big_conj_TCC2 0
  (big_conj_TCC2-1 nil 3430127082 3433153539 ("" (subtype-tcc) nil nil) proved
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (Body type-decl nil Body_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Plus? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (NumVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Neg? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Conj? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Eq? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (BoolVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (RefVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Assign? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (CondExpr? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (MethodCall? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Const? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Expr type-eq-decl nil Body_adt nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil))
   29 30 nil nil))
 (big_conj_TCC3 0
  (big_conj_TCC3-1 nil 3430127082 3433153539
   ("" (skosimp*) (("" (use "card_rest[Expr]") (("" (assert) nil nil)) nil))
    nil)
   proved
   ((card_rest formula-decl nil finite_sets nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (Body type-decl nil Body_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Plus? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (NumVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Neg? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Conj? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Eq? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (BoolVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (RefVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Assign? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (CondExpr? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (MethodCall? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Const? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Expr type-eq-decl nil Body_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (finite_rest application-judgement "finite_set" finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   188 160 t nil))
 (build_guard_TCC1 0
  (build_guard_TCC1-1 nil 3433138744 3433153540
   ("" (skosimp*)
    (("" (typepred "all_guards(a!1)(cp!1, e!1)")
      (("" (expand "is_finite")
        (("" (skosimp*)
          ((""
            (inst 1 "N!1" "LAMBDA(v : ({v: (Bool?[Name]) |
                     EXISTS (p: Guard[CP, Name]):
                       all_guards(a!1)(cp!1, e!1)(p) AND
                        v = Bool[Name](NOT p(stA!1, stP!1, arg!1))})) : f!1(choose({p : Guard[CP, Name] | all_guards(a!1)(cp!1, e!1)(p) AND
                        v = Bool[Name](NOT p(stA!1, stP!1, arg!1))}))")
            (("1" (expand "injective?")
              (("1" (skosimp*)
                (("1" (inst?)
                  (("1" (assert) nil nil)
                   ("2" (rewrite "nonempty_exists")
                    (("2" (typepred "x2!1")
                      (("2" (skosimp*)
                        (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
                      nil))
                    nil)
                   ("3" (rewrite "nonempty_exists")
                    (("3" (typepred "x1!1")
                      (("3" (skosimp*)
                        (("3" (inst?) (("3" (assert) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skosimp*)
              (("2" (rewrite "nonempty_exists")
                (("2" (typepred "v!1")
                  (("2" (skosimp*)
                    (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Transition type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (Guard type-eq-decl nil MVA nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (Store type-eq-decl nil State nil) (Val type-decl nil Val_adt nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (p!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (v!1 skolem-const-decl "({v: (Bool?[Name]) |
    EXISTS (p: Guard[CP, Name]):
      all_guards(a!1)(cp!1, e!1)(p) AND
       v = Bool[Name](NOT p(stA!1, stP!1, arg!1))})" MVACompletion nil)
    (injective? const-decl "bool" functions nil)
    (x1!1 skolem-const-decl "({v: (Bool?[Name]) |
    EXISTS (p: Guard[CP, Name]):
      all_guards(a!1)(cp!1, e!1)(p) AND
       v = Bool[Name](NOT p(stA!1, stP!1, arg!1))})" MVACompletion nil)
    (x2!1 skolem-const-decl "({v: (Bool?[Name]) |
    EXISTS (p: Guard[CP, Name]):
      all_guards(a!1)(cp!1, e!1)(p) AND
       v = Bool[Name](NOT p(stA!1, stP!1, arg!1))})" MVACompletion nil)
    (p!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (p!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (choose const-decl "(p)" sets nil) (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (Bool? adt-recognizer-decl "[Val -> boolean]" Val_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (a!1 skolem-const-decl "MVA[CP, Name]" MVACompletion nil)
    (cp!1 skolem-const-decl "CP" MVACompletion nil)
    (e!1 skolem-const-decl "Event[CP, Name]" MVACompletion nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Bool adt-constructor-decl "[bool -> (Bool?)]" Val_adt nil)
    (stA!1 skolem-const-decl "Store[Name]" MVACompletion nil)
    (stP!1 skolem-const-decl "Store[Name]" MVACompletion nil)
    (arg!1 skolem-const-decl "ValOrExcpt[Name]" MVACompletion nil)
    (nonempty? const-decl "bool" sets nil))
   589 570 t nil))
 (complete_trans_TCC1 0
  (complete_trans_TCC1-4 nil 3428743396 3433153541
   ("" (skosimp*)
    (("" (use "finite_union[Transition[CP, Name]]")
      (("1" (hide 2)
        (("1" (typepred "evs(a!1)")
          (("1" (expand "is_finite")
            (("1" (skosimp*)
              (("1"
                (inst 1 "N!1" "LAMBDA(t1 : ({t: Transition[CP, Name] |
                                   scp(t) = halted[CP, Name] AND evs(a!1)(event(t))
                               AND guard(t) =
                                    (LAMBDA (stA, stP: Store[Name], arg : ValOrExcpt): TRUE)
                               AND action(t) = skip[CP, Name]
                               AND tcp(t) = halted[CP, Name]})) : f!1(event(t1))")
                (("1" (expand "injective?")
                  (("1" (skosimp*)
                    (("1" (apply-extensionality :hide? t)
                      (("1" (inst -1 "event(x1!1)" "event(x2!1)")
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (typepred "cps(a!1)")
          (("2" (typepred "evs(a!1)")
            (("2" (expand "is_finite")
              (("2" (skosimp*)
                (("2" (case "N!1 = 0")
                  (("1"
                    (inst 1 "N!2" "LAMBDA(t : ({t: Transition[CP, Name] |
                                            cps(a!1)(scp(t)) AND evs(a!1)(event(t))
                                        AND guard(t) = build_guard(a!1)(scp(t), event(t))
                                        AND action(t) = skip[CP, Name]
                                        AND tcp(t) = halted[CP, Name]})) : f!2(scp(t))")
                    (("1" (expand "injective?")
                      (("1" (skosimp*)
                        (("1" (typepred "f!1(x2!1`event)")
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2"
                    (inst 2 "N!1 + N!1 * N!2"
                     "LAMBDA(t : ({t: Transition[CP, Name] |
                                                cps(a!1)(scp(t)) AND evs(a!1)(event(t))
                                            AND guard(t) = build_guard(a!1)(scp(t), event(t))
                                            AND action(t) = skip[CP, Name]
                                            AND tcp(t) = halted[CP, Name]})) : f!1(event(t)) + N!1 * f!2(scp(t))")
                    (("1" (expand "injective?")
                      (("1" (skosimp*)
                        (("1"
                          (use "unique_quotient"
                               ("b" "N!1" "q1" "f!2(scp(x1!1))" "q2"
                                "f!2(scp(x2!1))" "r1" "f!1(event(x1!1))" "r2"
                                "f!1(event(x2!1))"))
                          (("1" (assert)
                            (("1" (inst -2 "event(x1!1)" "event(x2!1)")
                              (("1" (inst -3 "scp(x1!1)" "scp(x2!1)")
                                (("1" (assert)
                                  (("1" (apply-extensionality 2 :hide? t) nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skosimp*)
                      (("2" (typepred "f!1(event(t!1))")
                        (("2" (typepred "f!2(scp(t!1))")
                          (("2" (use "lt_plus_lt1")
                            (("2" (split -1)
                              (("1" (propax) nil nil) ("2" (assert) nil nil)
                               ("3" (use "both_sides_times_pos_lt2")
                                (("1" (assert) nil nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((finite_union judgement-tcc nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (Action type-eq-decl nil MVA nil) (Event type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Transition type-eq-decl nil MVA nil)
    (a!1 skolem-const-decl "MVA[CP, Name]" MVACompletion nil)
    (TRUE const-decl "bool" booleans nil) (halted const-decl "CP" MVA nil)
    (skip const-decl "Action" MVA nil) (list type-decl nil list_adt nil)
    (OneAction type-eq-decl nil MVA nil) (Expr type-eq-decl nil Body_adt nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (Store type-eq-decl nil State nil) (MVA type-eq-decl nil MVA nil)
    (Decl type-eq-decl nil Program nil) (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil)
    (EventType type-decl nil EventType_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (both_sides_times_pos_lt2 formula-decl nil real_props nil)
    (lt_plus_lt1 formula-decl nil real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (unique_quotient formula-decl nil euclidean_division nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (N!1 skolem-const-decl "nat" MVACompletion nil)
    (f!1 skolem-const-decl "[(evs(a!1)) -> below[N!1]]" MVACompletion nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (N!2 skolem-const-decl "nat" MVACompletion nil)
    (f!2 skolem-const-decl "[(cps(a!1)) -> below[N!2]]" MVACompletion nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   536 470 nil nil)
  (complete_trans_TCC1-3 nil 3382265153 3428742910
   ("" (skosimp*)
    (("" (use "finite_union[Transition[CP, Name]]")
      (("1" (hide 2)
        (("1" (typepred "evs(a!1)")
          (("1" (expand "is_finite")
            (("1" (skosimp*)
              (("1"
                (inst 1 "N!1" "LAMBDA(t1 : ({t: Transition[CP, Name] |
                               scp(t) = halted[CP, Name] AND evs(a!1)(event(t))
                           AND guard(t) =
                                (LAMBDA (stA: Store[Name], stP: PSt[Name], arg : ValOrExcpt): TRUE)
                           AND action(t) = skip[CP, Name]
                           AND tcp(t) = halted[CP, Name]})) : f!1(event(t1))")
                (("1" (expand "injective?")
                  (("1" (skosimp*)
                    (("1" (apply-extensionality :hide? t)
                      (("1" (inst -1 "event(x1!1)" "event(x2!1)")
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (typepred "cps(a!1)")
          (("2" (typepred "evs(a!1)")
            (("2" (expand "is_finite")
              (("2" (skosimp*)
                (("2" (case "N!1 = 0")
                  (("1"
                    (inst 1 "N!2" "LAMBDA(t : ({t: Transition[CP, Name] |
                                      cps(a!1)(scp(t)) AND evs(a!1)(event(t))
                                  AND guard(t) = build_guard(a!1)(scp(t), event(t))
                                  AND action(t) = skip[CP, Name]
                                  AND tcp(t) = halted[CP, Name]})) : f!2(scp(t))")
                    (("1" (expand "injective?")
                      (("1" (skosimp*)
                        (("1" (typepred "f!1(x2!1`event)")
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2"
                    (inst 2 "N!1 + N!1 * N!2"
                     "LAMBDA(t : ({t: Transition[CP, Name] |
                                          cps(a!1)(scp(t)) AND evs(a!1)(event(t))
                                      AND guard(t) = build_guard(a!1)(scp(t), event(t))
                                      AND action(t) = skip[CP, Name]
                                      AND tcp(t) = halted[CP, Name]})) : f!1(event(t)) + N!1 * f!2(scp(t))")
                    (("1" (expand "injective?")
                      (("1" (skosimp*)
                        (("1"
                          (use "unique_quotient"
                               ("b" "N!1" "q1" "f!2(scp(x1!1))" "q2"
                                "f!2(scp(x2!1))" "r1" "f!1(event(x1!1))" "r2"
                                "f!1(event(x2!1))"))
                          (("1" (assert)
                            (("1" (inst -2 "event(x1!1)" "event(x2!1)")
                              (("1" (inst -3 "scp(x1!1)" "scp(x2!1)")
                                (("1" (assert)
                                  (("1" (apply-extensionality 2 :hide? t) nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skosimp*)
                      (("2" (typepred "f!1(event(t!1))")
                        (("2" (typepred "f!2(scp(t!1))")
                          (("2" (use "lt_plus_lt1")
                            (("2" (split -1)
                              (("1" (propax) nil nil) ("2" (assert) nil nil)
                               ("3" (use "both_sides_times_pos_lt2")
                                (("1" (assert) nil nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((finite_union judgement-tcc nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (Action type-eq-decl nil MVA nil) (Event type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Transition type-eq-decl nil MVA nil)
    (TRUE const-decl "bool" booleans nil) (halted const-decl "CP" MVA nil)
    (skip const-decl "Action" MVA nil) (list type-decl nil list_adt nil)
    (OneAction type-eq-decl nil MVA nil) (Expr type-eq-decl nil Body_adt nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PSt type-eq-decl nil State nil) (Store type-eq-decl nil State nil)
    (MVA type-eq-decl nil MVA nil) (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil)
    (EventType type-decl nil EventType_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (both_sides_times_pos_lt2 formula-decl nil real_props nil)
    (lt_plus_lt1 formula-decl nil real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (unique_quotient formula-decl nil euclidean_division nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   595 490 t nil)
  (complete_trans_TCC1-2 nil 3382265133 nil ("" (skip) nil nil) unchecked nil
   nil nil nil nil)
  (complete_trans_TCC1-1 nil 3382264515 3382264991 ("" (subtype-tcc) nil nil)
   unfinished nil 32426 31994 nil nil))
 (big_conj_wf_Expr 0
  (big_conj_wf_Expr-1 nil 3433148042 3433153541
   ("" (skolem 1 "a!1" _)
    (("" (use "finite_set_induction_rest[Expr]")
      (("" (split -1)
        (("1" (propax) nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)
         ("3" (hide 2)
          (("3" (skosimp*)
            (("3" (split -1)
              (("1" (expand "big_conj" 1)
                (("1" (expand "wf_Expr")
                  (("1" (expand "wf_Body")
                    (("1" (inst -2 "choose(SS!1)")
                      (("1" (assert)
                        (("1" (flatten)
                          (("1" (split 1)
                            (("1" (expand "var_names" 1 1)
                              (("1" (auto-rewrite "subset?" "union" "member")
                                (("1" (assert)
                                  (("1" (skosimp*)
                                    (("1" (inst?)
                                      (("1"
                                        (inst? -4)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (split -1)
                                            (("1" (propax) nil nil)
                                             ("2" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (skosimp*)
                              (("2" (expand "subterm" -1)
                                (("2"
                                  (apply (branch
                                          (split -1)
                                          ((then
                                            (flatten)
                                            (assert)
                                            (flatten)
                                            (assert)))))
                                  (("1" (inst? -6) (("1" (assert) nil nil))
                                    nil)
                                   ("2" (inst?) (("2" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skosimp*)
                (("2" (inst?)
                  (("2" (assert)
                    (("2" (auto-rewrite "rest" "remove" "member")
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((finite_set_induction_rest formula-decl nil finite_sets_inductions
     "finite_sets/")
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (Body type-decl nil Body_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Plus? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (NumVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Neg? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Conj? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Eq? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (BoolVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (RefVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Assign? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (CondExpr? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (MethodCall? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Const? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Expr type-eq-decl nil Body_adt nil)
    (big_conj def-decl "Expr" MVACompletion nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (non_empty_finite_set type-eq-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil)
    (finite_rest application-judgement "finite_set[Expr]" MVACompletion nil)
    (finite_remove application-judgement "finite_set[Expr]" MVACompletion nil)
    (remove const-decl "set" sets nil) (rest const-decl "set" sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (finite_emptyset name-judgement "finite_set[Expr]" MVACompletion nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (var_names def-decl "[Name -> boolean]" ProgramFunctions nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (union const-decl "set" sets nil) (subset? const-decl "bool" sets nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (Const adt-constructor-decl "[(defined?) -> (Const?)]" Body_adt nil)
    (Bool? adt-recognizer-decl "[Val -> boolean]" Val_adt nil)
    (Bool adt-constructor-decl "[bool -> (Bool?)]" Val_adt nil)
    (TRUE const-decl "bool" booleans nil))
   945 870 t shostak))
 (guard_to_expression_build_guard_TCC1 0
  (guard_to_expression_build_guard_TCC1-1 nil 3430127082 3433153542
   ("" (skosimp*)
    (("" (typepred "all_guards(a!1)(cp!1, e!1)")
      (("" (expand "is_finite")
        (("" (skosimp*)
          ((""
            (inst 1 "N!1" "LAMBDA(expr : ({expr: Expr[Name] |
                       EXISTS (g: Guard[CP, Name]):
                         all_guards(a!1)(cp!1, e!1)(g) AND
                          expr = Neg(guard_to_expression[CP, Name](g)(v!1))})) : f!1(choose({g : Guard[CP, Name] |  all_guards(a!1)(cp!1, e!1)(g) AND
                          expr = Neg(guard_to_expression[CP, Name](g)(v!1))}))")
            (("1" (expand "injective?")
              (("1" (skosimp*)
                (("1" (inst?)
                  (("1" (assert) nil nil)
                   ("2"
                    (apply (then (rewrite "nonempty_exists") (typepred "x2!1")
                            (skosimp*) (inst?) (assert)))
                    nil nil)
                   ("3"
                    (apply (then (rewrite "nonempty_exists") (typepred "x1!1")
                            (skosimp*) (inst?) (assert)))
                    nil nil))
                  nil))
                nil))
              nil)
             ("2" (skosimp*)
              (("2"
                (apply (then (rewrite "nonempty_exists") (typepred "expr!1")
                        (skosimp*) (inst?) (assert)))
                nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Transition type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (Guard type-eq-decl nil MVA nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (Store type-eq-decl nil State nil) (Val type-decl nil Val_adt nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (expr!1 skolem-const-decl "({expr: Expr[Name] |
    EXISTS (g: Guard[CP, Name]):
      all_guards(a!1)(cp!1, e!1)(g) AND
       expr = Neg[Name](guard_to_expression[CP, Name](g)(v!1))})"
     MVACompletion nil)
    (g!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (injective? const-decl "bool" functions nil)
    (x1!1 skolem-const-decl "({expr: Expr[Name] |
    EXISTS (g: Guard[CP, Name]):
      all_guards(a!1)(cp!1, e!1)(g) AND
       expr = Neg[Name](guard_to_expression[CP, Name](g)(v!1))})"
     MVACompletion nil)
    (x2!1 skolem-const-decl "({expr: Expr[Name] |
    EXISTS (g: Guard[CP, Name]):
      all_guards(a!1)(cp!1, e!1)(g) AND
       expr = Neg[Name](guard_to_expression[CP, Name](g)(v!1))})"
     MVACompletion nil)
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (g!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (g!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (choose const-decl "(p)" sets nil) (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (Body type-decl nil Body_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Plus? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (NumVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Neg? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Conj? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Eq? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (BoolVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (RefVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Assign? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (CondExpr? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (MethodCall? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Const? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Expr type-eq-decl nil Body_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (a!1 skolem-const-decl "MVA[CP, Name]" MVACompletion nil)
    (cp!1 skolem-const-decl "CP" MVACompletion nil)
    (e!1 skolem-const-decl "Event[CP, Name]" MVACompletion nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Neg adt-constructor-decl "[Expr -> (Neg?)]" Body_adt nil)
    (guard_to_expression const-decl "[ValOrExcpt -> Expr]" MVAMonitoring nil)
    (v!1 skolem-const-decl "ValOrExcpt[Name]" MVACompletion nil)
    (nonempty? const-decl "bool" sets nil))
   634 600 t nil))
 (guard_to_expression_build_guard_wf_Expr 0
  (guard_to_expression_build_guard_wf_Expr-1 nil 3430127622 3433153543
   ("" (skosimp*)
    (("" (lemma "big_conj_wf_Expr")
      (("" (inst -1 "a!1" _)
        (("" (expand "wf_Expr")
          (("" (expand "wf_Body")
            (("" (use "guard_to_expression_build_guard")
              (("" (replace -1 :hide? t)
                (("" (inst?)
                  (("1" (assert)
                    (("1" (split -1)
                      (("1" (propax) nil nil)
                       ("2" (hide 2)
                        (("2" (skosimp*)
                          (("2" (expand "all_guards")
                            (("2" (skosimp*)
                              (("2" (inst?)
                                (("2" (assert)
                                  (("2" (replace -5)
                                    (("2" (flatten)
                                      (("2"
                                        (split 1)
                                        (("1"
                                          (expand "var_names" 1 1)
                                          (("1" (assert) nil nil))
                                          nil)
                                         ("2"
                                          (skosimp*)
                                          (("2"
                                            (inst?)
                                            (("2"
                                              (expand "subterm" -1)
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide-all-but 1)
                    (("2" (typepred "all_guards(a!1)(cp!1, e!1)")
                      (("2" (expand "is_finite")
                        (("2" (skosimp*)
                          (("2"
                            (inst 1 "N!1" "LAMBDA(expr : ({expr: Expr[Name] |
                         EXISTS (g: Guard[CP, Name]):
                           all_guards(a!1)(cp!1, e!1)(g) AND
                            expr = Neg(guard_to_expression[CP, Name](g)(v!1))})) : f!1(choose({g : Guard[CP, Name] |  all_guards(a!1)(cp!1, e!1)(g) AND
                            expr = Neg(guard_to_expression[CP, Name](g)(v!1))}))")
                            (("1" (expand "injective?")
                              (("1" (skosimp*)
                                (("1" (inst?)
                                  (("1" (assert) nil nil)
                                   ("2"
                                    (apply (then
                                            (rewrite "nonempty_exists")
                                            (typepred "x2!1")
                                            (skosimp*)
                                            (inst?)
                                            (assert)))
                                    nil nil)
                                   ("3"
                                    (apply (then
                                            (rewrite "nonempty_exists")
                                            (typepred "x1!1")
                                            (skosimp*)
                                            (inst?)
                                            (assert)))
                                    nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (skosimp*)
                              (("2"
                                (apply (then
                                        (rewrite "nonempty_exists")
                                        (typepred "expr!1")
                                        (skosimp*)
                                        (inst?)
                                        (assert)))
                                nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((big_conj_wf_Expr formula-decl nil MVACompletion nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (guard_to_expression_build_guard formula-decl nil MVACompletion nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (v!1 skolem-const-decl "ValOrExcpt[Name]" MVACompletion nil)
    (guard_to_expression const-decl "[ValOrExcpt -> Expr]" MVAMonitoring nil)
    (Neg adt-constructor-decl "[Expr -> (Neg?)]" Body_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (e!1 skolem-const-decl "Event[CP, Name]" MVACompletion nil)
    (cp!1 skolem-const-decl "CP" MVACompletion nil)
    (a!1 skolem-const-decl "MVA[CP, Name]" MVACompletion nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Store type-eq-decl nil State nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil) (Expr type-eq-decl nil Body_adt nil)
    (Const? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (MethodCall? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (CondExpr? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Assign? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (RefVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (BoolVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Eq? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Conj? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Neg? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (NumVarEval? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (Plus? adt-recognizer-decl "[Body -> boolean]" Body_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Body type-decl nil Body_adt nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (var_names def-decl "[Name -> boolean]" ProgramFunctions nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (expr!1 skolem-const-decl "({expr: Expr[Name] |
    EXISTS (g: Guard[CP, Name]):
      all_guards(a!1)(cp!1, e!1)(g) AND
       expr = Neg[Name](guard_to_expression[CP, Name](g)(v!1))})"
     MVACompletion nil)
    (g!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (injective? const-decl "bool" functions nil)
    (x1!1 skolem-const-decl "({expr: Expr[Name] |
    EXISTS (g: Guard[CP, Name]):
      all_guards(a!1)(cp!1, e!1)(g) AND
       expr = Neg[Name](guard_to_expression[CP, Name](g)(v!1))})"
     MVACompletion nil)
    (x2!1 skolem-const-decl "({expr: Expr[Name] |
    EXISTS (g: Guard[CP, Name]):
      all_guards(a!1)(cp!1, e!1)(g) AND
       expr = Neg[Name](guard_to_expression[CP, Name](g)(v!1))})"
     MVACompletion nil)
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (g!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (g!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (choose const-decl "(p)" sets nil) (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (nonempty? const-decl "bool" sets nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil))
   915 830 t shostak))
 (guard_to_expression_LAMBDA_true_TCC1 0
  (guard_to_expression_LAMBDA_true_TCC1-1 nil 3430127082 3433153543
   ("" (subtype-tcc) nil nil) proved
   ((Name formal-nonempty-type-decl nil MVACompletion nil)
    (defined? const-decl "boolean" ValProp nil))
   10 10 nil nil))
 (guard_to_expression_LAMBDA_true_wf_Expr 0
  (guard_to_expression_LAMBDA_true_wf_Expr-1 nil 3430127090 3433153543
   ("" (auto-rewrite "emptyset" "union" "member")
    (("" (skosimp*)
      (("" (rewrite "guard_to_expression_LAMBDA_true")
        (("" (expand "wf_Expr")
          (("" (expand "wf_Body")
            (("" (split 1)
              (("1" (expand "subset?")
                (("1" (assert)
                  (("1" (expand "var_names") (("1" (assert) nil nil)) nil))
                  nil))
                nil)
               ("2" (skosimp*)
                (("2" (expand "subterm") (("2" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((wf_Expr const-decl "boolean" WellFormedMVA nil)
    (member const-decl "bool" sets nil) (emptyset const-decl "set" sets nil)
    (union const-decl "set" sets nil)
    (var_names def-decl "[Name -> boolean]" ProgramFunctions nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (subset? const-decl "bool" sets nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (guard_to_expression_LAMBDA_true formula-decl nil MVACompletion nil))
   134 130 t shostak))
 (build_guard_yields_wf_guard 0
  (build_guard_yields_wf_guard-1 nil 3387785549 3433153545
   ("" (skosimp*)
    (("" (expand* "wf_Guard" "wf_MVA" "build_guard" "all_guards")
      (("" (skosimp*)
        ((""
          (case-replace "{v_1: (Bool?) |
                    EXISTS (p: Guard):
                      (EXISTS (t: Transition):
                         ts(a!1)(t) AND
                          scp(t) = cp!1 AND
                           event(t) = e!1 AND guard(t) = p)
                       AND
                       v_1 =
                        Bool(NOT p(sA!1 WITH [n!1 |-> v!1], sP!1,
                                   arg!1))}= {v: (Bool?) |
                   EXISTS (p: Guard):
                     (EXISTS (t: Transition):
                        ts(a!1)(t) AND
                         scp(t) = cp!1 AND event(t) = e!1 AND guard(t) = p)
                      AND v = Bool(NOT p(sA!1, sP!1, arg!1))}" :hide? t)
          (("1"
            (case-replace "{v: (Bool?) |
                   EXISTS (p: Guard):
                     (EXISTS (t: Transition):
                        ts(a!1)(t) AND
                         scp(t) = cp!1 AND event(t) = e!1 AND guard(t) = p)
                      AND v = Bool(NOT p(sA!1, sP!1, arg!1))} = {v_1: (Bool?) |
                    EXISTS (p: Guard):
                      (EXISTS (t: Transition):
                         ts(a!1)(t) AND
                          scp(t) = cp!1 AND
                           event(t) = e!1 AND guard(t) = p)
                       AND
                       v_1 =
                        Bool(NOT p(sA!1, sP!1 WITH [n!1 |-> v!1], arg!1))}")
            (("1" (hide 5)
              (("1" (apply-extensionality :hide? t)
                (("1" (iff)
                  (("1" (split 1)
                    (("1" (skosimp*)
                      (("1" (inst? -10)
                        (("1" (replace -4 :dir rl :hide? t)
                          (("1" (expand "wf_Trans")
                            (("1" (assert)
                              (("1" (flatten)
                                (("1" (inst?)
                                  (("1" (split 1)
                                    (("1" (inst?) (("1" (assert) nil nil))
                                      nil)
                                     ("2" (replace -4)
                                      (("2"
                                        (apply-extensionality :hide? t)
                                        (("2"
                                          (expand "wf_Guard")
                                          (("2"
                                            (inst?)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skosimp*)
                      (("2" (inst?)
                        (("2" (inst?)
                          (("2" (expand "wf_Trans")
                            (("2" (assert)
                              (("2" (flatten)
                                (("2" (replace -4 :hide? t)
                                  (("2" (expand "wf_Guard")
                                    (("2" (inst?)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (flatten)
                                          (("2"
                                            (split 1)
                                            (("1"
                                              (inst?)
                                              (("1" (assert) nil nil))
                                              nil)
                                             ("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide 5)
            (("2" (apply-extensionality :hide? t)
              (("2" (iff)
                (("2" (split 1)
                  (("1" (skosimp*)
                    (("1" (inst?)
                      (("1" (assert)
                        (("1" (split 1)
                          (("1" (inst?) (("1" (assert) nil nil)) nil)
                           ("2" (inst?)
                            (("2" (expand "wf_Trans")
                              (("2" (flatten)
                                (("2" (expand "wf_Guard")
                                  (("2" (inst?)
                                    (("2" (assert)
                                      (("2"
                                        (inst?)
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (skosimp*)
                    (("2" (inst?)
                      (("2" (assert)
                        (("2" (split 1)
                          (("1" (inst?) (("1" (assert) nil nil)) nil)
                           ("2" (inst?)
                            (("2" (assert)
                              (("2" (expand "wf_Trans")
                                (("2" (flatten)
                                  (("2" (assert)
                                    (("2" (expand "wf_Guard")
                                      (("2"
                                        (inst?)
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((wf_MVA const-decl "boolean" WellFormedMVA nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (Val type-decl nil Val_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Bool? adt-recognizer-decl "[Val -> boolean]" Val_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Store type-eq-decl nil State nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Guard type-eq-decl nil MVA nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Action type-eq-decl nil MVA nil) (Event type-eq-decl nil MVA nil)
    (Transition type-eq-decl nil MVA nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (EventType type-decl nil EventType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (JType type-decl nil JType_adt nil) (Decl type-eq-decl nil Program nil)
    (MVA type-eq-decl nil MVA nil)
    (Bool adt-constructor-decl "[bool -> (Bool?)]" Val_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Val_Bool_extensionality formula-decl nil Val_adt nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil))
   1592 1520 t shostak))
 (complete_MVA_yields_wf_MVA 0
  (complete_MVA_yields_wf_MVA-1 nil 3387108138 3433153546
   ("" (skolem-typepred)
    (("" (expand "wf_MVA")
      (("" (prop)
        (("1"
          (expand* "complete_MVA" "init_cp" "add" "member" "complete_MVA_pre")
          (("1" (prop) nil nil)) nil)
         ("2" (expand* "wf_vdsA" "complete_MVA") nil nil)
         ("3" (expand* "wf_vdsP" "complete_MVA") nil nil)
         ("4" (expand "complete_MVA") (("4" (propax) nil nil)) nil)
         ("5" (expand "complete_MVA") (("5" (propax) nil nil)) nil)
         ("6" (expand "wf_Trans")
          (("6" (skosimp)
            (("6" (inst? -6)
              (("6" (expand "complete_MVA" -1)
                (("6" (expand* "union" "member")
                  (("6" (split -1)
                    (("1" (assert)
                      (("1" (flatten) (("1" (grind) nil nil)) nil)) nil)
                     ("2" (expand* "complete_trans" "union" "member")
                      (("2" (split -1)
                        (("1" (flatten)
                          (("1" (hide -7 -8 -9 -10)
                            (("1" (use "build_guard_yields_wf_guard")
                              (("1" (grind) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (hide -3 -4 -5 -6) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((wf_Trans const-decl "boolean" WellFormedMVA nil)
    (union const-decl "set" sets nil)
    (build_guard_yields_wf_guard formula-decl nil MVACompletion nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (member def-decl "bool" list_props nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (finite_intersection1 application-judgement "finite_set" finite_sets nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (disjoint? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (subset? const-decl "bool" sets nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (skip const-decl "Action" MVA nil)
    (deterministic const-decl "boolean" MVAProperties nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (partial const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   1559 1480 t shostak))
 (complete_MVA_has_trap_state_TCC1 0
  (complete_MVA_has_trap_state_TCC1-1 nil 3382264515 3433153546
   ("" (use "complete_MVA_yields_wf_MVA") nil nil) proved
   ((complete_MVA_yields_wf_MVA formula-decl nil MVACompletion nil)) 31 10 t
   nil))
 (complete_MVA_has_trap_state 0
  (complete_MVA_has_trap_state-3 nil 3411368153 3433153547
   ("" (skolem-typepred)
    (("" (expand* "trap_state" "complete_MVA")
      (("" (skosimp)
        (("" (expand* "complete_trans" "union" "member" "partial" "wf_MVA")
          (("" (prop)
            (("" (inst?)
              (("" (expand "wf_Trans")
                (("" (prop) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((complete_MVA const-decl "MVA" MVACompletion nil)
    (trap_state const-decl "boolean" MVAProperties nil)
    (union const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (partial const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   197 200 t nil)
  (complete_MVA_has_trap_state-2 nil 3383048645 3411368119
   ("" (skolem-typepred)
    (("" (expand* "trap_state" "complete_MVA")
      (("" (skosimp)
        ((""
          (expand* "complete_trans" "union" "member" "complete_MVA_pre"
           "wf_MVA")
          (("" (prop)
            (("" (inst?)
              (("" (expand "wf_Trans")
                (("" (prop) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((complete_MVA const-decl "MVA" MVACompletion nil)
    (trap_state const-decl "boolean" MVAProperties nil)
    (union const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil) (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   284 250 t nil)
  (complete_MVA_has_trap_state-1 nil 3382270875 3382270880
   ("" (skolem-typepred)
    (("" (expand* "trap_state" "complete_MVA")
      (("" (skosimp)
        ((""
          (expand* "complete_trans" "union" "member" "complete_MVA_pre"
           "valid_MVA")
          (("" (prop)
            (("" (inst?) (("" (prop) (("" (assert) nil nil)) nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   untried
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (union const-decl "set" sets nil) (member const-decl "bool" sets nil))
   295 42 t nil))
 (complete_MVA_is_deterministic 0
  (complete_MVA_is_deterministic-3 nil 3411368112 3433153112
   ("" (expand "deterministic")
    (("" (skolem-typepred)
      (("" (skosimp)
        (("" (expand "partial")
          (("" (flatten)
            (("" (case* "ts(a!1)(t1!1)" "ts(a!1)(t2!1)")
              (("1" (expand "deterministic")
                (("1" (inst -4 "t1!1" "t2!1" "stA!1" "stP!1" "arg!1")
                  (("1"
                    (expand* "wf_Store" "wf_PSt" "complete_MVA"
                     "complete_trans" "union" "member")
                    (("1" (prop) nil nil)) nil))
                  nil))
                nil)
               ("2" (expand "complete_MVA" -5)
                (("2" (expand "complete_trans")
                  (("2" (expand "union")
                    (("2" (expand "member")
                      (("2" (assert)
                        (("2" (prop)
                          (("1" (assert)
                            (("1" (replace -3)
                              (("1" (expand "build_guard")
                                (("1" (rewrite "big_and_is_forall")
                                  (("1"
                                    (inst -13
                                     "Bool(NOT guard(t1!1)(stA!1, stP!1, arg!1))")
                                    (("1" (assert)
                                      (("1"
                                        (inst?)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (expand "all_guards")
                                            (("1"
                                              (inst 3 "t1!1")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (typepred
                                     "all_guards(a!1)(scp(t2!1), event(t2!1))")
                                    (("2" (hide-all-but (1 -1))
                                      (("2"
                                        (expand "is_finite")
                                        (("2"
                                          (skosimp*)
                                          (("2"
                                            (inst
                                             1
                                             "N!1"
                                             "LAMBDA(v : ({v: (Bool?[Name]) |
                     EXISTS (p: Guard[CP, Name]):
                       all_guards(a!1)(scp(t2!1), event(t2!1))(p) AND
                        v = Bool[Name](NOT p(stA!1, stP!1, arg!1))})) : f!1(choose({p: Guard[CP, Name]|
                       all_guards(a!1)(scp(t2!1), event(t2!1))(p) AND
                        v = Bool[Name](NOT p(stA!1, stP!1, arg!1))}))")
                                            (("1"
                                              (expand "injective?")
                                              (("1"
                                                (skosimp*)
                                                (("1"
                                                  (inst?)
                                                  (("1" (assert) nil nil)
                                                   ("2"
                                                    (rewrite
                                                     "nonempty_exists")
                                                    (("2"
                                                      (typepred "x2!1")
                                                      (("2"
                                                        (skosimp*)
                                                        (("2"
                                                          (inst?)
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("3"
                                                    (rewrite
                                                     "nonempty_exists")
                                                    (("3"
                                                      (typepred "x1!1")
                                                      (("3"
                                                        (skosimp*)
                                                        (("3"
                                                          (inst?)
                                                          (("3"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (skosimp*)
                                              (("2"
                                                (rewrite "nonempty_exists")
                                                (("2"
                                                  (typepred "v!1")
                                                  (("2"
                                                    (skosimp*)
                                                    (("2"
                                                      (inst?)
                                                      (("2" (assert) nil nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (expand "complete_MVA" -4)
                (("3" (expand "complete_trans")
                  (("3" (expand "union")
                    (("3" (expand "member")
                      (("3" (assert)
                        (("3" (prop)
                          (("1" (replace -3)
                            (("1" (expand "build_guard")
                              (("1" (rewrite "big_and_is_forall")
                                (("1"
                                  (inst -12
                                   "Bool(NOT guard(t2!1)(stA!1, stP!1, arg!1))")
                                  (("1" (assert)
                                    (("1" (inst?)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (expand "all_guards")
                                          (("1"
                                            (inst 3 "t2!1")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (hide-all-but 1)
                                  (("2"
                                    (typepred
                                     "all_guards(a!1)(scp(t1!1), event(t1!1))")
                                    (("2" (expand "is_finite")
                                      (("2"
                                        (skosimp*)
                                        (("2"
                                          (inst
                                           1
                                           "N!1"
                                           "LAMBDA(v : ({v: (Bool?[Name]) |
                     EXISTS (p: Guard[CP, Name]):
                       all_guards(a!1)(scp(t1!1), event(t1!1))(p) AND
                        v = Bool[Name](NOT p(stA!1, stP!1, arg!1))})) : f!1(choose({p: Guard[CP, Name]|
                       all_guards(a!1)(scp(t1!1), event(t1!1))(p) AND
                        v = Bool[Name](NOT p(stA!1, stP!1, arg!1))}))")
                                          (("1"
                                            (expand "injective?")
                                            (("1"
                                              (skosimp*)
                                              (("1"
                                                (inst?)
                                                (("1" (assert) nil nil)
                                                 ("2"
                                                  (rewrite "nonempty_exists")
                                                  (("2"
                                                    (typepred "x2!1")
                                                    (("2"
                                                      (skosimp*)
                                                      (("2"
                                                        (inst?)
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("3"
                                                  (rewrite "nonempty_exists")
                                                  (("3"
                                                    (typepred "x1!1")
                                                    (("3"
                                                      (skosimp*)
                                                      (("3"
                                                        (inst?)
                                                        (("3"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (skosimp*)
                                            (("2"
                                              (rewrite "nonempty_exists")
                                              (("2"
                                                (typepred "v!1")
                                                (("2"
                                                  (skosimp*)
                                                  (("2"
                                                    (inst?)
                                                    (("2" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "wf_MVA")
                            (("2" (flatten)
                              (("2" (inst -11 "t2!1")
                                (("2" (expand "wf_Trans")
                                  (("2" (flatten) (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("4" (apply-extensionality 4 :hide? t)
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((deterministic const-decl "boolean" MVAProperties nil)
    (p!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (v!1 skolem-const-decl "({v: (Bool?[Name]) |
    EXISTS (p: Guard[CP, Name]):
      all_guards(a!1)(scp(t1!1), event(t1!1))(p) AND
       v = Bool[Name](NOT p(stA!1, stP!1, arg!1))})" MVACompletion nil)
    (x1!1 skolem-const-decl "({v: (Bool?[Name]) |
    EXISTS (p: Guard[CP, Name]):
      all_guards(a!1)(scp(t1!1), event(t1!1))(p) AND
       v = Bool[Name](NOT p(stA!1, stP!1, arg!1))})" MVACompletion nil)
    (x2!1 skolem-const-decl "({v: (Bool?[Name]) |
    EXISTS (p: Guard[CP, Name]):
      all_guards(a!1)(scp(t1!1), event(t1!1))(p) AND
       v = Bool[Name](NOT p(stA!1, stP!1, arg!1))})" MVACompletion nil)
    (p!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (p!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (t1!1 skolem-const-decl "Transition[CP, Name]" MVACompletion nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (finite_intersection1 application-judgement "finite_set" finite_sets nil)
    (skip const-decl "Action" MVA nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (intersection const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil) (disjoint? const-decl "bool" sets nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (subset? const-decl "bool" sets nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (This const-decl "Name" Program nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (a!1 skolem-const-decl "(partial)" MVACompletion nil)
    (t2!1 skolem-const-decl "Transition[CP, Name]" MVACompletion nil)
    (stA!1 skolem-const-decl "Store[Name]" MVACompletion nil)
    (stP!1 skolem-const-decl "Store[Name]" MVACompletion nil)
    (arg!1 skolem-const-decl "ValOrExcpt[Name]" MVACompletion nil)
    (nonempty? const-decl "bool" sets nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil)
    (choose const-decl "(p)" sets nil)
    (p!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (p!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (x2!1 skolem-const-decl "({v: (Bool?[Name]) |
    EXISTS (p: Guard[CP, Name]):
      all_guards(a!1)(scp(t2!1), event(t2!1))(p) AND
       v = Bool[Name](NOT p(stA!1, stP!1, arg!1))})" MVACompletion nil)
    (x1!1 skolem-const-decl "({v: (Bool?[Name]) |
    EXISTS (p: Guard[CP, Name]):
      all_guards(a!1)(scp(t2!1), event(t2!1))(p) AND
       v = Bool[Name](NOT p(stA!1, stP!1, arg!1))})" MVACompletion nil)
    (injective? const-decl "bool" functions nil)
    (v!1 skolem-const-decl "({v: (Bool?[Name]) |
    EXISTS (p: Guard[CP, Name]):
      all_guards(a!1)(scp(t2!1), event(t2!1))(p) AND
       v = Bool[Name](NOT p(stA!1, stP!1, arg!1))})" MVACompletion nil)
    (p!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (Bool adt-constructor-decl "[bool -> (Bool?)]" Val_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (Bool? adt-recognizer-decl "[Val -> boolean]" Val_adt nil)
    (big_and_is_forall formula-decl nil MVACompletion nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (member const-decl "bool" sets nil) (union const-decl "set" sets nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (Store type-eq-decl nil State nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (partial const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   1769167 14430 t nil)
  (complete_MVA_is_deterministic-2 nil 3383048795 3411368092
   ("" (expand "deterministic")
    (("" (skolem-typepred)
      (("" (skosimp)
        (("" (expand "complete_MVA_pre")
          (("" (flatten)
            (("" (case* "ts(a!1)(t1!1)" "ts(a!1)(t2!1)")
              (("1" (expand "deterministic")
                (("1" (inst -4 "t1!1" "t2!1" "stA!1" "stP!1" "arg!1")
                  (("1"
                    (expand* "wf_Store" "wf_PSt" "complete_MVA"
                     "complete_trans" "union" "member")
                    (("1" (prop) nil nil)) nil))
                  nil))
                nil)
               ("2" (expand "complete_MVA" -5)
                (("2" (expand "complete_trans")
                  (("2" (expand "union")
                    (("2" (expand "member")
                      (("2" (assert)
                        (("2" (prop)
                          (("1" (assert)
                            (("1" (replace -3)
                              (("1" (expand "build_guard")
                                (("1" (expand "all_guards")
                                  (("1" (inst? -13)
                                    (("1" (assert)
                                      (("1"
                                        (inst 3 "t1!1")
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (expand "complete_MVA" -4)
                (("3" (expand "complete_trans")
                  (("3" (expand "union")
                    (("3" (expand "member")
                      (("3" (assert)
                        (("3" (prop)
                          (("1" (replace -3)
                            (("1" (expand "build_guard")
                              (("1" (inst? -12)
                                (("1" (expand "all_guards")
                                  (("1" (inst 3 "t2!1")
                                    (("1" (assert) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "wf_MVA")
                            (("2" (flatten)
                              (("2" (inst -11 "t2!1")
                                (("2" (expand "wf_Trans")
                                  (("2" (flatten) (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("4" (apply-extensionality 4 :hide? t)
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (EventType type-decl nil EventType_adt nil)
    (Event type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Transition type-eq-decl nil MVA nil)
    (Val type-decl nil Val_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (JType type-decl nil JType_adt nil) (MVA type-eq-decl nil MVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PSt type-eq-decl nil State nil) (Store type-eq-decl nil State nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (union const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (This const-decl "Name" Program nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (subset? const-decl "bool" sets nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (disjoint? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (skip const-decl "Action" MVA nil)
    (finite_intersection1 application-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (deterministic const-decl "boolean" MVAProperties nil))
   12635 5840 t nil)
  (complete_MVA_is_deterministic-1 nil 3382270657 3382270846
   ("" (skolem-typepred)
    (("" (expand* "deterministic" "complete_MVA")
      (("" (skosimp)
        (("" (expand "complete_MVA_pre")
          (("" (flatten -2)
            (("" (case* "ts(a!1)(t1!1)" "ts(a!1)(t2!1)")
              (("1" (expand "deterministic")
                (("1" (inst -4 "t1!1" "t2!1" "stA!1" "stP!1")
                  (("1" (prop)
                    (("1" (expand "valid_PSt") (("1" (propax) nil nil)) nil)
                     ("2" (expand "valid_Store") (("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (delete -3 -6 -7)
                (("2" (expand "complete_trans" -4)
                  (("2" (expand "union" -4)
                    (("2" (expand "member" -4)
                      (("2" (prop)
                        (("1" (delete -8 1)
                          (("1" (expand "valid_MVA")
                            (("1" (prop)
                              (("1" (inst -9 "t1!1")
                                (("1" (prop)
                                  (("1" (delete -4 -5)
                                    (("1" (grind)
                                      (("1" (postpone) nil nil)
                                       ("2" (postpone) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (delete -3 -5 -6 -7)
                (("3" (expand* "complete_trans" "union" "member")
                  (("3" (prop)
                    (("1" (grind)
                      (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)
                     ("2" (expand "valid_MVA")
                      (("2" (prop)
                        (("2" (inst -9 "t2!1")
                          (("2" (prop)
                            (("2" (delete -4 -5) (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("4" (delete -1 -2 -5 -6)
                (("4" (grind)
                  (("1" (decompose-equality 4) nil nil)
                   ("2" (decompose-equality 4) nil nil)
                   ("3" (postpone) nil nil) ("4" (postpone) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   untried nil 18669 3635 t nil))
 (complete_MVA_is_total 0
  (complete_MVA_is_total-3 nil 3410259686 3433153535
   ("" (skolem-typepred)
    (("" (expand* "total" "complete_MVA")
      (("" (skosimp)
        ((""
          (case "EXISTS (t: Transition[CP, Name]): ts(a!1)(t) AND scp(t) = q!1 AND event(t) = e!1 AND guard(t)(stA!1, stP!1, arg!1)")
          (("1" (skolem!)
            (("1" (inst 1 "t!1")
              (("1" (expand* "union" "member") (("1" (prop) nil nil)) nil))
              nil))
            nil)
           ("2" (case "q!1 = halted")
            (("1" (hide 1)
              (("1"
                (inst +
                 "(# scp := halted, event := e!1, guard := (LAMBDA (stA, stP: Store , arg : ValOrExcpt): TRUE), action := skip, tcp := halted #)")
                (("1" (expand* "wf_MVA" "complete_MVA_pre")
                  (("1" (flatten)
                    (("1" (replace -1) (("1" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (delete 2)
              (("2"
                (case "EXISTS (t: Transition): ts(a!1)(t) AND scp(t) = q!1 AND event(t) = e!1 AND guard(t)(stA!1, stP!1, arg!1)")
                (("1" (skolem!)
                  (("1" (inst + "t!1") (("1" (grind) nil nil)) nil)) nil)
                 ("2"
                  (inst 3
                   "(# scp := q!1, event := e!1, guard := build_guard(a!1)(q!1, e!1), action := skip, tcp := halted #)")
                  (("2" (split 3)
                    (("1" (grind) nil nil)
                     ("2" (expand "build_guard")
                      (("2" (rewrite "big_and_is_forall")
                        (("1" (skosimp*)
                          (("1" (expand "all_guards")
                            (("1" (skosimp*)
                              (("1" (inst?)
                                (("1" (assert)
                                  (("1" (replace -5) (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (hide-all-but 1)
                          (("2" (typepred "all_guards(a!1)(q!1, e!1)")
                            (("2" (expand "is_finite")
                              (("2" (skosimp*)
                                (("2"
                                  (inst 1 "N!1"
                                   "LAMBDA(v : ({v: (Bool?[Name]) |
                     EXISTS (p: Guard[CP, Name]):
                       all_guards(a!1)(q!1, e!1)(p) AND
                        v = Bool[Name](NOT p(stA!1, stP!1, arg!1))})) : f!1(choose({p: Guard[CP, Name]|
                       all_guards(a!1)(q!1, e!1)(p) AND
                        v = Bool[Name](NOT p(stA!1, stP!1, arg!1))}))")
                                  (("1" (expand "injective?")
                                    (("1" (skosimp*)
                                      (("1"
                                        (inst?)
                                        (("1" (assert) nil nil)
                                         ("2"
                                          (rewrite "nonempty_exists")
                                          (("2"
                                            (typepred "x2!1")
                                            (("2"
                                              (skosimp*)
                                              (("2"
                                                (inst?)
                                                (("2" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("3"
                                          (rewrite "nonempty_exists")
                                          (("3"
                                            (typepred "x1!1")
                                            (("3"
                                              (skosimp*)
                                              (("3"
                                                (inst?)
                                                (("3" (assert) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (skosimp*)
                                    (("2" (rewrite "nonempty_exists")
                                      (("2"
                                        (typepred "v!1")
                                        (("2"
                                          (skosimp*)
                                          (("2"
                                            (inst?)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (EventType type-decl nil EventType_adt nil)
    (Event type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Transition type-eq-decl nil MVA nil)
    (Val type-decl nil Val_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (JType type-decl nil JType_adt nil) (Decl type-eq-decl nil Program nil)
    (MVA type-eq-decl nil MVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (partial const-decl "boolean" MVAProperties nil)
    (halted const-decl "CP" MVA nil) (skip const-decl "Action" MVA nil)
    (list type-decl nil list_adt nil) (OneAction type-eq-decl nil MVA nil)
    (Expr type-eq-decl nil Body_adt nil) (TRUE const-decl "bool" booleans nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (intersection const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil) (disjoint? const-decl "bool" sets nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (deterministic const-decl "boolean" MVAProperties nil)
    (add const-decl "(nonempty?)" sets nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (finite_intersection1 application-judgement "finite_set" finite_sets nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (subset? const-decl "bool" sets nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (big_and_is_forall formula-decl nil MVACompletion nil)
    (Bool? adt-recognizer-decl "[Val -> boolean]" Val_adt nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (Bool adt-constructor-decl "[bool -> (Bool?)]" Val_adt nil)
    (p!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (v!1 skolem-const-decl "({v: (Bool?[Name]) |
    EXISTS (p: Guard[CP, Name]):
      all_guards(a!1)(q!1, e!1)(p) AND
       v = Bool[Name](NOT p(stA!1, stP!1, arg!1))})" MVACompletion nil)
    (injective? const-decl "bool" functions nil)
    (x1!1 skolem-const-decl "({v: (Bool?[Name]) |
    EXISTS (p: Guard[CP, Name]):
      all_guards(a!1)(q!1, e!1)(p) AND
       v = Bool[Name](NOT p(stA!1, stP!1, arg!1))})" MVACompletion nil)
    (x2!1 skolem-const-decl "({v: (Bool?[Name]) |
    EXISTS (p: Guard[CP, Name]):
      all_guards(a!1)(q!1, e!1)(p) AND
       v = Bool[Name](NOT p(stA!1, stP!1, arg!1))})" MVACompletion nil)
    (p!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (p!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (choose const-decl "(p)" sets nil) (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (nonempty? const-decl "bool" sets nil)
    (arg!1 skolem-const-decl "ValOrExcpt[Name]" MVACompletion nil)
    (stP!1 skolem-const-decl "Store[Name]" MVACompletion nil)
    (stA!1 skolem-const-decl "Store[Name]" MVACompletion nil)
    (e!1 skolem-const-decl "Event[CP, Name]" MVACompletion nil)
    (q!1 skolem-const-decl "CP" MVACompletion nil)
    (a!1 skolem-const-decl "(partial)" MVACompletion nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (member const-decl "bool" sets nil) (union const-decl "set" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Store type-eq-decl nil State nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (total const-decl "boolean" MVAProperties nil)
    (complete_MVA const-decl "MVA" MVACompletion nil))
   412514 2110 t nil)
  (complete_MVA_is_total-2 nil 3383048587 3410259477
   ("" (skolem-typepred)
    (("" (expand* "total" "complete_MVA")
      (("" (skosimp)
        ((""
          (case "EXISTS (t: Transition[CP, Name]): ts(a!1)(t) AND scp(t) = q!1 AND event(t) = e!1 AND guard(t)(stA!1, stP!1, arg!1)")
          (("1" (skolem!)
            (("1" (inst 1 "t!1")
              (("1" (expand* "union" "member") (("1" (prop) nil nil)) nil))
              nil))
            nil)
           ("2" (case "q!1 = halted")
            (("1" (hide 1)
              (("1"
                (inst +
                 "(# scp := halted, event := e!1, guard := (LAMBDA (stA: Store , stP: PSt, arg : (defined?)): TRUE), action := skip, tcp := halted #)")
                (("1" (expand* "wf_MVA" "complete_MVA_pre")
                  (("1" (flatten)
                    (("1" (replace -1) (("1" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (delete 2)
              (("2"
                (case "EXISTS (t: Transition): ts(a!1)(t) AND scp(t) = q!1 AND event(t) = e!1 AND guard(t)(stA!1, stP!1, arg!1)")
                (("1" (skolem!)
                  (("1" (inst + "t!1") (("1" (grind) nil nil)) nil)) nil)
                 ("2"
                  (inst 3
                   "(# scp := q!1, event := e!1, guard := build_guard(a!1)(q!1, e!1), action := skip, tcp := halted #)")
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((complete_MVA const-decl "MVA" MVACompletion nil)
    (PSt type-eq-decl nil State nil) (Store type-eq-decl nil State nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (union const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (This const-decl "Name" Program nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (subterm adt-def-decl "boolean" Body_adt nil)
    (subset? const-decl "bool" sets nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (finite_intersection1 application-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (add const-decl "(nonempty?)" sets nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (disjoint? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (TRUE const-decl "bool" booleans nil) (Expr type-eq-decl nil Body_adt nil)
    (OneAction type-eq-decl nil MVA nil) (list type-decl nil list_adt nil)
    (skip const-decl "Action" MVA nil) (halted const-decl "CP" MVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil) (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   3936 3870 t nil)
  (complete_MVA_is_total-1 nil 3382265612 3382270601
   ("" (skolem-typepred)
    (("" (expand "total")
      (("" (skosimp)
        (("" (expand "complete_MVA" 1)
          ((""
            (case "EXISTS (t: Transition[CP, Name]): ts(a!1)(t) AND scp(t) = q!1 AND event(t) = e!1 AND guard(t)(stA!1, stP!1)")
            (("1" (skolem!)
              (("1" (inst 1 "t!1")
                (("1" (expand "union" 1)
                  (("1" (expand "member" 1) (("1" (prop) nil nil)) nil)) nil))
                nil))
              nil)
             ("2" (case "q!1 = halted")
              (("1"
                (inst 2
                 "(# scp := halted, event := e!1, guard := (LAMBDA (stA: (valid_Store(vdsA(a!1))) , stP: (valid_PSt(vdsP(a!1)))): TRUE), action := skip, tcp := halted #)")
                (("1" (hide -6 -7 1) (("1" (postpone) nil nil)) nil)) nil)
               ("2"
                (inst 3
                 "(# scp := q!1, event := e!1, guard := build_guard(q!1, e!1, ts(a!1), vdsA(a!1), vdsP(a!1)), action := skip, tcp := halted #)")
                (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   untried nil 46487 3476 t nil))
 (complete_MVA_is_complete 0
  (complete_MVA_is_complete-1 nil 3382265489 3433153547
   ("" (skolem-typepred)
    (("" (expand "complete")
      (("" (split)
        (("1" (use "complete_MVA_yields_wf_MVA") nil nil)
         ("2" (expand "complete_MVA")
          (("2" (expand "add") (("2" (propax) nil nil)) nil)) nil)
         ("3" (use "complete_MVA_has_trap_state") nil nil)
         ("4" (use "complete_MVA_is_deterministic") nil nil)
         ("5" (use "complete_MVA_is_total") nil nil))
        nil))
      nil))
    nil)
   proved
   ((complete const-decl "boolean" MVAProperties nil)
    (complete_MVA_is_total formula-decl nil MVACompletion nil)
    (complete_MVA_is_deterministic formula-decl nil MVACompletion nil)
    (complete_MVA_has_trap_state formula-decl nil MVACompletion nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (add const-decl "(nonempty?)" sets nil)
    (complete_MVA_yields_wf_MVA formula-decl nil MVACompletion nil)
    (partial const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   578 570 t nil))
 (evs_complete_MVA 0
  (evs_complete_MVA-1 nil 3412338923 3433153547
   ("" (skosimp*) (("" (expand "complete_MVA") (("" (propax) nil nil)) nil))
    nil)
   proved ((complete_MVA const-decl "MVA" MVACompletion nil)) 31 10 t
   shostak))
 (completion_equivalence_TCC1 0
  (completion_equivalence_TCC1-1 nil 3411913637 3433153548
   ("" (subtype-tcc) nil nil) proved
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (EventType type-decl nil EventType_adt nil)
    (Event type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Transition type-eq-decl nil MVA nil)
    (Val type-decl nil Val_adt nil) (JType type-decl nil JType_adt nil)
    (Decl type-eq-decl nil Program nil) (MVA type-eq-decl nil MVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (partial const-decl "boolean" MVAProperties nil)
    (Store type-eq-decl nil State nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (wf_PSt const-decl "boolean" MVACommonSemantics nil)
    (deterministic const-decl "boolean" MVAProperties nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (subset? const-decl "bool" sets nil) (union const-decl "set" sets nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (disjoint? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (finite_intersection1 application-judgement "finite_set" finite_sets nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (skip const-decl "Action" MVA nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (defined? const-decl "boolean" ValProp nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (wf_store const-decl "boolean" State nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil))
   466 440 nil nil))
 (completion_equivalence_TCC2 0
  (completion_equivalence_TCC2-1 nil 3411913637 3433153548
   ("" (subtype-tcc) nil nil) proved
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (EventType type-decl nil EventType_adt nil)
    (Event type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Transition type-eq-decl nil MVA nil)
    (Val type-decl nil Val_adt nil) (JType type-decl nil JType_adt nil)
    (Decl type-eq-decl nil Program nil) (MVA type-eq-decl nil MVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (partial const-decl "boolean" MVAProperties nil)
    (Store type-eq-decl nil State nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (finite_intersection1 application-judgement "finite_set" finite_sets nil)
    (member const-decl "bool" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (intersection const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil) (disjoint? const-decl "bool" sets nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (union const-decl "set" sets nil) (subset? const-decl "bool" sets nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (deterministic const-decl "boolean" MVAProperties nil)
    (wf_store const-decl "boolean" State nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (skip const-decl "Action" MVA nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (defined? const-decl "boolean" ValProp nil)
    (wf_PSt const-decl "boolean" MVACommonSemantics nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil))
   456 430 nil nil))
 (completion_equivalence_TCC3 0
  (completion_equivalence_TCC3-1 nil 3411913637 3433153548
   ("" (skosimp*) (("" (use "complete_MVA_is_total") nil nil)) nil) proved
   ((partial const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (complete_MVA_is_total formula-decl nil MVACompletion nil))
   150 150 t nil))
 (completion_equivalence 0
  (completion_equivalence-2 nil 3412328847 3433153857
   ("" (skosimp*)
    (("" (split 1)
      (("1" (skosimp*)
        (("1" (expand "step")
          (("1" (assert)
            (("1" (lift-if)
              (("1" (assert)
                (("1" (split -1)
                  (("1" (propax) nil nil)
                   ("2" (expand "complete_MVA")
                    (("2" (auto-rewrite "union" "member" "add")
                      (("2" (assert)
                        (("2" (use "complete_MVA_is_total")
                          (("2"
                            (name-replace "t"
                             "choose(LAMBDA (t: Transition[CP, Name]):
                                  (ts(a!1)(t) OR complete_trans(a!1)(t)) AND
                                   scp(t) = cp(s!1) AND
                                    event(t) = event(pe!1) AND
                                     guard(t)(stA(s!1), stP(pe!1), arg(pe!1))) "
                             :hide? t)
                            (("1" (typepred "t")
                              (("1" (split -1)
                                (("1" (inst?) (("1" (assert) nil nil)) nil)
                                 ("2" (expand "complete_trans")
                                  (("2" (assert)
                                    (("2"
                                      (apply
                                       (branch
                                        (split -1)
                                        ((then
                                          (flatten)
                                          (assert)
                                          (flatten)
                                          (assert)))))
                                      nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide 2 3)
                              (("2" (rewrite "nonempty_exists")
                                (("2" (expand "total")
                                  (("2"
                                    (inst -1 "cp(s!1)" "event(pe!1)"
                                     "stA(s!1)" "stP(pe!1)" "arg(pe!1)")
                                    (("2" (assert)
                                      (("2"
                                        (expand "complete_MVA")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (typepred "pe!1" "s!1")
                                            (("2"
                                              (expand*
                                               "wf_AState"
                                               "wf_PEvent")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (flatten)
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (skosimp*)
                                                      (("2"
                                                        (inst?)
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skosimp*)
        (("2" (expand "step")
          (("2" (lift-if)
            (("2" (assert)
              (("2" (auto-rewrite "union" "member")
                (("2" (expand "complete_MVA")
                  (("2" (assert)
                    (("2"
                      (name-replace "t"
                       "choose(LAMBDA (t: Transition[CP, Name]):
                              (ts(a!1)(t) OR complete_trans(a!1)(t)) AND
                               scp(t) = cp(s!1) AND
                                event(t) = event(pe!1) AND
                                 guard(t)(stA(s!1), stP(pe!1), arg(pe!1))) "
                       :hide? t)
                      (("1" (typepred "t")
                        (("1" (typepred "a!1")
                          (("1" (expand "wf_MVA")
                            (("1" (expand "partial")
                              (("1" (flatten)
                                (("1" (split -7)
                                  (("1" (inst?)
                                    (("1" (expand "wf_Trans")
                                      (("1" (assert) nil nil)) nil))
                                    nil)
                                   ("2" (split 3)
                                    (("1" (expand "complete_trans")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (skosimp*)
                                          (("1"
                                            (split -5)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (replace -3)
                                                (("1"
                                                  (expand "build_guard")
                                                  (("1"
                                                    (rewrite
                                                     "big_and_is_forall")
                                                    (("1"
                                                      (inst
                                                       -18
                                                       "Bool(NOT guard(t!1)(stA(s!1), stP(pe!1), arg(pe!1)))")
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (inst? 3)
                                                          (("1"
                                                            (expand
                                                             "all_guards")
                                                            (("1"
                                                              (inst? 3)
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (typepred
                                                       " all_guards(a!1)(scp(t), event(t))")
                                                      (("2"
                                                        (hide-all-but (1 -1))
                                                        (("2"
                                                          (expand "is_finite")
                                                          (("2"
                                                            (skosimp*)
                                                            (("2"
                                                              (inst
                                                               1
                                                               "N!1"
                                                               "LAMBDA(v : ({v: (Bool?[Name]) |
                     EXISTS (p: Guard[CP, Name]):
                       all_guards(a!1)(scp(t), event(t))(p) AND
                        v =
                         Bool[Name]
                             (NOT p(stA(s!1), stP(pe!1), arg(pe!1)))})) : f!1(choose({p: Guard[CP, Name]|
                       all_guards(a!1)(scp(t), event(t))(p) AND
                        v =
                         Bool[Name]
                             (NOT p(stA(s!1), stP(pe!1), arg(pe!1)))}))")
                                                              (("1"
                                                                (expand
                                                                 "injective?")
                                                                (("1"
                                                                  (skosimp*)
                                                                  (("1"
                                                                    (inst?)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil)
                                                                     ("2"
                                                                      (rewrite
                                                                       "nonempty_exists")
                                                                      (("2"
                                                                        (typepred
                                                                         "x2!1")
                                                                        (("2"
                                                                          (skosimp*)
                                                                          (("2"
                                                                            (inst?)
                                                                            (("2"
                                                                              (assert)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("3"
                                                                      (rewrite
                                                                       "nonempty_exists")
                                                                      (("3"
                                                                        (typepred
                                                                         "x1!1")
                                                                        (("3"
                                                                          (skosimp*)
                                                                          (("3"
                                                                            (inst?)
                                                                            (("3"
                                                                              (assert)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (skosimp*)
                                                                (("2"
                                                                  (rewrite
                                                                   "nonempty_exists")
                                                                  (("2"
                                                                    (typepred
                                                                     "v!1")
                                                                    (("2"
                                                                      (skosimp*)
                                                                      (("2"
                                                                        (inst?)
                                                                        (("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (inst -14 "t!1")
                                                (("2"
                                                  (expand "wf_Trans")
                                                  (("2" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (rewrite "nonempty_exists")
                        (("2" (use "complete_MVA_is_total")
                          (("2" (expand "total")
                            (("2"
                              (inst -1 "cp(s!1)" "event(pe!1)" "stA(s!1)"
                               "stP(pe!1)" "arg(pe!1)")
                              (("2" (assert)
                                (("2" (typepred "s!1")
                                  (("2" (typepred "pe!1")
                                    (("2" (expand "wf_PEvent")
                                      (("2"
                                        (expand "wf_AState")
                                        (("2"
                                          (flatten)
                                          (("2"
                                            (expand "complete_MVA")
                                            (("2"
                                              (auto-rewrite "add")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (skosimp*)
                                                  (("2"
                                                    (inst?)
                                                    (("2" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((step const-decl "AState" MVATotalSemantics nil)
    (step const-decl "lift[AState]" MVAPartialSemantics nil)
    (complete_MVA_is_total formula-decl nil MVACompletion nil)
    (partial const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (total const-decl "boolean" MVAProperties nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (pe!1 skolem-const-decl "(wf_PEvent(a!1))" MVACompletion nil)
    (s!1 skolem-const-decl "(wf_AState(a!1))" MVACompletion nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVACompletion nil)
    (a!1 skolem-const-decl "(partial)" MVACompletion nil)
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (Store type-eq-decl nil State nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (is_finite const-decl "bool" finite_sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (union const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (t skolem-const-decl "(LAMBDA (t: Transition[CP, Name]):
   (ts(a!1)(t) OR complete_trans(a!1)(t)) AND
    scp(t) = cp(s!1) AND
     event(t) = event(pe!1) AND guard(t)(stA(s!1), stP(pe!1), arg(pe!1)))"
     MVACompletion nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil)
    (p!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (p!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (x2!1 skolem-const-decl "({v: (Bool?[Name]) |
    EXISTS (p: Guard[CP, Name]):
      all_guards(a!1)(scp(t), event(t))(p) AND
       v = Bool[Name](NOT p(stA(s!1), stP(pe!1), arg(pe!1)))})" MVACompletion
     nil)
    (x1!1 skolem-const-decl "({v: (Bool?[Name]) |
    EXISTS (p: Guard[CP, Name]):
      all_guards(a!1)(scp(t), event(t))(p) AND
       v = Bool[Name](NOT p(stA(s!1), stP(pe!1), arg(pe!1)))})" MVACompletion
     nil)
    (injective? const-decl "bool" functions nil)
    (v!1 skolem-const-decl "({v: (Bool?[Name]) |
    EXISTS (p: Guard[CP, Name]):
      all_guards(a!1)(scp(t), event(t))(p) AND
       v = Bool[Name](NOT p(stA(s!1), stP(pe!1), arg(pe!1)))})" MVACompletion
     nil)
    (p!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (big_and_is_forall formula-decl nil MVACompletion nil)
    (Bool? adt-recognizer-decl "[Val -> boolean]" Val_adt nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (Bool adt-constructor-decl "[bool -> (Bool?)]" Val_adt nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVACompletion nil))
   264092 4110 t nil)
  (completion_equivalence-1 nil 3411913637 3412328771
   ("" (skosimp*)
    (("" (split 1)
      (("1" (skosimp*)
        (("1" (expand "step")
          (("1" (assert)
            (("1" (lift-if)
              (("1" (assert)
                (("1" (split -1)
                  (("1" (propax) nil nil)
                   ("2" (expand "complete_MVA")
                    (("2" (auto-rewrite "union" "member" "add")
                      (("2" (assert)
                        (("2" (use "complete_MVA_is_total")
                          (("2"
                            (name-replace "t"
                             "choose(LAMBDA (t: Transition[CP, Name]):
                      (ts(a!1)(t) OR complete_trans(a!1)(t)) AND
                       scp(t) = cp(s!1) AND
                        event(t) = event(pe!1) AND
                         guard(t)(stA(s!1), stP(pe!1), arg(pe!1))) " :hide? t)
                            (("1" (typepred "t")
                              (("1" (split -1)
                                (("1" (inst?) (("1" (assert) nil nil)) nil)
                                 ("2" (expand "complete_trans")
                                  (("2" (assert)
                                    (("2"
                                      (apply
                                       (branch
                                        (split -1)
                                        ((then
                                          (flatten)
                                          (assert)
                                          (flatten)
                                          (assert)))))
                                      nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide 2 3)
                              (("2" (rewrite "nonempty_exists")
                                (("2" (expand "total")
                                  (("2"
                                    (inst -1 "cp(s!1)" "event(pe!1)"
                                     "stA(s!1)" "stP(pe!1)" "arg(pe!1)")
                                    (("2" (assert)
                                      (("2"
                                        (expand "complete_MVA")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (typepred "pe!1" "s!1")
                                            (("2"
                                              (expand*
                                               "wf_AState"
                                               "wf_PEvent")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (flatten)
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (skosimp*)
                                                      (("2"
                                                        (inst?)
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skosimp*)
        (("2" (expand "step")
          (("2" (lift-if)
            (("2" (assert)
              (("2" (auto-rewrite "union" "member")
                (("2" (expand "complete_MVA")
                  (("2" (assert)
                    (("2"
                      (name-replace "t"
                       "choose(LAMBDA (t: Transition[CP, Name]):
                      (ts(a!1)(t) OR complete_trans(a!1)(t)) AND
                       scp(t) = cp(s!1) AND
                        event(t) = event(pe!1) AND
                         guard(t)(stA(s!1), stP(pe!1), arg(pe!1))) " :hide? t)
                      (("1" (typepred "t")
                        (("1" (typepred "a!1")
                          (("1" (expand "wf_MVA")
                            (("1" (expand "good_for_monitoring")
                              (("1" (flatten)
                                (("1" (split -7)
                                  (("1" (inst?)
                                    (("1" (expand "wf_Trans")
                                      (("1" (assert) nil nil)) nil))
                                    nil)
                                   ("2" (split 3)
                                    (("1" (expand "complete_trans")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (skosimp*)
                                          (("1"
                                            (split -5)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (replace -3)
                                                (("1"
                                                  (expand "build_guard")
                                                  (("1"
                                                    (inst? -18)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand "all_guards")
                                                        (("1"
                                                          (inst? 3)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (inst -14 "t!1")
                                                (("2"
                                                  (expand "wf_Trans")
                                                  (("2" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (rewrite "nonempty_exists")
                        (("2" (use "complete_MVA_is_total")
                          (("2" (expand "total")
                            (("2"
                              (inst -1 "cp(s!1)" "event(pe!1)" "stA(s!1)"
                               "stP(pe!1)" "arg(pe!1)")
                              (("2" (assert)
                                (("2" (typepred "s!1")
                                  (("2" (typepred "pe!1")
                                    (("2" (expand "wf_PEvent")
                                      (("2"
                                        (expand "wf_AState")
                                        (("2"
                                          (flatten)
                                          (("2"
                                            (expand "complete_MVA")
                                            (("2"
                                              (auto-rewrite "add")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (skosimp*)
                                                  (("2"
                                                    (inst?)
                                                    (("2" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((step const-decl "AState" MVATotalSemantics nil)
    (step const-decl "lift[AState]" MVAPartialSemantics nil)
    (complete_MVA_is_total formula-decl nil MVACompletion nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (MVA type-eq-decl nil MVA nil) (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (total const-decl "boolean" MVAProperties nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (PSt type-eq-decl nil State nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (Store type-eq-decl nil State nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (is_finite const-decl "bool" finite_sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (union const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil))
   1098 990 t shostak))
 (completion_equivalence2_TCC1 0
  (completion_equivalence2_TCC1-1 nil 3412337967 3433153550
   ("" (skosimp*)
    (("" (use "complete_definedness")
      (("" (use "complete_MVA_is_complete") nil nil)) nil))
    nil)
   proved
   ((complete_definedness formula-decl nil MVAPartialSemantics nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (a!1 skolem-const-decl "(partial[CP, Name])" MVACompletion nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (Store type-eq-decl nil State nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (partial const-decl "boolean" MVAProperties nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (complete const-decl "boolean" MVAProperties nil)
    (MVA type-eq-decl nil MVA nil) (Decl type-eq-decl nil Program nil)
    (JType type-decl nil JType_adt nil)
    (defined? const-decl "boolean" ValProp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Val type-decl nil Val_adt nil) (Transition type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Event type-eq-decl nil MVA nil)
    (EventType type-decl nil EventType_adt nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (complete_MVA_is_complete formula-decl nil MVACompletion nil))
   194 160 t nil))
 (completion_equivalence2 0
  (completion_equivalence2-1 nil 3412338025 3433154041
   ("" (skosimp*)
    (("" (split 1)
      (("1" (skosimp*)
        (("1" (expand "step")
          (("1" (assert)
            (("1" (lift-if)
              (("1" (assert)
                (("1" (split -1)
                  (("1" (propax) nil nil)
                   ("2" (expand "complete_MVA")
                    (("2" (auto-rewrite "union" "member" "add")
                      (("2" (assert)
                        (("2" (use "complete_MVA_is_total")
                          (("2"
                            (name-replace "t"
                             "choose(LAMBDA (t: Transition[CP, Name]):
                                  (ts(a!1)(t) OR complete_trans(a!1)(t)) AND
                                   scp(t) = cp(s!1) AND
                                    event(t) = event(pe!1) AND
                                     guard(t)(stA(s!1), stP(pe!1), arg(pe!1))) "
                             :hide? t)
                            (("1" (typepred "t")
                              (("1" (split -1)
                                (("1" (inst?) (("1" (assert) nil nil)) nil)
                                 ("2" (expand "complete_trans")
                                  (("2" (assert)
                                    (("2"
                                      (apply
                                       (branch
                                        (split -1)
                                        ((then
                                          (flatten)
                                          (assert)
                                          (flatten)
                                          (assert)))))
                                      (("1"
                                        (split 2)
                                        (("1" (propax) nil nil)
                                         ("2"
                                          (skosimp*)
                                          (("2"
                                            (inst?)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (split 2)
                                        (("1" (propax) nil nil)
                                         ("2"
                                          (skosimp*)
                                          (("2"
                                            (inst?)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide 2 3)
                              (("2" (rewrite "nonempty_exists")
                                (("2" (expand "total")
                                  (("2"
                                    (inst -1 "cp(s!1)" "event(pe!1)"
                                     "stA(s!1)" "stP(pe!1)" "arg(pe!1)")
                                    (("2" (assert)
                                      (("2"
                                        (expand "complete_MVA")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (typepred "pe!1" "s!1")
                                            (("2"
                                              (expand*
                                               "wf_AState"
                                               "wf_PEvent")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (flatten)
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (skosimp*)
                                                      (("2"
                                                        (inst?)
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skosimp*)
        (("2" (expand "step")
          (("2" (lift-if)
            (("2" (assert)
              (("2" (auto-rewrite "union" "member")
                (("2" (expand "complete_MVA")
                  (("2" (assert)
                    (("2"
                      (name-replace "t"
                       "choose(LAMBDA (t: Transition[CP, Name]):
                              (ts(a!1)(t) OR complete_trans(a!1)(t)) AND
                               scp(t) = cp(s!1) AND
                                event(t) = event(pe!1) AND
                                 guard(t)(stA(s!1), stP(pe!1), arg(pe!1))) "
                       :hide? t)
                      (("1" (typepred "t")
                        (("1" (typepred "a!1")
                          (("1" (expand "wf_MVA")
                            (("1" (expand "partial")
                              (("1" (flatten)
                                (("1" (split -7)
                                  (("1" (inst?)
                                    (("1" (expand "wf_Trans")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (split -11)
                                          (("1"
                                            (skosimp*)
                                            (("1" (assert) nil nil))
                                            nil)
                                           ("2"
                                            (skosimp*)
                                            (("2"
                                              (inst?)
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (split 3)
                                    (("1" (expand "complete_trans")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (skosimp*)
                                          (("1"
                                            (split -5)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (replace -3)
                                                (("1"
                                                  (expand "build_guard")
                                                  (("1"
                                                    (rewrite
                                                     "big_and_is_forall")
                                                    (("1"
                                                      (inst
                                                       -18
                                                       "Bool(NOT guard(t!1)(stA(s!1), stP(pe!1), arg(pe!1)))")
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (inst? 3)
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (expand
                                                               "all_guards")
                                                              (("1"
                                                                (inst? 3)
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (hide-all-but 1)
                                                      (("2"
                                                        (typepred
                                                         "all_guards(a!1)(scp(t), event(t))")
                                                        (("2"
                                                          (expand "is_finite")
                                                          (("2"
                                                            (skosimp*)
                                                            (("2"
                                                              (inst
                                                               1
                                                               "N!1"
                                                               "LAMBDA(v : ({v: (Bool?[Name]) |
                     EXISTS (p: Guard[CP, Name]):
                       all_guards(a!1)(scp(t), event(t))(p) AND
                        v =
                         Bool[Name]
                             (NOT p(stA(s!1), stP(pe!1), arg(pe!1)))})) : f!1(choose({p: Guard[CP, Name]|
                       all_guards(a!1)(scp(t), event(t))(p) AND
                        v =
                         Bool[Name]
                             (NOT p(stA(s!1), stP(pe!1), arg(pe!1)))}))")
                                                              (("1"
                                                                (expand
                                                                 "injective?")
                                                                (("1"
                                                                  (skosimp*)
                                                                  (("1"
                                                                    (inst?)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil)
                                                                     ("2"
                                                                      (rewrite
                                                                       "nonempty_exists")
                                                                      (("2"
                                                                        (typepred
                                                                         "x2!1")
                                                                        (("2"
                                                                          (skosimp*)
                                                                          (("2"
                                                                            (inst?)
                                                                            (("2"
                                                                              (assert)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("3"
                                                                      (rewrite
                                                                       "nonempty_exists")
                                                                      (("3"
                                                                        (typepred
                                                                         "x1!1")
                                                                        (("3"
                                                                          (skosimp*)
                                                                          (("3"
                                                                            (inst?)
                                                                            (("3"
                                                                              (assert)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (skosimp*)
                                                                (("2"
                                                                  (rewrite
                                                                   "nonempty_exists")
                                                                  (("2"
                                                                    (typepred
                                                                     "v!1")
                                                                    (("2"
                                                                      (skosimp*)
                                                                      (("2"
                                                                        (inst?)
                                                                        (("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (inst -14 "t!1")
                                                (("2"
                                                  (expand "wf_Trans")
                                                  (("2" (assert) nil nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (rewrite "nonempty_exists")
                        (("2" (use "complete_MVA_is_total")
                          (("2" (expand "total")
                            (("2"
                              (inst -1 "cp(s!1)" "event(pe!1)" "stA(s!1)"
                               "stP(pe!1)" "arg(pe!1)")
                              (("2" (assert)
                                (("2" (typepred "s!1")
                                  (("2" (typepred "pe!1")
                                    (("2" (expand "wf_PEvent")
                                      (("2"
                                        (expand "wf_AState")
                                        (("2"
                                          (flatten)
                                          (("2"
                                            (expand "complete_MVA")
                                            (("2"
                                              (auto-rewrite "add")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (skosimp*)
                                                  (("2"
                                                    (inst?)
                                                    (("2" (assert) nil nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((t!1 skolem-const-decl "Transition[CP, Name]" MVACompletion nil)
    (big_and_is_forall formula-decl nil MVACompletion nil)
    (Bool? adt-recognizer-decl "[Val -> boolean]" Val_adt nil)
    (all_guards const-decl "finite_set[Guard]" MVACompletion nil)
    (Bool adt-constructor-decl "[bool -> (Bool?)]" Val_adt nil)
    (p!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (v!1 skolem-const-decl "({v: (Bool?[Name]) |
    EXISTS (p: Guard[CP, Name]):
      all_guards(a!1)(scp(t), event(t))(p) AND
       v = Bool[Name](NOT p(stA(s!1), stP(pe!1), arg(pe!1)))})" MVACompletion
     nil)
    (injective? const-decl "bool" functions nil)
    (x1!1 skolem-const-decl "({v: (Bool?[Name]) |
    EXISTS (p: Guard[CP, Name]):
      all_guards(a!1)(scp(t), event(t))(p) AND
       v = Bool[Name](NOT p(stA(s!1), stP(pe!1), arg(pe!1)))})" MVACompletion
     nil)
    (x2!1 skolem-const-decl "({v: (Bool?[Name]) |
    EXISTS (p: Guard[CP, Name]):
      all_guards(a!1)(scp(t), event(t))(p) AND
       v = Bool[Name](NOT p(stA(s!1), stP(pe!1), arg(pe!1)))})" MVACompletion
     nil)
    (p!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (p!1 skolem-const-decl "Guard[CP, Name]" MVACompletion nil)
    (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (t skolem-const-decl "(LAMBDA (t: Transition[CP, Name]):
   (ts(a!1)(t) OR complete_trans(a!1)(t)) AND
    scp(t) = cp(s!1) AND
     event(t) = event(pe!1) AND guard(t)(stA(s!1), stP(pe!1), arg(pe!1)))"
     MVACompletion nil)
    (build_guard const-decl "Guard" MVACompletion nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (complete_MVA const-decl "MVA" MVACompletion nil)
    (union const-decl "set" sets nil) (member const-decl "bool" sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (complete_trans const-decl "finite_set[Transition]" MVACompletion nil)
    (Store type-eq-decl nil State nil)
    (AState type-eq-decl nil MVACommonSemantics nil)
    (wf_AState const-decl "boolean" MVACommonSemantics nil)
    (ValOrExcpt type-decl nil ValOrExcpt_adt nil)
    (PEvent type-eq-decl nil MVACommonSemantics nil)
    (wf_PEvent const-decl "boolean" MVACommonSemantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nonempty_exists formula-decl nil sets_lemmas nil)
    (a!1 skolem-const-decl "(partial)" MVACompletion nil)
    (t!1 skolem-const-decl "Transition[CP, Name]" MVACompletion nil)
    (s!1 skolem-const-decl "(wf_AState(a!1))" MVACompletion nil)
    (pe!1 skolem-const-decl "(wf_PEvent(a!1))" MVACompletion nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (total const-decl "boolean" MVAProperties nil)
    (Name formal-nonempty-type-decl nil MVACompletion nil)
    (CP formal-nonempty-type-decl nil MVACompletion nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (EventType type-decl nil EventType_adt nil)
    (Event type-eq-decl nil MVA nil) (Action type-eq-decl nil MVA nil)
    (Guard type-eq-decl nil MVA nil) (Transition type-eq-decl nil MVA nil)
    (Val type-decl nil Val_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (defined? const-decl "boolean" ValProp nil)
    (JType type-decl nil JType_adt nil) (Decl type-eq-decl nil Program nil)
    (MVA type-eq-decl nil MVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (partial const-decl "boolean" MVAProperties nil)
    (complete_MVA_is_total formula-decl nil MVACompletion nil)
    (step const-decl "lift[AState]" MVAPartialSemantics nil))
   175444 3610 t shostak)))
(EmptyMVA
 (unit_TCC1 0
  (unit_TCC1-1 nil 3413191968 3430124198
   ("" (use "CP_not_only_halted") (("" (skosimp*) (("" (inst?) nil nil)) nil))
    nil)
   proved-complete
   ((CP formal-nonempty-type-decl nil EmptyMVA nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Name formal-nonempty-type-decl nil EmptyMVA nil)
    (halted const-decl "CP" MVA nil) nil
    (CP_not_only_halted formula-decl nil EmptyMVA nil))
   124 120 t nil))
 (empty_TCC1 0
  (empty_TCC1-1 nil 3413191968 3430124198 ("" (subtype-tcc) nil nil)
   proved-complete
   ((member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil))
   8 10 nil nil))
 (empty_TCC2 0
  (empty_TCC2-1 nil 3413191968 3430124198 ("" (subtype-tcc) nil nil)
   proved-incomplete
   ((extend const-decl "R" extend nil)
    (singleton const-decl "(singleton?)" sets nil)
    (nonempty_extend application-judgement "(nonempty?[T])" extend_set_props
     nil)
    (finite_extend application-judgement "finite_set[T]" extend_set_props nil)
    (nonempty_singleton_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (choose const-decl "(p)" sets nil) (emptyset const-decl "set" sets nil)
    (Name formal-nonempty-type-decl nil EmptyMVA nil)
    (var_names const-decl "finite_set[Name]" ProgramFunctions nil)
    (member const-decl "bool" sets nil)
    (reserved_words const-decl "finite_set[Name]" Program nil)
    (intersection const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil) (disjoint? const-decl "bool" sets nil)
    (CP formal-nonempty-type-decl nil EmptyMVA nil)
    (wf_vdsA const-decl "boolean" WellFormedMVA nil)
    (wf_vdsP const-decl "boolean" WellFormedMVA nil)
    (wf_Guard const-decl "boolean" WellFormedMVA nil)
    (var_names const-decl "finite_set[Name]" MVA nil)
    (union const-decl "set" sets nil) (subset? const-decl "bool" sets nil)
    (wf_Body const-decl "boolean" WellFormedMVA nil)
    (wf_Expr const-decl "boolean" WellFormedMVA nil)
    (wf_Action const-decl "boolean" WellFormedMVA nil)
    (wf_Trans const-decl "boolean" WellFormedMVA nil)
    (wf_MVA const-decl "boolean" WellFormedMVA nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_intersection1 application-judgement "finite_set" finite_sets nil))
   388 340 nil nil)))

