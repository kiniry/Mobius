
% automaton events: method entry, exit or exceptional exit
EventType : DATATYPE
BEGIN

  Entry : Entry?
  ExitNormal : ExitNormal?
  ExitExceptional : ExitExceptional?


END EventType


% Multi-Variable Automata
MVA[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING Program[Name]

  IMPORTING State[Name], ValOrExcpt[Name]

  % A guard depends on:
  % .the state of the automaton,
  % .the field store of the program,
  % .if the event is of type Entry, the argument of the method, 
  %  if it is of type ExitNormal, the value returned, and 
  %  if its type is ExitExceptional, 
  %     the  exception with which the method returns.
  Guard : TYPE = [Store, Store, ValOrExcpt -> boolean]

  % update MVA variable target with value of expression source
  OneAction : TYPE =
    [# target : Name,
       source : Expr[Name]
    #]

  Action : TYPE = list[OneAction]

  % skip is an empty action
  skip : Action = null[OneAction]

  IMPORTING EventType

  Event : TYPE =
    [# etype : EventType,
       mname : Name       % name of the method being monitored
    #]

  Transition : TYPE =
    [# scp : CP,          % source control point
       event : Event,
       guard : Guard,
       action : Action,
       tcp : CP           % target control point
    #]

  % halted represents a special error state
  halted : CP

  % An MVA consists of:
  % a name for the automaton,
  % the name of the class that the automaton will monitor,
  % a finite set of control points,
  % an initial control point,
  % a finite set of events,
  % a finite set of variable declarations used by the automaton,
  % a finite set of var decls from the program, used in guards and actions,
  % a finite transition relation.
  MVA : TYPE =
    [# name : Name,
       class_name : Name,
       cps : finite_set[CP],
       init_cp : CP,
       evs : finite_set[Event],
       vdsA : finite_set[Decl],
       vdsP : finite_set[Decl],
       ts : finite_set[Transition]
    #]

  % NOTE: vdsA and vdsP are just the signatures of the variables, they do not
  %       contain their values. Only states have values for variables.

  IMPORTING ProgramFunctions[Name] % imports var_names

  % Collected declared variable names
  var_names(a : MVA) : finite_set[Name] =
    union(var_names(vdsA(a)), var_names(vdsP(a)))

  get_MVAVarDecl(n : Name, a : MVA) : lift[Decl] =
    LET vds = {vd : Decl | vdsA(a)(vd) AND name(vd) = n}  IN
      IF empty?(vds) 
      THEN bottom 
      ELSE up(choose(vds))
      ENDIF


END MVA


% Constraints for well-formed MVAs
WellFormedMVA[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MVA[CP, Name]

  % A Body <b> is well formed with respect to an MVA <a> if all the variables
  % mentioned in <b> are declared by <a> and <b> does not contain a JML set
  % command. This last restriction is necessary to avoid that monitoring
  % updates the program state 
  wf_Body(a : MVA)(b : Body) : boolean =
    subset?(var_names(b), var_names(a)) AND
    (FORALL (b1 : Body) : subterm(b1, b) IMPLIES NOT Set?(b1))

  wf_Expr(a : MVA)(e : Expr) : boolean =
    wf_Body(a)(e)

  % A set of variable declaration for internal use of the automaton is well
  % formed if their names are disjoint and they are not reserved words.
  wf_vdsA(vds : finite_set[Decl]) : boolean =
    (FORALL (vd1, vd2 : Decl) : vds(vd1) IMPLIES vds(vd2) IMPLIES
       name(vd1) = name(vd2) IMPLIES vd1 = vd2) AND
    disjoint?(var_names(vds), reserved_words)

  % A set of variable declarations taken from the program is well formed if
  % their names are disjoint.
  wf_vdsP(vds : finite_set[Decl]) : boolean =
    FORALL (vd1, vd2 : Decl) : vds(vd1) IMPLIES vds(vd2) IMPLIES
      name(vd1) = name(vd2) IMPLIES vd1 = vd2

  % A guard is well formed w.r.t. an MVA <a> if it only depends on the 
  % variables  of the automaton (i.e. vdsA and vdsP). 
  % Thus, changing the value of an undeclared variable does not affect 
  % value of guard.
  wf_Guard(a : MVA)(g : Guard) : boolean =
    FORALL (sA, sP : Store, arg : ValOrExcpt, n : Name, v : Val) :
      (NOT var_names(vdsA(a))(n) AND NOT var_names(vdsP(a))(n)) IMPLIES
        g(sA, sP, arg) = g(sA WITH [n |-> v], sP, arg) AND
        g(sA, sP, arg) = g(sA, sP WITH [n |-> v], arg)

  % An action is well formed w.r.t. <a> if for each of its OneAction members,
  % the target is a variable declared in <a> and the source expression is
  % well formed w.r.t. <a>.
  wf_Action(a : MVA)(l : Action) : boolean =
    FORALL (c : OneAction) :
      member(c, l) IMPLIES 
        (var_names(vdsA(a))(target(c)) AND
         wf_Expr(a)(source(c)))

  % A transition is well formed w.r.t. an MVA <a> if:
  % Its source and target control points are in the set of 
  % control points of <a>,
  % Its event is in the set of events of <a>,
  % Guards and actions are well formed w.r.t. <a>.
  wf_Trans(a : MVA)(t : Transition) : boolean = 
    ts(a)(t) IMPLIES
      cps(a)(scp(t)) AND
      cps(a)(tcp(t)) AND
      evs(a)(event(t)) AND
      wf_Guard(a)(guard(t)) AND
      wf_Action(a)(action(t))

  % An MVA <a> is well formed if:
  % The initial cp is in the set of control points of <a> and is not halted,
  % The sets vdsA and vdsP are well formed,
  % The name of the variables in vdsA and vdsP are disjoint,
  % The transitions are well formed w.r.t. <a>.
  wf_MVA(a : MVA) : boolean =
    cps(a)(init_cp(a)) AND
    NOT init_cp(a) = halted AND % needed to prove initial_states_are_equivalent
    wf_vdsA(vdsA(a)) AND
    wf_vdsP(vdsP(a)) AND
    disjoint?(var_names(vdsA(a)), var_names(vdsP(a))) AND
    FORALL (t : Transition) : wf_Trans(a)(t)


END WellFormedMVA


MVAProperties[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING WellFormedMVA[CP, Name]

  % An MVA is deterministic if for every source control point and event, there
  % is at most one guard that holds. In other words, given two transitions of
  % the automata, if they have the same scp, event and their guards hold for
  % some state, then they are the same.
  deterministic(a : MVA) : boolean =
    FORALL (t1, t2 : Transition, stA, stP : Store, arg : ValOrExcpt) :
      ts(a)(t1) IMPLIES
      ts(a)(t2) IMPLIES
      scp(t2) = scp(t1) IMPLIES
      event(t2) = event(t1) IMPLIES
      guard(t1)(stA, stP, arg) IMPLIES
      guard(t2)(stA, stP, arg) IMPLIES
        t1 = t2

  % An MVA is partial if is deterministic and does not contain halted as
  % control point.
  % Any partial MVA can be completed by complete_MVA
  % A partial MVA is suitable for monitoring
  partial(a : (wf_MVA)) : boolean =
    deterministic(a) AND NOT cps(a)(halted)

  % An MVA is total if for any source control point and event there is exactly
  % one guard that holds.
  total(a : MVA) : boolean =
    FORALL (q : CP, e : Event, stA, stP : Store, arg : ValOrExcpt) :
      cps(a)(q) IMPLIES
      evs(a)(e) IMPLIES
        EXISTS (t : Transition) : ts(a)(t) AND
                                  scp(t) = q AND
                                  event(t) = e AND
                                  guard(t)(stA, stP, arg)

  % A trap state is a control point where every outgoing transition 
  % leads to itself.
  trap_state(q : CP, a : (wf_MVA)) : boolean =
    FORALL (t : Transition) :
      ts(a)(t) AND scp(t) = q IMPLIES
        tcp(t) = q

  % An MVA is complete if it is:
  % - wellformed
  % - it contains halted as control point
  % - halted is a trap_state
  % - it is deterministic
  % - it is total
  % A complete MVA is suitable for monitoring
  % Below we define a function complete_MVA that transforms any
  % partial MVA into a complete one.
  complete(a : MVA) : boolean =
    wf_MVA(a) AND
    cps(a)(halted) AND
    trap_state(halted, a) AND
    deterministic(a) AND
    total(a)

END MVAProperties


% Definitions and properties used by MVAPartialSemantics and MVATotalSemantics
MVACommonSemantics[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING WellFormedMVA[CP, Name], 
            State[Name]


  % A store <st> is a well formed program state w.r.t. a finite set of 
  % program variable <vds> names if all variable that in <vds> are defined 
  % in <st> (ie not Bottom).
  % Notices that the variable names in <vds> can be a subset of the 
  % program variables names (otherwise we could use wf_store from State)
  wf_PSt(st : Store)(vds : finite_set[Name]) : boolean =
    FORALL (n : Name) :
      vds(n) IMPLIES defined?(st(n))


  % type of program event
  % triggers automaton transition
  % contains program store (for variables used in automaton)
  % event type and
  % argument (for method call), result (method entry) or exception
  % (exceptional method entry) 
  PEvent : TYPE =
    [# stP : Store,
       event : Event,
       arg : ValOrExcpt
    #]

  % A PEvent is well formed w.r.t. to an MVA <a> if its event belong to the set
  % of events of <a> and its program state is well formed w.r.t. 
  % to the program variable declarations of <a>.
  wf_PEvent(a : MVA)(pe : PEvent) : boolean =
    evs(a)(event(pe)) AND wf_PSt(stP(pe))(var_names(vdsP(a)))

  % NOTE: eval is implicitly defined by eval_action_behaviour in WellBehavedMVA
  % eval expression depends on program and automaton state

  % Since we only consider the PSt of the state of the program, actions can not
  % use ghost variables of the monitored program (this could be changed)
  eval(e : Expr)(stA, stP : Store) : Val

  % Action evaluation must return a defined value (thus it can not
  % throw an exception). 
  % Note that this is required by well_behaved_MVA, but for simplicity we
  % specify it here (otherwise we have to move execute_action_yields_wf_state
  % and step_yields_wf_state to WellBehavedMVA as well).
  eval_yields_not_bottom : AXIOM
    FORALL (a : MVA, e : Expr, stA, stP : Store) :
      wf_store(stA)(var_names(vdsA(a))) IMPLIES
      wf_PSt(stP)(var_names(vdsP(a))) IMPLIES
        defined?(eval(e)(stA, stP))


  % An action is executed by executing each of its OneActions in order.
  execute_action(l : Action)(stA, stP : Store) : RECURSIVE Store =
    IF null?(l)
    THEN stA
    ELSE execute_action(cdr(l))
           (update_store(target(car(l)), eval(source(car(l)))(stA, stP))(stA),
            stP)
    ENDIF
  MEASURE length(l)

  % wf_store preserved by execute_action (if action wellformed)
  execute_action_yields_wf_state : LEMMA % :-)
    FORALL (a : MVA, l : Action, stA, stP : Store) :
      wf_store(stA)(var_names(vdsA(a))) IMPLIES
      wf_PSt(stP)(var_names(vdsP(a))) IMPLIES
      wf_Action(a)(l) IMPLIES
        wf_store(execute_action(l)(stA, stP))(var_names(vdsA(a)))

  % The state of an MVA is composed by its currrent control point and values
  % for its variables.
  AState : TYPE =
    [# cp : CP,
       stA : Store
    #]

  % Initial state of an MVA.
  % control point is initial control point
  % all declared automaton variables are mapped to their initial value, 
  % otherwise to Bottom
  initial_MVA_state(a : MVA) : AState =
    (# cp := init_cp(a),
       stA := LAMBDA (n: Name) :
         LET vd = get_MVAVarDecl(n, a) IN
         IF bottom?(vd)
         THEN Bottom
         ELSE init_val(down(vd))
         ENDIF
    #)

  % automaton state is wellformed is control point is in set of control points
  % and automaton store wellformed wrt automaton variable
  wf_AState(a : MVA)(s : AState) : boolean =
    cps(a)(cp(s)) AND
    wf_store(stA(s))(var_names(vdsA(a)))


  %  Well-formed lemmas

  % initial automaton state is wellformed
  wf_initial_MVA_state: LEMMA % :-)
    FORALL (a: MVA) :
      wf_MVA(a) IMPLIES wf_AState(a)(initial_MVA_state(a))


END MVACommonSemantics


% Partial step relation (defined for partial and total MVAs)
MVAPartialSemantics[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MVACommonSemantics[CP, Name], 
            MVAProperties[CP, Name]

  % Single step judgement for a partial MVA.
  step(a : MVA)(s : (wf_AState(a)), pe : (wf_PEvent(a))) : lift[AState] =
      IF EXISTS (t : Transition) :
                       ts(a)(t) AND 
                       scp(t) = cp(s) AND 
                       event(t) = event(pe) AND
                       guard(t)(stA(s), stP(pe), arg(pe))
      THEN LET t = choose(LAMBDA (t : Transition) : 
                       ts(a)(t) AND 
                       scp(t) = cp(s) AND 
                       event(t) = event(pe) AND
                       guard(t)(stA(s), stP(pe), arg(pe))) IN
      up((# cp := tcp(t),
         stA := execute_action(action(t))(stA(s), stP(pe))
         #))
      ELSE bottom
      ENDIF


  %  Well-formed lemmas

  % wf_state preserved by automaton step
  step_yields_wf_state : THEOREM % :-)
    FORALL (a : MVA, s : (wf_AState(a)), pe : (wf_PEvent(a))) :
      wf_MVA(a) IMPLIES
      up?(step(a)(s, pe)) IMPLIES
      wf_AState(a)(down(step(a)(s, pe)))


  % a complete MVA can always make a step
  complete_definedness : LEMMA  % :-)
    FORALL(a : (complete), 
           s : (wf_AState(a)), pe : (wf_PEvent(a))) :
      up?(MVAPartialSemantics.step(a)(s, pe))

END MVAPartialSemantics


% Total step relation, only defined for total MVA
MVATotalSemantics[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MVACommonSemantics[CP, Name],
            MVAProperties[CP, Name]

  % Single step judgement for a total MVA.
  step(a : (total))(s : (wf_AState(a)), pe : (wf_PEvent(a))) : AState =
      LET t = choose(LAMBDA (t : Transition) : 
                       ts(a)(t) AND 
                       scp(t) = cp(s) AND 
                       event(t) = event(pe) AND
                       guard(t)(stA(s), stP(pe), arg(pe))) IN
      (# cp := tcp(t),
         stA := execute_action(action(t))(stA(s), stP(pe))
      #)


  %  Well-formed lemmas

  % wf_state preserved by automaton step
  step_yields_wf_state : THEOREM % :-)
    FORALL (a : (total), s : (wf_AState(a)), pe : (wf_PEvent(a))) :
      wf_MVA(a) IMPLIES
      wf_AState(a)(step(a)(s, pe))


END MVATotalSemantics


% Assumptions about MVAs needed to prove correctness of translation
MVAMonitoring[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING WellFormedMVA[CP, Name]

  % We need a way to translate a guard into a Java boolean expression.
  % In an implementation we would define a language for writing guards (probably
  % a subset of Java) and then we would translate them into Java. In our
  % specification we modelled guards as uninterpreted functions. We assume a
  % function guard_to_expression, whose behaviuor is defined axiomatically.

  % guard_to_expression is implicitly defined by guard_to_expression_behavior
  % in Equivalence.
  guard_to_expression(g : Guard) : [ValOrExcpt -> Expr]

  % assumptions on guard_to_expression

  % guard_to_expression produces wellformed expressions
  % i.e. any guard occurring in a translates into an expression that is 
  % wellformed wrt a
  guard_to_expression_yields_wf_Expr : AXIOM
    FORALL(a : MVA, t : Transition) :
      wf_MVA(a) IMPLIES
      ts(a)(t) IMPLIES
        FORALL(v : ValOrExcpt) :
          wf_Expr(a)(guard_to_expression(guard(t))(v))

  % guard_to_expression produces expressions that do not contain TryCatch 
  % statements (exclude operational aspects of Java)
  guard_to_expression_contains_no_TryCatch : AXIOM
    FORALL(a : MVA, t : Transition) :
      wf_MVA(a) IMPLIES
      ts(a)(t) IMPLIES
        FORALL(v : ValOrExcpt, b : Body) :
          subterm(b, guard_to_expression(guard(t))(v)) IMPLIES
            NOT TryCatch?(b)

  IMPORTING ContainsNoMethodCall[Name]

  % guard_to_expressions produces expressions that do not contain method calls
  guard_to_expression_contains_no_method_calls : AXIOM
    FORALL(a : MVA, t : Transition) :
      wf_MVA(a) IMPLIES
      ts(a)(t) IMPLIES
        FORALL(v : ValOrExcpt) :
        contains_no_method_call(guard_to_expression(guard(t))(v))

  % sources of actions do not contain method calls
  action_sources_contains_no_method_calls : AXIOM
    FORALL(a : MVA, t : Transition) :
      wf_MVA(a) IMPLIES
      ts(a)(t) IMPLIES
        FORALL(l : OneAction) :
          member(l, action(t)) IMPLIES
            contains_no_method_call(source(l))

  % sources of actions do not contain TryCatch statement
  % (excluding operational aspects of Java)
  action_sources_contains_no_TryCatch : AXIOM
    FORALL(a : MVA, t : Transition) :
      wf_MVA(a) IMPLIES
      ts(a)(t) IMPLIES
        FORALL(l : OneAction, b : Body) :
          member(l, action(t)) IMPLIES
          subterm(b, source(l)) IMPLIES
            NOT TryCatch?(b)

END MVAMonitoring


% This theory defines the MVA completition function, which is used in the
% first step of the translation algorithm.
MVACompletion[CP, Name : TYPE+] : THEORY
BEGIN

  IMPORTING MVAProperties[CP, Name]

  % Returns the set of guards from transitions with cp as source control
  % point and e as event.
  all_guards(a : MVA)(cp : CP, e : Event) : finite_set[Guard] =
    {p : Guard | EXISTS (t : Transition) : ts(a)(t) AND scp(t) = cp AND
                                           event(t) = e AND guard(t) = p}

  big_and(V : finite_set[(Bool?)]) : RECURSIVE (Bool?) =
    IF empty?(V)
    THEN Bool(TRUE)
    ELSE Bool(b(choose(V)) AND b(big_and(rest(V))))
    ENDIF
  MEASURE card(V)

  IMPORTING finite_sets@finite_sets_inductions[(Bool?)]

  big_and_is_forall : LEMMA % :-)
    FORALL(V : finite_set[(Bool?)]) :
      b(big_and(V)) = FORALL(v : (Bool?)) : V(v) IMPLIES b(v)

  big_conj(E : finite_set[Expr]) : RECURSIVE Expr =
    IF empty?(E)
    THEN Const(Bool(TRUE))
    ELSE Conj(choose(E), big_conj(rest(E)))
    ENDIF
  MEASURE card(E)
 
  % Returns a guard that is the conjuction of the negation of the guards in ts
  % with source control point cp and event e. 
  build_guard(a : MVA)(cp : CP, e : Event) : Guard =
   LAMBDA (stA, stP : Store, arg : ValOrExcpt) :
     b(big_and({v : (Bool?) | EXISTS(p : Guard) :
                                all_guards(a)(cp, e)(p) AND
                                v = Bool(NOT p(stA, stP, arg))}))

  % Makes ts(a) complete with respect to cps and evs(a).
  complete_trans(a : MVA) : finite_set[Transition] =
    union({t : Transition | cps(a)(scp(t)) AND evs(a)(event(t)) AND
                            guard(t) = build_guard(a)(scp(t), event(t)) AND
                            action(t) = skip AND tcp(t) = halted},
          {t : Transition | scp(t) = halted AND evs(a)(event(t)) AND
                            guard(t) = (LAMBDA (stA : Store, 
                                                stP : Store, 
                                                arg : ValOrExcpt) : TRUE)
                            AND action(t) = skip AND tcp(t) = halted})

  

  IMPORTING finite_sets@finite_sets_inductions[Expr]


  % auxiliary lemma, to prove guard_to_expression_build_guard_wf_Expr
  % (proof is not allow to use guard_to_expression_wf_Expr axiom)
  big_conj_wf_Expr : LEMMA % :-)
    FORALL(a : MVA)(E : finite_set[Expr]) :
      (FORALL (e : Expr) : E(e) IMPLIES wf_Expr(a)(e)) IMPLIES
      wf_Expr(a)(big_conj(E))

  IMPORTING MVAMonitoring[CP, Name]

  guard_to_expression_build_guard : AXIOM
    FORALL(a : MVA)(cp : CP, e : Event, v : ValOrExcpt) :
      guard_to_expression(build_guard(a)(cp, e))(v) =
        big_conj({expr : Expr |
                  EXISTS (g : Guard) : all_guards(a)(cp, e)(g) AND
                                       expr = Neg(guard_to_expression(g)(v))})

  % sanity check 
  % (proof is not allow to use guard_to_expression_wf_Expr axiom)
  guard_to_expression_build_guard_wf_Expr : LEMMA % :-)
    FORALL(a : MVA)(cp : CP, e : Event)(v : ValOrExcpt) : 
      (FORALL (t : Transition) : 
         ts(a)(t) IMPLIES 
         scp(t) = cp IMPLIES
         event(t) = e IMPLIES
          wf_Expr(a)(guard_to_expression(guard(t))(v))) IMPLIES
      wf_Expr(a)(guard_to_expression(build_guard(a)(cp, e))(v))

  guard_to_expression_LAMBDA_true : AXIOM
    guard_to_expression(LAMBDA(stA, stP : Store, arg : ValOrExcpt) : TRUE) =
      LAMBDA(arg : ValOrExcpt) : Const(Bool(TRUE))

  % sanity check 
  % (proof is not allow to use guard_to_expression_wf_Expr axiom)
  guard_to_expression_LAMBDA_true_wf_Expr : LEMMA % :-)
    FORALL(a : MVA, v : ValOrExcpt) :
      wf_Expr(a)(guard_to_expression
                   (LAMBDA(stA, stP : Store, arg : ValOrExcpt) : TRUE)(v))
    
  % Makes a deterministic MVA total.
  complete_MVA(a : (partial)) : MVA =
    a WITH [cps := add(halted, cps(a)),
            ts := union(ts(a), complete_trans(a))]


  build_guard_yields_wf_guard : LEMMA % :-)
    FORALL (a : MVA, cp : CP, e : Event ) :
      wf_MVA(a) IMPLIES wf_Guard(a)(build_guard(a)(cp, e))

  complete_MVA_yields_wf_MVA : LEMMA % :-)
    FORALL (a : (partial)) :
      wf_MVA(complete_MVA(a))

  complete_MVA_has_trap_state: LEMMA % :-)
    FORALL (a : (partial)) :
      trap_state(halted, complete_MVA(a))

  complete_MVA_is_deterministic : LEMMA % :-)
    FORALL (a : (partial)) :
      deterministic(complete_MVA(a))

  complete_MVA_is_total : LEMMA % :-)
    FORALL (a : (partial)) :
      total(complete_MVA(a))

  complete_MVA_is_complete : THEOREM % :-)
    FORALL (a : (partial)) :
      complete(complete_MVA(a))

  evs_complete_MVA : LEMMA % :-)
    FORALL (a : (partial)) :
      evs(complete_MVA(a)) = evs(a)


  IMPORTING MVAPartialSemantics[CP, Name], 
            MVATotalSemantics[CP, Name]

  completion_equivalence : LEMMA  % :-)
    FORALL(a : (partial), 
           s : (wf_AState(a)), pe : (wf_PEvent(a))) :
      MVAPartialSemantics.step(a)(s, pe) = bottom IFF
        cp(MVATotalSemantics.step(complete_MVA(a))(s, pe)) = halted

  completion_equivalence2 : LEMMA  % :-)
    FORALL(a : (partial), 
           s : (wf_AState(a)), pe : (wf_PEvent(a))) :
      MVAPartialSemantics.step(a)(s, pe) = bottom IFF
        cp(down(MVAPartialSemantics.step(complete_MVA(a))(s, pe))) = halted

END MVACompletion


EmptyMVA[CP, Name : TYPE+] : THEORY
BEGIN

ASSUMING 

    IMPORTING MVA[CP, Name]

    CP_not_only_halted : ASSUMPTION
      EXISTS(cp : CP) : NOT cp = halted

ENDASSUMING

  unit : (LAMBDA(cp : CP) : NOT cp = halted)

  IMPORTING WellFormedMVA[CP, Name]

  % empty automaton with single control points, and no transitions
  empty(cln : Name) : (wf_MVA) =
   (# name := choose({n : Name | TRUE}),
       class_name := cln,
       cps := singleton(unit),
       init_cp := unit,
       evs := emptyset[Event],
       vdsA := emptyset[Decl],
       vdsP := emptyset[Decl],
       ts := emptyset[Transition]
   #)

END EmptyMVA
