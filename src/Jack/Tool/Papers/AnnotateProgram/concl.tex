\section{Conclusions \& Future Work }\label{SecConcl}

This paper presents an algorithm to inline security automata, in the
form of JML annotations. The translation is defined in several steps,
thanks to the introduction of method-level set-annotations as
extension to JML. All steps are formalised and proven correct, using
the PVS theorem prover. The algorithm might seem trivial, but several
subtleties complicate the proof, \emph{i.e.}~evaluating the
specifications in the right order, dealing with side-effect-freeness
of annotations and the possibility that a
\emph{finally} block hides exceptions. 

% First of all,
% for the main step, where the monitor is encoded in method-level set
% annotations, it is not straightforward to state the correct relation
% that is maintained between the two program executions. In particular,
% once the \halted state is reached, the correspondence between the two
% program states is not preserved anymore, because the monitored program
% might continue executing, while the annotated program throws an
% exception. Also, to prove correctness of this translation step, it was
% important to specify the evaluation of pre- and postcondition, class
% invariant and pre- and post-set annotations in the right order, to ensure
% that the relation was reestablished as quickly as possible~--~so that
% the induction hypothesis could be applied for the other
% steps. Adding the additional assert to the pre-set annotation was also
% crucial for correctness.
% Finally, a last important issue here was the behaviour of the
% \TryCatch statement, where exceptions in the \emph{finally} block can
% overwrite other exceptions.

The formalisation has been developed for a subset of Java. We believe
that extending it to full (sequential) Java would be relatively
straightforward. However, generalising to properties that are not
restricted to a single class or that are related to multithreading
might be more challenging.

The ultimate goal of our work is to statically verify adherence to
security policies. 
To achieve this, a weakest precondition calculus can
be used to generate pre- and postconditions, 
based on the generated
\Set annotations. 
In earlier work, we presented such a propagation
algorithm~\cite{PavlovaBBHL04}, and proved correctness for a limited
case (instance variables and branches are not considered). It is
future work to overcome these limitations.
%  We will then
% also exploit the existing PVS formalisation, to prove the formal
% correctness of the propagation with a theorem prover.
