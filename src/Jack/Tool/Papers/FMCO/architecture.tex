
\section{General Architecture of JACK}\label{SecArchitecture}

This section describes the general architecture of JACK, and how it
aims at a high level of precision.  The next section then discusses
how JACK has been made accessible to application developers by
integration within the IDE Eclipse, and the development of the special
JACK perspective. For the development of the JACK architecture, the
main design principles were the following:
\begin{itemize}
\item integration within a widely-used IDE, so that developers do not
have to learn a new environment, and do not have to switch between tools;
\item automatic generation of proof obligations by
implementation of a weakest precondition (wp) calculus;
\item proof obligations are first-order logic formulae; and
\item prover independence, \emph{i.e.}, proof obligations for
a single application can be verified with different provers.
\end{itemize}

The wp-calculus that is implemented is a so-called ``direct''
calculus, meaning that it works directly on an AST representation of
the application, and it does not use a transformation into guarded
commands, as is done by \emph{e.g.},  ESC/Java.  The wp-calculus is
based on the classical wp-calculus developed by
Dijkstra~\cite{Dijkstra75}, but adapted to Java by extending it with
side-effects, exceptions and other abrupt termination constructs
(\emph{cf.}\
\emph{e.g.},~\cite{Jacobs04}).
Method invocations are abstracted by their specifications, since we
want verification to be modular.  This direct wp-calculus has the
advantage that it is easy to generate proof obligations for each path
through a method, and then to connect the proof obligation with the
path through the method that gave rise to this particular proof
obligation (to achieve this, also some program flow information is
associated to each proof obligation). This connection makes the
understanding of the generated proof obligations easier. Another
advantage of this approach is that the algorithms for annotation
generation as described below in Section~\ref{SecAnnotGen} could make
direct use of the weakest precondition infrastructure. A drawback of
this approach is that the size of the generated proof obligation may
be exponential in the size of the code fragment being
checked~\cite{FlanaganS01}.


%\marginpar{MH: Please check what I say here! Should we say something about
%drawbacks?}

To avoid this blow up in the size of the proof obligation, and to
ensure that proof obligations can be generated automatically, JACK
uses several new specification constructs, introduced
in~\cite{BurdyRL03}: loops can be annotated with frame conditions
(\texttt{loop\_modifies}) and exceptional postconditions
(\texttt{loop\_exsures}), and any code block can be specified with a
block specification (similar to a method specification). The loop
frame condition is used in the the wp-calculus to make a universal
quantification over the loop invariant when generating the appropriate
proof obligations. Block specifications and
\texttt{loop\_exsures} clauses improve readability and reduce the
number of proof obligations, because they reduce the number of paths
through a method that have to be considered.


JACK generates its proof obligations in an abstract formula language,
representing first-order logic formulae. It is straightforward to
translate the abstract formulae into a proof obligation for a
particular prover. Adding a new prover as a plug-in to the tool is
simple: one develops a background theory formalising Java's type
system and memory model, and one defines how the abstract formulae are
translated into concrete proof obligations for this particular
prover. Initially, JACK was designed to use the AtelierB
prover~\cite{Abrial96}, now Simplify and Coq are the best
supported back-end provers for JACK.




