\section{Pure methods}
JML's pure methods are methods that can be used in specifications.
They cannot mutate already existing objects but they can allocate new objects.
Nonetheless, the pure keyword is not an alias for JML 
\code{modifies $\backslash$nothing}, 
it implies also that the methods terminates, giving a result or throwing an 
exception.
For instance if a constructor only modifies the object that is being 
created and terminates properly
it can be considered as pure.
A mean to verify whether a method is pure or not according to JML
can be found in \cite{salcianu05}. 



In dynamic program verification pure methods are usually built from 
their source code. 
The method is first thought on the Java level, without side effects, 
and afterward the user writes its specifications on the JML level; 
in order to be able to use it in JML annotations.
In static program verification,  pure methods can be built directly
from their specifications, since most of the tools replace pure method's calls 
 by the instantiation of the pure method's specifications.


%\subsection{Jack's implementation}
%In Jack the notion of purity used is as in JML a kind of observational 
%purity \cite{naumann05}, but a constructor that modifies the fields 
%of the newly created objects is not considered as pure.
%In Jack's weakest precondition calculus the specifications are considered 
%as lightweight: the method calls are replaced by their specifications 
%inside the calculus.
%The replacement with its specifications is done with the normal 
%specifications in case the method terminated normally or with the 
%exceptional specification if the pure method terminated on an exception.
 
%For a method defined in a Java file: 
%\btab
% /*\=@ requires tab != null;\+\\
%  @  modifies $\backslash$nothing;\\
%  @ ensures   $\backslash$result == (0 $\le$ i \&\& i $\le$ tab.length);\\
%  @ exsures false;\\
%  @*/\-\\
%publi\=c static /*@ pure @*/  withinBounds(int[] tab, int i) \{\+\\
%       return 0 $\le$ i \&\& i $\le$ tab.length;\-\\
%\}
%\etab
%with this method call within the annotations: 
%\btab
%withinBounds(tab,i)
%\etab
%the method call will be replaced in the weakest precondition calculus by:
%\btab
%(tab $!=$ null) \rarrow \ (0 $\le$ i) \conj \ (i $\le$ tab.length)
%\etab
%Since the specification
%of the method has an \code{exsures false} clause, there is no exceptional case.
%In a way, this method will be replaced by its specifications like for a macro.



\subsection{Specification macros}

When specifying a program with JML one of the main problems is the 
growth of the size of the annotations. 
The way static verification tools usually define the handling 
of pure methods, we can use them to do some specification macros.
The method calls will be replaced by their specifications when the 
annotations will be interpreted by the tool. It is useful to avoid the growth.
If we have for instance a property to tell an array is sorted we would 
prefer to read the annotation
{\tt withinBounds(tab, i)}
instead of: {\tt (0 $\le$ i \&\& i $<$ tab.length)}.

This method makes the annotations clearer, but as annotations 
grows big, proof obligations grows big too. In order to ease the readability 
of the proof obligations, we would like to keep track of the pure method name
that was used as the macro in order to see what part of the specification we 
are proving. That's why we do pure method's substitution in Jack.
We have a couple Definition / hypothesis.
A functional definition is generated of the form:
\btab
mypurefun\_norm  Args Result := (requires Args) \rarrow 
\ (ensures Args Result)\\
mypurefun\_exc  Args Result := (requires Args) \rarrow 
\ (exsures Args Result) \etab
where \code{requires} is a predicate that is on the arguments of 
the pure function and which correspond to JML \code{requires} 
clause the same for \code{ensures} and \code{exsures} 
which are predicates that correspond to JML's \code{ensures} and 
\code{exsures} clause respectively.
These functions are then called within the hypothesis at the places 
where they were used in the code. 

It is nearly what is done in Krakatoa\cite{MPMU-04-JLAP}, as
Krakatoa use a functional definition of the pure method if it can generate it
but otherwise use an axiomatisation of it like in ESC/Java\cite{COKK-04-ESCJ}.
The axiomatisation is done in 3 parts: the pure method is first declared 
as a variable, there is some hypothesis  using it and giving 
it its properties (which correspond to its specifications), 
and then the variable is used within the lemma which has to be 
proved (for more detailed comparison between 
the different technique see: \cite{COK-04-METH,DarvasMueller-05}).

This way of defining Definition/Hypothesis doesn't change anything 
for automatic proof of the proof obligations with prover like Simplify. 
%However, with Coq 
%it add an extra step to the proof which is to unfold the definition 
%within the hypothesis. Nevertheless,  
With Coq,
it facilitate the readability of the proof obligation for the user which 
is a critical point, notably when doing an interactive proof.

\subsection{Pure as Predicates}
Some of the properties we have to express are not so easy to deal with 
on the JML level. 
We want to be able to prove lemmas concerning pure methods, and also have 
relations over  variables without specifying any property on the relation. 
So we decided to be able to define pure methods directly within 
the language in which the proof 
obligations are generated or the JML annotations are interpreted. 
We added a new keyword to JML in order to allow it explicitly: 
the \code{native} keyword. 
If a method is declared within a specification as {\tt native}, 
it will be an uninterpreted symbol function.
%the method will not be defined nor specified in JML at all, it will only be declared. 
Its specifications will be to the target prover or environment discretion.

Since the native methods are declared within the specifications they must 
be pure: they must not have any side-effect, they can only create objects, 
they have to be terminating. 
But native is more restrictive than pure: 
a native method must not throw any exception.


For instance we can have the property \code{withinBounds} declared as native, 
inside the specification:
\btab
//@ public native static boolean withinBounds(int [] tab, int i); 
\etab
If interpreted with a dynamic program verification tool, it
can be defined with the Java method:
\btab
public \= static boolean withinBounds(int [] tab, int i) \{\+\\
    return (tab $!=$ null) \&\& (0 $\le$ i) \&\& (i $\le$ (tab.length));\-\\
\}
\etab
If interpreted with a static program verification tool,
it can be defined this way in Coq, within a library file:
\btab
Def\=inition withinBounds := \+\\
fun \= (tab i) =>\+\\
       (and (not (tab = null)) (and (0 $\le$ i) (i $\le$ (arraylength tab))).
\etab
In Simplify it will be seen as an uninterpreted function symbol, 
just a relation on the arguments.
In Jack, the binding from the JML declaration to the \code{native} 
language is done automatically.
The arguments passed to the method are the same as the one whose the method 
was declared with except:
\begin{itemize}
\item if the method is an instance method, an extra argument \code{this} 
is added by Jack 
  at the beginning of the method when it is translated
\item if one of the argument is an array, the array dereferencing relation
(to do array access) and its length relation are also given
\end{itemize}


For static program verification, this construct can be really useful, 
especially if it is used in the pure macro fashion. 
%Even though we lose the ability to express JML's behaviour
%with these specification macros, 
We can also easily prove properties over specifications in the target prover language. 
Once these properties are proved, they can be added as a help
to ease the automatic solving to some of the proofs of the proof obligations.

In  ESC/Java or Krakatoa it is permitted to define a pure method in
specifications only, but the methods declared this way are defined by the 
tools in their prover output. The native keyword for methods is more 
similar to other constructs of these tools.
%Krakatoa is indeed a front-end for Java and JML to the. 
%In these tool there exists  mechanisms 
%which allow similar definitions as the native keyword for specification
%methods, but they are more tool dependent. 
In Krakatoa, we can find 
the \code{parameter} construct  but it is not used on the JML level, it is used on the
 Why tool \cite{Why-Tool} level. 
In ESC/Java, the \code{dttfsa} construct 
is a way to call prover defined function symbols, but these function symbols are not declared 
on the JML level.

% the former not being and the later
%being just a way to call prover defined function symbols, with 
%the return type, the method name and the function parameters passed as parameters
%to the keyword.


