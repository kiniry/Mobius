\subsection{Checking High-Level Security Properties}\label{SecResults} 

Using the techniques of Section~\ref{sec:highlevel}, we checked for
several realistic applications whether they respect the security
properties presented in Section~\ref{SecHighLevelSecProp}, and
actually found some violations.  This section presents these results
for the PACAP case study of Gemplus, focusing on the atomicity properties.


\subsubsection{Core-annotations for Atomicity Properties}

The core-annotations related to the atomicity properties specify the
methods related to the transaction mechanism declared in class
\texttt{JCSystem} of the Java Card API. As explained above, a static
ghost variable \texttt{TRANS} is used to keep track of whether there
is a transaction in progress.  


To check for the absence of uncaught exceptions inside transactions,
we use a special feature of JACK, namely pre- and postcondition
annotations for statement blocks (as presented
in~\cite{BRL-JACK}). Block annotations are  similar to method
specifications. The propagation algorithm is adapted, so that it not
only generates annotations for methods, but also for designated
blocks. As core-annotation, we add the following annotation for
\texttt{commitTransaction}. 
\begin{verbatim}
/*@ exsures (Exception) TRANS == 0; @*/
public static native void commitTransaction() 
                          throws TransactionException;
\end{verbatim}
This specifies that exceptions only can occur if no transaction is in
progress. Propagating these annotations to statement blocks ending
with a commit guarantees that if exceptions are thrown, they have to
be caught within the transaction.

%that these only can raise exceptions, if they
%do not start a transaction.

%An exceptional postcondition is added claiming that an exeption can be
%thrown only if no transaction is open.  The propagation of this
%exceptional postcondition mechanism leads to annotate the block that
%terminates with the commit of the transaction and all calling methods.

Finally, in order to check that only a bounded number of retries of
pin-verification is possible, we annotate the method \texttt{check}
(declared in the interface \texttt{Pin} in the
standard Java Card API) with a precondition, requiring that no
transaction is in progress.
\begin{verbatim}
/*@ requires TRANS == 0; @*/
public boolean check(byte[] pin, short offset, byte length);
\end{verbatim}
Note: one could enforce a weaker property than not checking
PIN in transactions, but it is good practice to do so.

\subsubsection{Checking atomicity}
The method of Section~\ref{sec:highlevel} has been applied on
industrial examples of TPD applications to check that atomicity
properties are respected.



 We used the core-annotations as presented above, and
propagated these throughout the applications.

For both applications we found that they contained no nested
transactions, and that they did not contain attempts to verify pin
codes within transactions. All proof obligations generated
\emph{w.r.t.}~these properties are trivial and can be discharged
immediately. However, to emphasize once more the usefulness of having
a tool for generating annotations, in the PACAP case study we
encountered cases where a single transaction gave rise to twenty-three
annotations in five different classes. When writing these annotations
manually, it is very easy to forget some of them.

Finally, in the PACAP application we found transactions containing
uncaught exceptions. Consider for example the following code fragment.
\begin{verbatim}
void appExchangeCurrency(...) { 
  ...
  /*@ exsures (Exception) TRANS == 0; @*/ 
  { ...
  JCSystem.beginTransaction();      
  try {balance.setValue(decimal2); ...}
  catch (DecimalException e) {
    ISOException.throwIt(PurseApplet.DECIMAL_OVERFLOW); }
  JCSystem.commitTransaction();
  } ... }
\end{verbatim}
The method \texttt{setValue} that is called can actually throw a
decimal exception, which would lead to throwing an ISO exception, and
the transaction would not be committed. This clearly violates the
security policy as described in
Section~\ref{SecHighLevelSecProp}. After propagating the
core-annotations, and computing the appropriate proof obligations,
this violation is found automatically, without any problems.

