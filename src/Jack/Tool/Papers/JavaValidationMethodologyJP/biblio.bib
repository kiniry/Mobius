
@inproceedings{CK04:cassis,
  author =       "D. R. Cok and J. R. Kiniry",
  title =        "{ESC\slash Java2}: Uniting {ESC\slash Java} and {JML}
                 --- Progress and Issues in Building and Using
                 {ESC\slash Java2}, Including a Case Study Involving the
                 Use of the Tool to Verify Portions of an {Internet}
                 Voting Tally System",
  volume =       "3362",
  pages =        "108--128",
  year =         "2005",
  booktitle={Proceedings of {CASSIS}'04},
series="Lecture Notes in Computer Science",
publisher="Springer-Verlag",
editor={G. Barthe and L. Burdy and M. Huisman and J.-L. Lanet and T. Muntean}
}

@inproceedings{BP06:sac,
title={Annotation Carrying Code},
author={L. Burdy and M. Pavlova},
booktitle={Proceedings of SAC'06},
year={2006},
publisher="ACM Press"}

@inproceedings{gta05:fast,
  author = {G. Barthe and T.Rezk and A. Saabas},  
  title = {{Proof obligations preserving compilation}},
  year = 	 {2005},
  booktitle="Proceedings of FAST'05",
  OPTeditor="T.~Dimitrakos and F.~Martinelli and P.~Ryan and S.~Schneider",
series="Lecture Notes in Computer Science",
volume={3866},
pages="112-126",
  publisher="Springer-Verlag"}

@inproceedings{Rousset,
author=" C. March\'e and N. Rousset",
title="Verification of JavaCard Applets Behaviour with respect to Transactions and Card Tears",
booktitle="Proceedings of SEFM'06",
year="2006"}

@INPROCEEDINGS{Bershad1994,
  author = {Bershad, Brian N. and Chambers, Craig and Eggers, Susan J. and Maeda,
	Chris and McNamee, Dylan and Pardyak, Przemyslaw and Savage, Stefan
	and Sirer, Emin Gunyoer},
  title = {{SPIN} - An Extensible Microkernel for Application-specific Operating
	System Services},
  booktitle = {{ACM} {SIGOPS} European Workshop},
  year = {1994},
  pages = {68-71},
  crossref = {s},
  keywords = {spin, operating systems},
  lang = {en},
  url = {citeseer.ist.psu.edu/bershad94spin.html},
}

@ARTICLE{Anton2002,
  author = {Ertl, M. Anton and Gregg, David and Krall, Andreas and Paysan, Bernd},
  title = {Vmgen: a generator of efficient virtual machine interpreters},
  journal = {Softw. Pract. Exper.},
  year = {2002},
  volume = {32},
  pages = {265--294},
  number = {3},
  abstract = {In a virtual machine interpreter, the code for each virtual machine
	instruction has similarities to code for other instructions. We present
	an interpreter generator that takes simple virtual machine instruction
	descriptions as input and generates C code for processing the instructions
	in several ways: execution, virtual machine code generation, disassembly,
	tracing, and profiling. The generator is designed to support efficient
	interpreters: it supports threaded code, caching the top-of-stack
	item in a register, combining simple instructions into superinstructions,
	and other optimizations. We have used the generator to create interpreters
	for Forth and Java. The resulting interpreters are faster than other
	interpreters for the same languages and they are typically 2-10 times
	slower than code produced by native-code compilers. We also present
	results for the effects of the individual optimizations supported
	by the generator.},
  crossref = {@ARTICLE{Mulchandani1998, author = {Deepak Mulchandani}, title =
	{Java for embedded systems}, journal = {Internet Computing, IEEE},
	year = {1998}, volume = {2}, number = {3}, pages = {30 - 39}, lang
	= {en}, keywords = {java, embedded systems}, abstract = {Java requires
	infrastructure to run on embedded devices. This requirement must
	be traded against the powerful support for dynamic behavior that
	it offers embedded system developers.}, pdf = {Mulchandani1998.pdf},
	url = {http://ieeexplore.ieee.org:80/xpls/abs_all.jsp?isNumber=15040\&arNumber=683797\&isnumber=15040\&arnumber=683797},
	} @INPROCEEDINGS{Lestideau2002, author = {Vincent Lestideau and Noureddine
	Belkhatir and Pierre-Yves Cunin}, title = {Towards Automated Software
	Component Configuration and Deployment}, booktitle = {8th International
	Conference on Information Systems Analysis and Synthesis}, year =
	{2002}, abstract = {Software deployment is a complex process that
	covers post development activities as configuring, releasing, installing,
	updating, adapting until uninstalling a software application. The
	existing tools do not cover all this process and they are ad hoc.
	This paper presents and describes some ideas to create a deployment
	environment. The aim of this environment is to ensure a coherent
	and secure installation. We propose an approach using the federation
	technology.}, pdf = {Lestideau2002.pdf}, url = {citeseer.ist.psu.edu/lestideau02towards.html},
	} @INPROCEEDINGS{Lagosanto2002, author = {Lagosanto, Laurent}, title
	= {Next-generation embedded Java operating system for smart cards},
	booktitle = {4th Gemplus Developer Conference}, year = {2002}, lang
	= {en}, pdf = {Lagosanto2002.pdf}, keywords = {java, smart card,
	embedded systems}, url = {http://www.gemplus.com/smart/r_d/publications/pdf/Lag02gdc.pdf},
	} @INPROCEEDINGS{Hall1999, author = {Richard S. Hall and Dennis Heimbigner
	and Alexander L. Wolf}, title = {A Cooperative Approach to Support
	Software Deployment Using the Software Dock}, booktitle = {International
	Conference on Software Engineering}, year = {1999}, pages = {174-183},
	url = {http://citeseer.ist.psu.edu/hall99cooperative.html}, } @INPROCEEDINGS{Grimaud2003,
	author = {G. Grimaud and J.-J. Vandewalle}, title = {Introducing
	Research Issues for Next Generation {J}ava-based Smart Card Platforms},
	booktitle = {Proc. Smart Objects Conference (sOc'2003)}, year = {2003},
	address = {Grenoble, France}, keywords = {java, smart card}, pdf
	= {Grimaud2003.pdf}, url = {http://www.lifl.fr/RD2P/Papers/rd2p.bib/grimaud-soc-03},
	language = {en}, } @BOOK{embedded-dictionary, title = {Embedded Systems
	Dictionary}, publisher = {{CMPBooks}}, year = {2003}, author = {J.
	Ganssle and M. Barr}, keywords = {embedded systems}, isbn = {1-57820-120-9},
	} @INPROCEEDINGS{Coupaye2000, author = {Thierry Coupaye and Jacky
	Estublier}, title = {Foundations of Enterprise Software Deployment},
	booktitle = {{CSMR}}, year = {2000}, pages = {65-74}, keywords =
	{deployment}, url = {http://citeseer.ist.psu.edu/564597.html}, }
	@TECHREPORT{Carzaniga1998, author = {A. Carzaniga and A. Fuggetta
	and R. S. Hall and A. van der Hoek and D. Heimbigner and A. L. Wolf.},
	title = {A Characterization Framework for Software Deployment Technologies},
	institution = {Dept. of Computer Science, University of Colorado},
	year = {1998}, number = {CU-CS-857-98}, month = {April}, pdf = {Carzaniga1998.pdf},
	keywords = {deployment}, url = {http://citeseer.ist.psu.edu/carzaniga98characterization.html},
	} @ARTICLE{Bothner2003, author = {Per Bothner}, title = {Compiling
	Java with GCJ}, journal = {Linux J.}, year = {2003}, volume = {2003},
	number = {105}, pages = {4}, issn = {1075-3583}, keywords = {java,
	compiler}, url = {http://portal.acm.org/citation.cfm?id=603775\&coll=Portal\&dl=ACM\&CFID=29272944\&CFTOKEN=84887953},
	publisher = {Specialized Systems Consultants, Inc.}, } @ARTICLE{Mulchandani1998,
	author = {Deepak Mulchandani}, title = {Java for embedded systems},
	journal = {Internet Computing, IEEE}, year = {1998}, volume = {2},
	number = {3}, pages = {30 - 39}, lang = {en}, keywords = {java, embedded
	systems}, abstract = {Java requires infrastructure to run on embedded
	devices. This requirement must be traded against the powerful support
	for dynamic behavior that it offers embedded system developers.},
	pdf = {Mulchandani1998.pdf}, url = {http://ieeexplore.ieee.org:80/xpls/abs_all.jsp?isNumber=15040\&arNumber=683797\&isnumber=15040\&arnumber=683797},
	} @INPROCEEDINGS{Lestideau2002, author = {Vincent Lestideau and Noureddine
	Belkhatir and Pierre-Yves Cunin}, title = {Towards Automated Software
	Component Configuration and Deployment}, booktitle = {8th International
	Conference on Information Systems Analysis and Synthesis}, year =
	{2002}, abstract = {Software deployment is a complex process that
	covers post development activities as configuring, releasing, installing,
	updating, adapting until uninstalling a software application. The
	existing tools do not cover all this process and they are ad hoc.
	This paper presents and describes some ideas to create a deployment
	environment. The aim of this environment is to ensure a coherent
	and secure installation. We propose an approach using the federation
	technology.}, pdf = {Lestideau2002.pdf}, url = {citeseer.ist.psu.edu/lestideau02towards.html},
	} @INPROCEEDINGS{Lagosanto2002, author = {Lagosanto, Laurent}, title
	= {Next-generation embedded Java operating system for smart cards},
	booktitle = {4th Gemplus Developer Conference}, year = {2002}, lang
	= {en}, pdf = {Lagosanto2002.pdf}, keywords = {java, smart card,
	embedded systems}, url = {http://www.gemplus.com/smart/r_d/publications/pdf/Lag02gdc.pdf},
	} @INPROCEEDINGS{Hall1999, author = {Richard S. Hall and Dennis Heimbigner
	and Alexander L. Wolf}, title = {A Cooperative Approach to Support
	Software Deployment Using the Software Dock}, booktitle = {International
	Conference on Software Engineering}, year = {1999}, pages = {174-183},
	url = {http://citeseer.ist.psu.edu/hall99cooperative.html}, } @INPROCEEDINGS{Grimaud2003,
	author = {G. Grimaud and J.-J. Vandewalle}, title = {Introducing
	Research Issues for Next Generation {J}ava-based Smart Card Platforms},
	booktitle = {Proc. Smart Objects Conference (sOc'2003)}, year = {2003},
	address = {Grenoble, France}, keywords = {java, smart card}, pdf
	= {Grimaud2003.pdf}, url = {http://www.lifl.fr/RD2P/Papers/rd2p.bib/grimaud-soc-03},
	language = {en}, } @BOOK{embedded-dictionary, title = {Embedded Systems
	Dictionary}, publisher = {{CMPBooks}}, year = {2003}, author = {J.
	Ganssle and M. Barr}, keywords = {embedded systems}, isbn = {1-57820-120-9},
	} @INPROCEEDINGS{Coupaye2000, author = {Thierry Coupaye and Jacky
	Estublier}, title = {Foundations of Enterprise Software Deployment},
	booktitle = {{CSMR}}, year = {2000}, pages = {65-74}, keywords =
	{deployment}, url = {http://citeseer.ist.psu.edu/564597.html}, }
	@TECHREPORT{Carzaniga1998, author = {A. Carzaniga and A. Fuggetta
	and R. S. Hall and A. van der Hoek and D. Heimbigner and A. L. Wolf.},
	title = {A Characterization Framework for Software Deployment Technologies},
	institution = {Dept. of Computer Science, University of Colorado},
	year = {1998}, number = {CU-CS-857-98}, month = {April}, pdf = {Carzaniga1998.pdf},
	keywords = {deployment}, url = {http://citeseer.ist.psu.edu/carzaniga98characterization.html},
	} @ARTICLE{Bothner2003, author = {Per Bothner}, title = {Compiling
	Java with GCJ}, journal = {Linux J.}, year = {2003}, volume = {2003},
	number = {105}, pages = {4}, issn = {1075-3583}, keywords = {java,
	compiler}, url = {http://portal.acm.org/citation.cfm?id=603775\&coll=Portal\&dl=ACM\&CFID=29272944\&CFTOKEN=84887953},
	publisher = {Specialized Systems Consultants, Inc.}, } @ARTICLE{Mulchandani1998,
	author = {Deepak Mulchandani}, title = {Java for embedded systems},
	journal = {Internet Computing, IEEE}, year = {1998}, volume = {2},
	number = {3}, pages = {30 - 39}, lang = {en}, keywords = {java, embedded
	systems}, abstract = {Java requires infrastructure to run on embedded
	devices. This requirement must be traded against the powerful support
	for dynamic behavior that it offers embedded system developers.},
	pdf = {Mulchandani1998.pdf}, url = {http://ieeexplore.ieee.org:80/xpls/abs_all.jsp?isNumber=15040\&arNumber=683797\&isnumber=15040\&arnumber=683797},
	} @INPROCEEDINGS{Lestideau2002, author = {Vincent Lestideau and Noureddine
	Belkhatir and Pierre-Yves Cunin}, title = {Towards Automated Software
	Component Configuration and Deployment}, booktitle = {8th International
	Conference on Information Systems Analysis and Synthesis}, year =
	{2002}, abstract = {Software deployment is a complex process that
	covers post development activities as configuring, releasing, installing,
	updating, adapting until uninstalling a software application. The
	existing tools do not cover all this process and they are ad hoc.
	This paper presents and describes some ideas to create a deployment
	environment. The aim of this environment is to ensure a coherent
	and secure installation. We propose an approach using the federation
	technology.}, pdf = {Lestideau2002.pdf}, url = {citeseer.ist.psu.edu/lestideau02towards.html},
	} @INPROCEEDINGS{Lagosanto2002, author = {Lagosanto, Laurent}, title
	= {Next-generation embedded Java operating system for smart cards},
	booktitle = {4th Gemplus Developer Conference}, year = {2002}, lang
	= {en}, pdf = {Lagosanto2002.pdf}, keywords = {java, smart card,
	embedded systems}, url = {http://www.gemplus.com/smart/r_d/publications/pdf/Lag02gdc.pdf},
	} @INPROCEEDINGS{Hall1999, author = {Richard S. Hall and Dennis Heimbigner
	and Alexander L. Wolf}, title = {A Cooperative Approach to Support
	Software Deployment Using the Software Dock}, booktitle = {International
	Conference on Software Engineering}, year = {1999}, pages = {174-183},
	url = {http://citeseer.ist.psu.edu/hall99cooperative.html}, } @INPROCEEDINGS{Grimaud2003,
	author = {G. Grimaud and J.-J. Vandewalle}, title = {Introducing
	Research Issues for Next Generation {J}ava-based Smart Card Platforms},
	booktitle = {Proc. Smart Objects Conference (sOc'2003)}, year = {2003},
	address = {Grenoble, France}, keywords = {java, smart card}, pdf
	= {Grimaud2003.pdf}, url = {http://www.lifl.fr/RD2P/Papers/rd2p.bib/grimaud-soc-03},
	language = {en}, } @BOOK{embedded-dictionary, title = {Embedded Systems
	Dictionary}, publisher = {{CMPBooks}}, year = {2003}, author = {J.
	Ganssle and M. Barr}, keywords = {embedded systems}, isbn = {1-57820-120-9},
	} @INPROCEEDINGS{Coupaye2000, author = {Thierry Coupaye and Jacky
	Estublier}, title = {Foundations of Enterprise Software Deployment},
	booktitle = {{CSMR}}, year = {2000}, pages = {65-74}, keywords =
	{deployment}, url = {http://citeseer.ist.psu.edu/564597.html}, }
	@TECHREPORT{Carzaniga1998, author = {A. Carzaniga and A. Fuggetta
	and R. S. Hall and A. van der Hoek and D. Heimbigner and A. L. Wolf.},
	title = {A Characterization Framework for Software Deployment Technologies},
	institution = {Dept. of Computer Science, University of Colorado},
	year = {1998}, number = {CU-CS-857-98}, month = {April}, pdf = {Carzaniga1998.pdf},
	keywords = {deployment}, url = {http://citeseer.ist.psu.edu/carzaniga98characterization.html},
	} @ARTICLE{Bothner2003, author = {Per Bothner}, title = {Compiling
	Java with GCJ}, journal = {Linux J.}, year = {2003}, volume = {2003},
	number = {105}, pages = {4}, issn = {1075-3583}, keywords = {java,
	compiler}, url = {http://portal.acm.org/citation.cfm?id=603775\&coll=Portal\&dl=ACM\&CFID=29272944\&CFTOKEN=84887953},
	publisher = {Specialized Systems Consultants, Inc.}, }},
  doi = {http://dx.doi.org/10.1002/spe.434},
  issn = {0038-0644},
  keywords = {java, virtual machine},
  lang = {en},
  pdf = {Anton2002.pdf},
  publisher = {John Wiley \& Sons, Inc.},
  url = {http://portal.acm.org/citation.cfm?id=776238},
}

@INPROCEEDINGS{Adl-Tabatabai1998,
  author = {Ali-Reza Adl-Tabatabai and Micha\&\#322; Cierniak and Guei-Yuan Lueh
	and Vishesh M. Parikh and James M. Stichnoth},
  title = {Fast, effective code generation in a just-in-time Java compiler},
  booktitle = {PLDI '98: Proceedings of the ACM SIGPLAN 1998 conference on Programming
	language design and implementation},
  year = {1998},
  pages = {280--290},
  address = {New York, NY, USA},
  publisher = {ACM Press},
  doi = {http://doi.acm.org/10.1145/277650.277740},
  isbn = {0-89791-987-4},
  location = {Montreal, Quebec, Canada},
  pdf = {Adl-Tabatabai1998.pdf},
  url = {http://portal.acm.org/citation.cfm?id=277740},
}

@INPROCEEDINGS{Azevedo1999,
  author = {Ana Azevedo and Alex Nicolau and Joe Hummel},
  title = {Java annotation-aware just-in-time (AJIT) complilation system},
  booktitle = {JAVA '99: Proceedings of the ACM 1999 conference on Java Grande},
  year = {1999},
  pages = {142--151},
  address = {New York, NY, USA},
  publisher = {ACM Press},
  doi = {http://doi.acm.org/10.1145/304065.304115},
  isbn = {1-58113-161-5},
  location = {San Francisco, California, United States},
  pdf = {Azevedo1999.pdf},
  url = {http://portal.acm.org/citation.cfm?id=304115},
}

@BOOK{M97oos,
  title = {Object-Oriented Software Construction},
  publisher = {Prentice Hall},
  year = {1997},
  author = {B.Meyer},
  edition = {2 revised},
}

@MASTERSTHESIS{Bizzotto2002a,
  author = {Gabriel Bizzotto},
  title = {JITS: Java In The Small},
  school = {Universit�de Lille 1},
  year = {2002},
  keywords = {jits,java},
  lang = {fr},
  pdf = {Bizzotto2002a.pdf},
  pubdate = {20020610},
  url = {http://www.lifl.fr/RD2P/JITS/Publications?action=bibentry&bibfile=jits.bib&bibref=Bizzotto2002a},
}

@TECHREPORT{Bizzotto2001,
  author = {Gabriel Bizzotto},
  title = {Vers un bytecode JavaCard plus compact et plus rapide},
  institution = {LIFL},
  year = {2001},
  month = {June},
  keywords = {jits,java},
  lang = {fr},
  pdf = {Bizzotto2001.pdf},
  pubdate = {20010601},
  url = {http://www.lifl.fr/RD2P/JITS/Publications?action=bibentry&bibfile=jits.bib&bibref=Bizzotto2001},
}

@INPROCEEDINGS{Bizzotto2002,
  author = {Gabriel Bizzotto and Gilles Grimaud},
  title = {Practical JavaCard Bytecode Compression},
  booktitle = {RENPAR14/ASF/SYMPA},
  year = {2002},
  address = {Hammamet (Tunisia)},
  month = {April},
  abstract = {Our work concerns bytecode compression on an embedded, tiny and safe
	environment, and more specifically JAVA CARDS. [2] and [4] propose
	a way to compress java card bytecode into a format executable in
	an ultra light embedded system, using macro-packing. Our implementation,
	improved with new specifical algorithms, allows a better compress
	rate (up to 32%). In a smart card having 32kB EEPROM, up to 10kB
	can be freed, it is enough to store some applets. The execution of
	macro-packed programs is very simple and the code overhead in the
	operating system and in the virtual machine is very small. Unfortunately,
	the compression process is not feasible in a tiny embedded system.
	We propose a distribution of the compression process called Compression-Carrying
	Code or simply CCC. This distribution maintains the Java Card 2.11
	compatibility [11], and allows a trusted, just-in-time compression
	by the embedded bytecode loader.},
  keywords = {jits, java},
  lang = {en},
  pdf = {Bizzotto2002.pdf},
  pubdate = {20020410},
  url = {http://www.lifl.fr/RD2P/JITS/Publications?action=bibentry&bibfile=jits.bib&bibref=Bizzotto2002},
}

@ARTICLE{Bothner2003,
  author = {Per Bothner},
  title = {Compiling Java with GCJ},
  journal = {Linux J.},
  year = {2003},
  volume = {2003},
  pages = {4},
  number = {105},
  issn = {1075-3583},
  keywords = {java, compiler},
  publisher = {Specialized Systems Consultants, Inc.},
  url = {http://portal.acm.org/citation.cfm?id=603775&coll=Portal&dl=ACM&CFID=29272944&CFTOKEN=84887953},
}

@TECHREPORT{Burgaard2000,
  author = {Burgaard, Kim and Erichsen, J{\o}rgen Bang},
  title = {Virtual Machines for Limited Devices},
  institution = {Faculty of Sciences, University of Aarhus},
  year = {2000},
  keywords = {java, virtual machine},
  lang = {en},
  pdf = {Burgaard2000.pdf},
  url = {http://citeseer.ist.psu.edu/burgaard00virtual.html},
}

@MISC{Campbell1996,
  author = {R. Campbell and J. Coomes and A. Dave and N. Islam and Y. Li and
	W. Liao and S. Lim and T. Qian and D. Raila and E. Roush and A. Sane
	and M. Sefika and A. Singhai and S. Tan},
  title = {Customizable Object-Oriented Operating Systems},
  year = {1996},
  keywords = {choices, operating systems},
  lang = {en},
  pdf = {Campbell1996.pdf},
  text = {Roy H. Campbell, J. W. Coomes, Amitabh Dave, Nayeem Islam, Y. Li,
	Willy S. Liao, Swee Lim, Tin Qian, Dave K. Raila, Ellard Roush, Aamod
	Sane, Mohlalefi Sefika, Ashish Singhai, and S. T. Tan. Customizable
	Object-Oriented Operating Systems. Submitted for publication. Available
	at http://choices.cs.uiuc.edu, 1996.},
  url = {http://citeseer.ist.psu.edu/campbell96customizable.html},
}

@INPROCEEDINGS{Campbell1995,
  author = {R. H. Campbell and See-Mong Tan},
  title = {/spl mu/Choices: an object-oriented multimedia operating system},
  booktitle = {Proceedings of the Fifth Workshop on Hot Topics in Operating Systems
	(HotOS-V)},
  year = {1995},
  pages = {90},
  publisher = {IEEE Computer Society},
  abstract = {The paper describes the design of the /spl mu/Choices object-oriented
	multimedia operating system. /spl mu/Choices provides an architecture
	for interconnecting different OS subsystems, with these subsystems
	realized as separate modules. The modules are implemented as independent
	object-oriented frameworks. Frameworks interact through exported
	abstract interfaces. The sub-classing of components within frameworks
	enables application and media-specific customization. /spl mu/Choices
	also provides a unified scheme for memory handling and passing across,
	as well as between, all OS subsystems. This allows buffer transfers
	and manipulation within and between operating system modules without
	copying, while allowing subsystems to specialize their views of memory
	buffers for efficient handling of problem-specific behavior. Interpreted
	agents may be embedded in the kernel that can control system level
	processing of multimedia streams without interference, eliminating
	excessive system call overhead. Operating system support for authentication,
	encryption, and delegation is transparently provided via an extensible
	framework that customizes interfaces to operating system resources.
	A new networking subsystem based on an asynchronous transfer mode
	network environment allows quality of service guarantees within the
	network protocol stack. These features are combined in /spl mu/Choices
	to give an environment that supports high bandwidth multimedia streams.},
  isbn = {0-8186-7081-9},
  keywords = {choices, operating systems},
  lang = {en},
  url = {http://portal.acm.org/citation.cfm?id=822403},
}

@ARTICLE{Campbell1993,
  author = {Roy H. Campbell and Nayeem Islam and David Raila and Peter Madany},
  title = {Designing and implementing Choices: an object-oriented system in
	C++},
  journal = {Commun. ACM},
  year = {1993},
  volume = {36},
  pages = {117--126},
  number = {9},
  doi = {http://doi.acm.org/10.1145/162685.162717},
  issn = {0001-0782},
  keywords = {choices, operating systems},
  lang = {en},
  pdf = {Campbell1993.pdf},
  publisher = {ACM Press},
  url = {http://portal.acm.org/citation.cfm?id=162717&coll=Portal&dl=GUIDE&CFID=24454099&CFTOKEN=86599911#},
}

@TECHREPORT{Carzaniga1998,
  author = {A. Carzaniga and A. Fuggetta and R. S. Hall and A. van der Hoek and
	D. Heimbigner and A. L. Wolf.},
  title = {A Characterization Framework for Software Deployment Technologies},
  institution = {Dept. of Computer Science, University of Colorado},
  year = {1998},
  number = {CU-CS-857-98},
  month = {April},
  keywords = {deployment},
  pdf = {Carzaniga1998.pdf},
  url = {http://citeseer.ist.psu.edu/carzaniga98characterization.html},
}

@INPROCEEDINGS{Cazzola2000,
  author = {Cazzola, Walter and Chiba, Shigeru and Ledoux, Thomas},
  title = {Reflection and {Meta-Level Architectures}~: State of the Art and
	Future Trends},
  booktitle = {Object-Oriented Technology ({ECOOP} 2000 Workshop Reader)},
  year = {2000},
  editor = {Jacques Malenfant and Sabine Moisan and Ana M. D. Moreira},
  volume = {1964},
  series = {Lecture Notes in Computer Science},
  pages = {1--15},
  publisher = {Springer-Verlag},
  abstract = {Previous workshops on reflection both in ECOOP and in OOPSLA have
	pointed out the growing interest and importance of Reflection and
	Metalevel Architectures in the fields of programming languages and
	systems (ECOOP'98, OOPSLA'98), software engineering (OOPSLA'99) and
	middleware (Middleware 2000). Following these workshops but also
	the conference Reflection'99 held in SaintMalo (France), this workshop
	has provided an opportunity for researchers with a broad range of
	interests in meta-level architectures and reflective techniques to
	discuss recent developments in this field. It has also provided a
	good test-bed for preparing them to submit their works to Reflection'01.
	The workshop main goal is to encourage people to present works in
	progress. These works could cover all the spectrum from theory to
	practice. To ensure creativity, originality, and audience interests,
	participants have been selected by the workshop organizers on the
	basis of 5-page position paper. We hope that the workshop will help
	them to mature their ideas and improve the quality of their future
	publications based on the presented work.},
  keywords = {java, code specialization},
  kind = {CDL},
  lang = {en},
  pdf = {Cazzola2000.pdf},
  url = {http://www.emn.fr/x-info/obasco/bibliography/details/cazzola-chiba-ledoux_rmla-ecoop2000.html},
}

@ARTICLE{Chang2001,
  author = {Da-Wei Chang and Ruei-Chuan Chang},
  title = {EJVM: an economic Java run-time environment for embedded devices},
  journal = {Software Practice \& Experience},
  year = {2001},
  volume = {31},
  pages = {129--146},
  number = {2},
  abstract = {As network-enabled embedded devices and Java grow in their popularity,
	embedded system researchers start seeking ways to make these devices
	Java-enabled. However, it is a challenge to apply Java technology
	to these devices due to their shortage of resources. In this paper,
	we propose EJVM (Economic Java Virtual Machine), an economic way
	to run Java programs on network-enabled and resource-limited embedded
	devices. Espousing the architecture proposed by distributed JVM,
	we store all Java codes on the server to reduce the storage needs
	of the client devices. In addition, we use two novel techniques to
	reduce the client-side memory footprints: server-side class representation
	conversion and on-demand bytecode loading. Finally, we maintain client-side
	caches and provide performance evaluation on different caching policies.
	We implement EJVM by modifying a freely available JVM implementation,
	Kaffe. From the experiment results, we show that EJVM can reduce
	Java heap requirements by about 20-50% and achieve 90% of the original
	performance. Copyright  2001 John Wiley & Sons, Ltd.},
  address = {New York, NY, USA},
  doi = {http://dx.doi.org/10.1002/1097-024X(200102)31:2<129::AID-SPE359>3.0.CO;2-1},
  issn = {0038-0644},
  pdf = {Chang2001.pdf},
  publisher = {John Wiley \& Sons, Inc.},
  url = {http://portal.acm.org/citation.cfm?id=372826.372830},
}

@BOOK{Chen2000,
  title = {Java Card Technology for Smart Cards: Architecture and Programmer's
	Guide},
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  year = {2000},
  author = {Zhiqun Chen},
  isbn = {0201703297},
  keywords = {java, java card},
  lang = {en},
  url = {http://portal.acm.org/citation.cfm?id=518247},
}

@ARTICLE{Cierniak2000,
  author = {Micha\&\#322; Cierniak and Guei-Yuan Lueh and James M. Stichnoth},
  title = {Practicing JUDO: Java under dynamic optimizations},
  journal = {SIGPLAN Not.},
  year = {2000},
  volume = {35},
  pages = {13--26},
  number = {5},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/358438.349306},
  issn = {0362-1340},
  pdf = {Cierniak2000.pdf},
  publisher = {ACM Press},
}

@INPROCEEDINGS{Clarke1999,
  author = {M. Clarke and G. Coulson},
  title = {Dynamic Memory Model Reconfiguration in DEIMOS},
  booktitle = {Proceedings of the 1 st French Conference on Operating Systems (CFSE'1),
	Rennes,},
  year = {1999},
  address = {Rennes, France},
  month = {June},
  abstract = {Operating system design has traditionally followed a philosophy in
	which the system is structured as a fixed set of abstractions and
	mechanisms. This approach, however, is now showing its limitations
	in the face of new application areas which demand extensibility and
	configurability. In this paper, we describe aspects of the design
	of a dynamically extensible operating system called DEIMOS. DEIMOS
	is unique in that it does not define a kernel entity. Instead, both
	traditional kernel abstractions and application specific services
	are encapsulated as `modules' which can be loaded, configured and
	unloaded on demand (i.e. at run time) by a base system component
	called the Configuration Manager (which can itself be unloaded).
	The lack of a kernel gives DEIMOS great scope for flexibility as
	applications have complete freedom to tailor their execution environment
	in accordance with their particular needs. Furthermore, applications
	can dynamically adapt their environment on an ongoing basis a...},
  keywords = {deimos, operating systems},
  lang = {en},
  pdf = {Clarke1999.pdf},
  url = {citeseer.ist.psu.edu/clarke99dynamic.html},
}

@INPROCEEDINGS{Clarke1998,
  author = {M. Clarke and G. Coulson},
  title = {An Architecture for Dynamically Extensible Operating Systems},
  booktitle = {Proceedings of the 4th International Conference on Configurable Distributed
	Systems},
  year = {1998},
  address = {Annapolis, Maryland, USA},
  abstract = {Operating system design has traditionally followed a philosophy in
	which the system is structured as a fixed set of abstractions and
	mechanisms. This approach, however, is now showing its limitations
	in the face of new application areas which demand extensibility and
	configurability. In this paper, we describe the design of a dynamically
	extensible operating system called DEIMOS. DEIMOS is unique in that
	it does not define a kernel entity. Instead, both traditional kernel
	functions and application specific services are encapsulated as modules
	which can be loaded, configured and unloaded on demand (i.e. at run
	time) by a base system component called the Configuration Manager
	(which can itself be unloaded). The lack of a kernel gives DEIMOS
	great scope for flexibility as applications have complete freedom
	to tailor their execution environment in accordance with their particular
	needs. Furthermore, applications can dynamically adapt their environment
	on an ongoing basis and the differing...},
  keywords = {deimos, operating systems},
  lang = {en},
  text = {Clarke, M. and Coulson, G. (1998) An Architecture for Dynamically
	Extensible Operating Systems. Proceedings of the 4th International
	Conference on Configurable Distributed Systems, Annapolis, Maryland,
	USA.},
  url = {citeseer.ist.psu.edu/clarke98architecture.html},
}

@ARTICLE{Clausen2000,
  author = {L. R. Clausen and U. P. Schultz and C. Consel and G. Muller},
  title = {Java bytecode compression for low-end embedded systems},
  journal = acmpls,
  year = {2000},
  volume = {22},
  pages = {471--489},
  number = {3},
  keywords = {java},
  pdf = {Clausen2000.pdf},
}

@INPROCEEDINGS{Consel1993,
  author = {Charles Consel and Olivier Danvy},
  title = {Tutorial notes on partial evaluation},
  booktitle = {Proceedings of the 20th ACM SIGPLAN-SIGACT symposium on Principles
	of programming languages},
  year = {1993},
  pages = {493--501},
  publisher = {ACM Press},
  abstract = {The last years have witnessed a flurry of new results in the area
	of partial evaluation. These tutorial notes survey the field and
	present a critical assessment of the state of the art.},
  doi = {http://doi.acm.org/10.1145/158511.158707},
  isbn = {0-89791-560-7},
  keywords = {partial interpretation, code specialization},
  lang = {en},
  location = {Charleston, South Carolina, United States},
  pdf = {Consel1993.pdf},
  url = {http://portal.acm.org/citation.cfm?id=158707},
}

@INPROCEEDINGS{Consel1996,
  author = {Charles Consel and Luke Hornof and Fran{\c c}ois No{\"e}l and Jacques
	Noy{\'e} and Nicolae Volansche},
  title = {A Uniform Approach for Compile-Time and Run-Time Specialization},
  booktitle = {Selected Papers from the Internaltional Seminar on Partial Evaluation},
  year = {1996},
  pages = {54--72},
  address = {London, UK},
  publisher = {Springer-Verlag},
  isbn = {3-540-61580-6},
  keywords = {partial evaluation},
  pdf = {Consel1996.pdf},
  url = {http://portal.acm.org/citation.cfm?id=724058&coll=Portal&dl=GUIDE&CFID=43947250&CFTOKEN=97358474#},
}

@INPROCEEDINGS{Consel1993a,
  author = {Charles Consel and Calton Pu and Jonathan Walpole},
  title = {Incremental Partial Evaluation: The Key to High Performance, Modularity,
	and Portability in Operating Systems},
  booktitle = {Proceedings of the 1993 Conference on Partial Evaluation and Program
	Manipulation},
  year = {1993},
  keywords = {partial interpretation, code specialization},
  lang = {en},
  pdf = {Consel1993a.pdf},
  url = {http://www.cse.ogi.edu/DISC/projects/synthetix/publications.html},
}

@INPROCEEDINGS{Coupaye2000,
  author = {Thierry Coupaye and Jacky Estublier},
  title = {Foundations of Enterprise Software Deployment},
  booktitle = {{CSMR}},
  year = {2000},
  pages = {65-74},
  keywords = {deployment},
  url = {http://citeseer.ist.psu.edu/564597.html},
}

@TECHREPORT{Courbot2005,
  author = {Alexandre Courbot and Gilles Grimaud and Jean-Jacques Vandewalle},
  title = {Romization: Early Deployment and Customization of Java Systems for
	Restrained Devices},
  institution = {INRIA Futurs},
  year = {2005},
  number = {{RR-5629}},
  address = {Lille, France},
  month = {July},
  abstract = {Memory is the scarcest ressource of embedded and restrained devices.
	This paper studies the memory footprint benefit of pre-deploying
	embedded Java systems up to their activation. We find out that the
	more the system is deployed off-board, the more it can be efficiently
	and automatically customized in order to reduce its final size. This
	claim is validated experimentally through the production of memory
	images that are between 10% and 45% the size of their J2ME CLDC counterparts,
	while using the J2SE API and being ready-to-run without any further
	on-board initialization. Embedded solutions like J2ME degrade the
	Java environment and API right fromtheir specification, limiting
	their usage perspectives. By contrast, our romization scheme generates
	and specializes a custom-tailored Java system and API for embedded
	applications being deployed in a full-fledged J2SE environment.},
  keywords = {ROMIZATION, JAVA, EMBEDDED DEVICES, SYSTEM CUSTOMIZATION, PRE-DEPLOYMENT,
	VIRTUAL EXECUTION ENVIRONMENTS},
  pdf = {Courbot2005.pdf},
  url = {http://www.inria.fr/rrrt/rr-5629.html},
}

@INPROCEEDINGS{Courbot2005a,
  author = {Alexandre Courbot and Gilles Grimaud and Jean-Jacques Vandewalle
	and David Simplot},
  title = {Application-Driven Customization of an Embedded Java Virtual Machine},
  booktitle = {proceedings of the Second International Symposium on Ubiquitous Intelligence
	and Smart Worlds (UISW2005)},
  year = {2005},
  address = {Nagasaki, Japan},
  month = {December},
  note = {To appear},
  abstract = {Java for embedded devices is today synonym of "embeddable pseudo-Java".
	In order to limit their memory footprint, the embedded flavors of
	Java introduce incompatibilities against the standard edition, and
	break Java's portability rule. The application developer has to comply
	to specific Java APIs and incomplete runtime features. In this paper,
	we introduce a way to embed applications written for Java 2 Standard
	Edition. The applications are pre-deployed into a virtual Java execution
	environment, which is analyzed so that the Java virtual machine can
	be tailored according to the runtime needs of the system. Thus, the
	programmer is not enforced to comply to a particular Java environment;
	but conversely, the Java environment is customized according to its
	applications and targeted device. Experiments reveal that the customized
	virtual machines are comparable in size to existing static embedded
	Java solutions, while being more flexible and preserving Java compatibility.},
  keywords = {romization, Java virtual machine, embedded devices, system customization},
}

@ARTICLE{Cousot1996,
  author = {Patrick Cousot},
  title = {Abstract interpretation},
  journal = {ACM Comput. Surv.},
  year = {1996},
  volume = {28},
  pages = {324--328},
  number = {2},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/234528.234740},
  issn = {0360-0300},
  pdf = {Cousot1996.pdf},
  publisher = {ACM Press},
}

@INPROCEEDINGS{Cowan1996,
  author = {Cowan, C. and Autrey, T. and Krasic, C. and Pu, C. and Walpole, J.},
  title = {Fast concurrent dynamic linking for an adaptive operating system},
  booktitle = {Proceedings of the 3rd International Conference on Configurable Distributed
	Systems},
  year = {1996},
  pages = {108},
  publisher = {IEEE Computer Society},
  abstract = {The need for customizable and application-specific operating systems
	has been recognized for many years. A customizable operating system
	is one that can adapt to some particular circumstance to gain some
	functional or performance benefits. Microkernels have attempted to
	address this problem, but suffer performance degradation due to the
	cost of inter-process protection barriers. Commercial operating systems
	that can efficiently adapt themselves to changing circumstances have
	failed to appear, in part due to the difficulty of providing an interface
	that is efficient to invoke, provides a protection barrier, and can
	be dynamically reconfigured. Providing such a safe, efficient, and
	dynamic interface in a concurrent operating system requires an effective
	concurrency control mechanism to prevent conflicts between system
	components proposing to execute specialized components, and those
	components responsible for dynamically replacing specialized components.
	We outline our basic approach to specialization of operating systems,
	and detail our dynamic replacement mechanism and its concurrency
	control features.},
  isbn = {0-8186-7395-8},
  keywords = {synthetix, operating systems},
  lang = {en},
  pdf = {Cowan1996.pdf},
  url = {http://portal.acm.org/citation.cfm?id=851348&dl=ACM&coll=portal},
}

@INPROCEEDINGS{Dean1995,
  author = {Jeffrey Dean and David Grove and Craig Chambers},
  title = {Optimization of Object-Oriented Programs Using Static Class Hierarchy
	Analysis},
  booktitle = {ECOOP '95: Proceedings of the 9th European Conference on Object-Oriented
	Programming},
  year = {1995},
  pages = {77--101},
  address = {London, UK},
  publisher = {Springer-Verlag},
  isbn = {3-540-60160-0},
  keywords = {call graph},
  pdf = {Dean1995.pdf},
  url = {http://portal.acm.org/citation.cfm?id=679523},
}

@INPROCEEDINGS{Deleray2003,
  author = {Christophe Deleray and Nicolas Bedon and Gilles Roussel},
  title = {MyJVM: a 100% pure Java customizable Java Virtual Machine},
  booktitle = {Proceedings of the 2nd international conference on Principles and
	practice of programming in Java},
  year = {2003},
  pages = {177--179},
  publisher = {Computer Science Press, Inc.},
  abstract = {Numerous research works propose Java extensions. Most of these works
	try to solve a precise problem and offer ad-hoc solutions to achieve
	their goal: language extensions, preprocessors implementation, modifications
	of the compiler, of the bytecode or of the virtual machine behavior.
	Most of this changes could be implemented in a common framework by
	extending a Java Virtual Machine (JVM). Unfortunately, most JVM are
	not freely available or difficult to manage and/or to extend, and
	explicit use of their particular features implies a loss of portability.
	In this paper, we present an open Java Virtual Machine (100% pure
	Java) designed to be easily extensible (at compile-time and at run-time)
	by Java programmers.},
  isbn = {0-9544145-1-9},
  keywords = {java, virtual machine},
  lang = {#en#},
  location = {Kilkenny City, Ireland},
  pdf = {Deleray2003.pdf},
  url = {http://portal.acm.org/citation.cfm?id=957343},
}

@ARTICLE{Denys2002,
  author = {Denys, G. and Piessens, F. and Matthijs, F.},
  title = {A survey of customizability in operating systems research},
  journal = {ACM Comput. Surv.},
  year = {2002},
  volume = {34},
  pages = {450--468},
  number = {4},
  abstract = {An important goal of an operating system is to make computing and
	communication resources available in a fair and efficient way to
	the applications that will run on top of it. To achieve this result,
	the operating system implements a number of policies for allocating
	resources to, and sharing resources among applications, and it implements
	safety mechanisms to guard against misbehaving applications. However,
	for most of these allocation and sharing tasks, no single optimal
	policy exists. Different applications may prefer different operating
	system policies to achieve their goals in the best possible way.
	A customizable or adaptable operating system is an operating system
	that allows for flexible modification of important system policies.
	Over the past decade, a wide range of approaches for achieving customizability
	has been explored in the operating systems research community. In
	this survey, an overview of these approaches, structured around a
	taxonomy, is presented.},
  comment = {This paper gives a good and complete survey of customization in operating
	system research. It's main interest is to present a taxonomy of customizable
	operating systems to classify them according to two criterias: *
	The time of adaptation, before runtime (static) or during runtime
	(dynamic) * The initiator of the adaptation which can be a human,
	an application running on the system of the system itself. However
	the 6 categories are not equally surveyed: for static customizations,
	only human-driven ones are clearly identified with actual systems,
	which makes the taxonomy a little bit unbalanced.},
  doi = {http://doi.acm.org/10.1145/592642.592644},
  issn = {0360-0300},
  keywords = {survey, operating systems},
  lang = {en},
  pdf = {Denys2002.pdf},
  publisher = {ACM Press},
  url = {http://portal.acm.org/citation.cfm?id=592644&dl=ACM&coll=portal},
}

@MASTERSTHESIS{Deville2001,
  author = {Damien Deville},
  title = {D�eloppement d'un verifieur de bytecode JavaCard optimis�pour
	carte �microprocesseur},
  school = {Universit�de Lille 1},
  year = {2001},
  abstract = {Java est une plate-forme id�le pour r�liser des syst�es �code
	mobile. Elle assure la portabilit�et la mobilit�des applications
	sur diff�ents support d'ex�ution, tout en garantissant un fort
	niveau de s�urit� Les cartes �microprocesseur sont maintenant
	�uip�s de machine virtuelle Java. Les JavaCard sont un support
	d'ex�ution de code mobile. La provenance de ce code mobile n'est
	pas toujours connue, il convient donc pour la machine virtuelle de
	s'assurer de l'innocuit�de celui-ci. Dans l'architecture Java,
	c'est le v�ifieur de bytecode qui garantit l'int�rit�et la
	coh�ence de la machine virtuelle. Celui-ci n'est pas pr�ent dans
	les JavaCard en particulier en raison de sa complexit� Aussi, diff�entes
	solutions ont ���udi�s pour d�orter cette phase hors de
	la carte. Nous nous sommes propos�, dans ce document, d'int�rer
	enti�ement le v�i eur dans la carte. Cette op�ation est une
	garantie de l'autonomie de la carte, concernant sa propre s�urit�
	Pour cela nous avons abord�la r�lisation du v�ifieur sous un
	angle syst�e, c'est-�dire, en cherchant �maximiser l'usage
	qui peut �re fait des ressources mat�ielles propres aux cartes.},
  keywords = {jits,java},
  lang = {fr},
  pdf = {Deville2001.pdf},
  pubdate = {20010615},
  url = {http://www.lifl.fr/RD2P/JITS/Publications?action=bibentry&bibfile=jits.bib&bibref=Deville2001},
}

@INPROCEEDINGS{Deville2002,
  author = {Damien Deville and Gilles Grimaud},
  title = {Building an "impossible" verifier on a Java Card},
  booktitle = {Second Workshop on Industrial Experiences with Systems Software (WIESS'02)},
  year = {2002},
  address = {Boston (USA)},
  abstract = {Java is a popular development platform for mobile code systems. It
	ensures application portability and mobility for a variety of systems,
	while providing strong security features. The intermediate code (byte
	code) allows the virtual machine to verify statically (during the
	loading phase) that the program is well-behaved. This is done by
	a software security module called the byte code verifier. Smart Cards
	that provide a Java Virtual Machine, called Java Card, are not supplied
	with such a verifier because of its complexity. Alternatives are
	being studied to provide the same functionality outside the card.
	In the present paper, we propose to integrate the whole verifier
	inside the smart card. This ensures that the smart card becomes entirely
	autonomous, which allows full realization of smart cards potential
	as pervasive computing devices. Our verifier uses a specialized encoding
	and a software cache with a variety of cache polices to adapt to
	the hardware constraints of smart card. Our experimental results
	confirm the feasibility of such a security system being implemented
	in a smart card.},
  keywords = {jits,java},
  lang = {en},
  pdf = {Deville2002.pdf},
  pubdate = {20020810},
  url = {http://www.lifl.fr/RD2P/JITS/Publications?action=bibentry&bibfile=jits.bib&bibref=Deville2002},
}

@ARTICLE{Diwan2001,
  author = {Amer Diwan and Kathryn S. McKinley and J. Eliot B. Moss},
  title = {Using types to analyze and optimize object-oriented programs},
  journal = {ACM Trans. Program. Lang. Syst.},
  year = {2001},
  volume = {23},
  pages = {30--72},
  number = {1},
  doi = {http://doi.acm.org/10.1145/383721.383732},
  issn = {0164-0925},
  keywords = {code specialization},
  pdf = {Diwan2001.pdf},
  publisher = {ACM Press},
}

@INPROCEEDINGS{Engler1995a,
  author = {Dawson R. Engler and M. Frans Kaashoek and James O'Toole},
  title = {Exokernel: An Operating System Architecture for Application-Level
	Resource Management},
  booktitle = {Symposium on Operating Systems Principles},
  year = {1995},
  pages = {251-266},
  keywords = {exokernels, operating systems},
  lang = {en},
  pdf = {Engler1995a.pdf},
  url = {citeseer.ist.psu.edu/engler95exokernel.html},
}

@INPROCEEDINGS{Engler1995,
  author = {Dawson R. Engler and M. F. Kaashoeker},
  title = {Exterminate all operating system abstractions},
  booktitle = {Proceedings of the Fifth Workshop on Hot Topics in Operating Systems
	(HotOS-V)},
  year = {1995},
  pages = {78},
  publisher = {IEEE Computer Society},
  isbn = {0-8186-7081-9},
  keywords = {exokernels, operating systems},
  lang = {en},
  pdf = {Engler1995.pdf},
  url = {http://portal.acm.org/citation.cfm?id=822387&dl=ACM&coll=GUIDE},
}

@PHDTHESIS{Fassino2001,
  author = {Jean-Philippe Fassino},
  title = {{THINK} : vers une architecture de syst�es flexibles},
  school = {�ole Nationale Sup�ieure des T��ommunications},
  year = {2001},
  month = {December},
  keywords = {think, operating systems},
  lang = {fr},
  pdf = {Fassino2001.pdf},
  url = {http://sardes.inrialpes.fr/papers/phd.shtml},
}

@INPROCEEDINGS{Fassino2001a,
  author = {Jean-Philippe Fassino and Jean-Bernard Stefani},
  title = {Think : un noyau d'infrastructure r�artie adaptable},
  booktitle = {CFSE-02},
  year = {2001},
  comment = {English version: Fassino2002.},
  keywords = {think, operating systems},
  lang = {fr},
  pdf = {Fassino2001a.pdf},
  url = {http://www-src.lip6.fr/conferences/cfse2/actes.html},
}

@INPROCEEDINGS{Fassino2002,
  author = {Jean-Philippe Fassino and Jean-Bernard Stefani and Julia Lawall and
	Gilles Muller},
  title = {{THINK}: A Software Framework for Component-based Operating System
	Kernels},
  booktitle = {{USENIX'02}},
  year = {2002},
  pages = {73--86},
  address = {Monterey, CA, USA},
  organization = {{USENIX}},
  abstract = {Building a flexible kernel from components is a promising solution
	for supporting various embedded systems. The use of components encourages
	code re-use and reduces development time. Flexibility permits the
	system to be configured at various stages of the design, up to run
	time. In this paper, we propose a software framework, called THINK,
	for implementing operating system kernels from components of arbitrary
	sizes. A unique feature of THINK is that it provides a uniform and
	highly flexible binding model to help OS architects assemble operating
	system components in varied ways. An OS architect can build an OS
	kernel from components using THINK without being forced into a predefined
	kernel design (e.g. exo-kernel, micro-kernel or classical OS kernel).
	To evaluate the THINK framework, we have implemented KORTEX, a library
	of commonly used kernel components. We have used KORTEX to implement
	several kernels, including an L4-like micro-kernel, and kernels for
	an active network router, for the Kaffe Java virtual machine, and
	for a Doom game. Performance measurements show no degradation due
	to componentization and the systematic use of the binding framework,
	and that application-specific kernels can achieve speed-ups over
	standard general-purpose operating systems such as Linux.},
  comment = {French version: Fassino2001a.},
  keywords = {think, operating systems},
  lang = {en},
  pdf = {Fassino2002.pdf},
  url = {http://www.usenix.org/events/usenix02/fassino.html},
}

@INPROCEEDINGS{Ford1997,
  author = {Bryan Ford and Godmar Back and Greg Benson and Jay Lepreau and Albert
	Lin and Olin Shivers},
  title = {The Flux {OSKit}: A Substrate for Kernel and Language Research},
  booktitle = {Proceedings of the sixteenth ACM symposium on Operating systems principles},
  year = {1997},
  pages = {38--51},
  publisher = {ACM Press},
  abstract = {Implementing new operating systems is tedious, costly, and often impractical
	except for large projects. The Flux OSKit addresses this problem
	in a novel way by providing clean, well-documented OS components
	designed to be reused in a wide variety of other environments, rather
	than defining a new OS structure. The OSKit uses unconventional techniques
	to maximize its usefulness, such as intentionally exposing implementation
	details and platform-specific facilities. Further, the OSKit demonstrates
	a technique that allows unmodified code from existing mature operating
	systems to be incorporated quickly and updated regularly, by wrapping
	it with a small amount of carefully designed ``glue'' code to isolate
	its dependencies and export well-defined interfaces. The OSKit uses
	this technique to incorporate over 230,000 lines of stable code including
	device drivers, file systems, and network protocols. Our experience
	demonstrates that this approach to component software structure and
	reuse has a surprisingly large impact in the OS implementation domain.
	Four real-world examples show how the OSKit is catalyzing research
	and development in operating systems and programming languages.},
  comment = {OSKit is a framework and set of libraries that can easily be replaced
	or adapted to create a custom operating system. It greatly simplifies
	the process of building a new system from existing components, but
	customizations finer than just replacing a module with another must
	be hand-done, thus requiring from the person who deploys the system
	to exactly know what he wants to modify within the OS, to be fluent
	in the programming langage used to write the OS, and therefore to
	have general knowledge about operating systems. There is no automation
	in the customization process, but a well-designed framework to build
	operating systems variants. Moreover, the library modules are based
	on existing OS components taken from various places like the Linux
	kernel or FreeBSD, and a glue is needed to makes these components
	work together properly. Therefore it is hardly applicable to very
	small embedded systems.},
  doi = {http://doi.acm.org/10.1145/268998.266642},
  isbn = {0-89791-916-5},
  keywords = {oskit, operating systems},
  lang = {en},
  location = {Saint Malo, France},
  pdf = {Ford1997.pdf},
  url = {http://portal.acm.org/citation.cfm?id=266642&coll=Portal&dl=GUIDE&CFID=24454099&CFTOKEN=86599911#},
}

@ARTICLE{Friedrich2001,
  author = {Friedrich, L.F. and Stankovic, J. and Humphrey, M. and Marley, M.
	and Haskins, J., Jr.},
  title = {A survey of configurable, component-based operating systems for embedded
	applications},
  journal = {Micro, IEEE},
  year = {2001},
  volume = {21},
  pages = {54--68},
  number = {3},
  abstract = {Component-based software is becoming an increasingly popular technology
	as a means for creating complex software systems by assembling off-the-shelf
	building blocks. However, many of the component-based methodologies
	that use large components fail to address issues of size, real-time
	performance, power, and cost, as well as problems associated with
	the configuration process itself. These issues are critical for using
	components in embedded systems},
  comment = {This article makes a quite complete survey of component-based operating
	systems that are suitable for embedded devices. Most of the systems
	surveyed are unfortunately not suitable for ''very'' small embedded
	devices since they have a footprint of several hundreds of kilobytes.},
  keywords = {survey, operating systems},
  lang = {en},
  pdf = {Friedrich2001.pdf},
  url = {http://www.cs.virginia.edu/~ty4k/vestpage/},
}

@BOOK{Froehlich2001,
  title = {Application-Oriented Operating Systems},
  publisher = {GMD - Forschungszentrum Informationstechnik},
  year = {2001},
  author = {Ant�io Augusto Fr�lich},
  number = {17},
  series = {GMD Research Series},
  address = {Sankt Augustin},
  month = August,
  abstract = {The majority of processors produced nowadays are targeted at dedicated
	computing systems that execute either a single application or a small
	set of previously known applications. In contrast to generic computing
	systems, these dedicated systems have very speciffic run-time support
	requirements, which are not properly fulfilled by general-purpose
	operating systems. The impossibility to anticipate which applications
	will be executed results in generic operating systems being forced
	to provide an extensive set of services targeted at making all resources
	available to all applications. The standardization of such generic
	system services locked general-purpose operating system inside a
	hard shell that prevents innovations from reaching applications.
	With regard to dedicated computing, these generic operating system
	provide uncountable services that are not used by individual applications,
	and yet fail to fulfill application demands. This dissertation proposes
	a novel strategy to systematically construct application-oriented
	operating systems as arrangements of adaptable software components.
	Instead of standard compliance and hardware properties, the features
	offered by such a system emanate directly from application requirements,
	thus enabling it to be customized according to the needs of particular
	applications. Such application-tailored system instances are produced
	by selecting, configuring, and composing proper components. Even
	if applications refrain from the new application-oriented services
	in benefit of standard interfaces, most dedicated applications require
	such a small subset of those interfaces that mapping them to new
	system services-instead of porting their traditional implementations-is
	usually possible. The Application-Oriented System Design multiparadigm
	design method proposed in this dissertation guides domain decomposition
	towards families of scenarioindependent system abstractions that
	can be reused to build a variety of run-time support systems. Environmental
	dependencies observed during domain decomposition are separately
	modeled as scenario aspects, which can be transparently applied to
	system abstractions with the aid of scenario adapters. The assembling
	of such software components to produce a functioning system is assisted
	by component frameworks, which capture elements of reusable software
	architecture identified in the course of domain engineering. Usability
	is improved by in ated interfaces, which export whole families of
	abstractions to users as if they were single macrocomponents, passing
	the responsibility of selecting appropriate family members to the
	system. The concepts and techniques introduced by application-oriented
	system design were verified during the development of Epos (Embedded
	Parallel Operating System), an application-oriented operating system
	for the domain of high-performance dedicated computing. The prototype
	of Epos implemented for the Snow cluster of workstations consists
	of a repository of software components that encapsulate system abstractions
	and scenario aspects, a statically metaprogrammed component framework,
	and a set of tools that is able to automatically select and configure
	components in order to generate application-oriented system instances.},
  keywords = {epos, operating systems},
  language = {en},
  pdf = {Froehlich2001.pdf},
  url = {http://www.lisha.ufsc.br/~guto/publications/aoos.pdf},
}

@TECHREPORT{Gal2003,
  author = {Andreas Gal and Christian W. Probst and Michael Franz},
  title = {Static Closure of Java Dynamic Class Loading},
  institution = {University of California, Irvine, School of Information and Computer
	Science},
  year = {2003},
  number = {03-32},
  month = {September},
  pdf = {Gal2003.pdf},
  url = {http://nil.ics.uci.edu/~probst/index.php?goto=abstracts},
}

@BOOK{EmbeddedDictionary,
  title = {Embedded Systems Dictionary},
  publisher = {{CMPBooks}},
  year = {2003},
  author = {J. Ganssle and M. Barr},
  isbn = {1-57820-120-9},
  keywords = {embedded systems},
}

@INPROCEEDINGS{Grimaud2003,
  author = {G. Grimaud and J.-J. Vandewalle},
  title = {Introducing Research Issues for Next Generation {J}ava-based Smart
	Card Platforms},
  booktitle = {Proc. Smart Objects Conference (sOc'2003)},
  year = {2003},
  address = {Grenoble, France},
  keywords = {java, smart card},
  language = {en},
  pdf = {Grimaud2003.pdf},
  url = {http://www.lifl.fr/RD2P/Papers/rd2p.bib/grimaud-soc-03},
}

@INPROCEEDINGS{Grove1997,
  author = {David Grove and Greg DeFouw and Jeffrey Dean and Craig Chambers},
  title = {Call graph construction in object-oriented languages},
  booktitle = {OOPSLA '97: Proceedings of the 12th ACM SIGPLAN conference on Object-oriented
	programming, systems, languages, and applications},
  year = {1997},
  pages = {108--124},
  address = {New York, NY, USA},
  publisher = {ACM Press},
  doi = {http://doi.acm.org/10.1145/263698.264352},
  isbn = {0-89791-908-4},
  keywords = {call graph, code specialization},
  location = {Atlanta, Georgia, United States},
  pdf = {Grove1997.pdf},
  url = {http://portal.acm.org/citation.cfm?id=264352\&coll=Portal\&dl=GUIDE\&CFID=42547536\&CFTOKEN=73837719},
}

@INPROCEEDINGS{Hall1999,
  author = {Richard S. Hall and Dennis Heimbigner and Alexander L. Wolf},
  title = {A Cooperative Approach to Support Software Deployment Using the Software
	Dock},
  booktitle = {International Conference on Software Engineering},
  year = {1999},
  pages = {174-183},
  url = {http://citeseer.ist.psu.edu/hall99cooperative.html},
}

@ARTICLE{Hartel2001,
  author = {Pieter H. Hartel and Luc Moreau},
  title = {Formalizing the safety of Java, the Java virtual machine, and Java
	card},
  journal = {ACM Comput. Surv.},
  year = {2001},
  volume = {33},
  pages = {517--558},
  number = {4},
  doi = {http://doi.acm.org/10.1145/503112.503115},
  issn = {0360-0300},
  keywords = {java},
  pdf = {Hartel2001.pdf},
  publisher = {ACM Press},
  url = {http://portal.acm.org/citation.cfm?id=503115&coll=Portal&dl=ACM&CFID=29272944&CFTOKEN=84887953},
}

@INPROCEEDINGS{Helander1998,
  author = {Johannes Helander and Alessandro Forin},
  title = {MMLite: a highly componentized system architecture},
  booktitle = {Proceedings of the 8th ACM SIGOPS European workshop on Support for
	composing distributed applications},
  year = {1998},
  pages = {96--103},
  publisher = {ACM Press},
  doi = {http://doi.acm.org/10.1145/319195.319210},
  keywords = {mmlite, operating systems},
  lang = {en},
  location = {Sintra, Portugal},
  pdf = {Helander1998.pdf},
  url = {http://portal.acm.org/citation.cfm?id=319210},
}

@TECHREPORT{Hofmeister1993,
  author = {Christine R. Hofmeister and James M. Purtilo},
  title = {A Framework for Dynamic Reconfiguration of Distributed Programs},
  institution = {University of Maryland},
  year = {1993},
  number = {CS-TR-3119},
  abstract = {Inspired by Kramer and Magee's reconfiguration model in Conic, this
	work adapts that model to the Polylith distributed environment (supports
	general message-passing, not just RPC). Reconfigurations can change
	module implementations, application structure (e.g. add and remove
	modules), and application geometry (e.g. physical location of modules).
	This work extends the Conic work by adding support for capturing
	and restoring process state via an intermediate abstract representation
	[herlihy82value]. Reconfiguring modules must be quiescent; messages
	received during the reconfiguration are buffered and are used to
	initialize the replacement module.},
  keywords = {reconfiguration},
  pdf = {Hofmeister1993.pdf},
  url = {http://citeseer.ist.psu.edu/hofmeister93framework.html},
}

@ARTICLE{Hummel1997,
  author = {Joseph Hummel and Ana Azevedo and David Kolson and Alexandru Nicolau},
  title = {Annotating the {Java} bytecodes in support of optimization},
  journal = {Concurrency: Prac\-tice and Experience},
  year = {1997},
  volume = {9},
  pages = {1003--1016},
  number = {11},
  pdf = {Hummel1997.pdf},
  url = {http://citeseer.ist.psu.edu/hummel97annotating.html},
}

@INPROCEEDINGS{Ishizaki1999,
  author = {Kazuaki Ishizaki and Motohiro Kawahito and Toshiaki Yasue and Mikio
	Takeuchi and Takeshi Ogasawara and Toshio Suganuma and Tamiya Onodera
	and Hideaki Komatsu and Toshio Nakatani},
  title = {Design, implementation, and evaluation of optimizations in a just-in-time
	compiler},
  booktitle = {JAVA '99: Proceedings of the ACM 1999 conference on Java Grande},
  year = {1999},
  pages = {119--128},
  address = {New York, NY, USA},
  publisher = {ACM Press},
  doi = {http://doi.acm.org/10.1145/304065.304111},
  isbn = {1-58113-161-5},
  location = {San Francisco, California, United States},
  pdf = {Ishizaki1999.pdf},
  url = {http://portal.acm.org/citation.cfm?id=1075386},
}

@BOOK{Jones1993,
  title = {Partial evaluation and automatic program generation},
  publisher = {Prentice-Hall, Inc.},
  year = {1993},
  author = {Neil D. Jones and Carsten K. Gomard and Peter Sestoft},
  abstract = {This book is about partial evaluation, a program optimization technique
	also known as program specialization. It presents general principles
	for constructing partial evaluators for a variety of programming
	languages, and it gives examples of applications and numerous references
	to the literature.},
  isbn = {0-13-020249-5},
  keywords = {partial interpretation, code specialization},
  pdf = {Jones1993.pdf},
  url = {http://www.dina.dk/~sestoft/pebook/pebook.html},
}

@INCOLLECTION{Jones1994,
  author = {Jones, Neil D. and Nielson, Flemming},
  title = {Abstract Interpretation: a Semantics-Based Tool for Program Analysis},
  booktitle = {Handbook of Logic in Computer Science},
  publisher = {Oxford University Press},
  year = {1994},
  note = {527--629},
  abstract = {This is a broad overview of Abstract Interpretation, to be a large
	chapter (around 100 pages) in the above-mentioned handbook. It consists
	of three main parts: an Introduction with motivation and Descriptions
	of the main methods used in the field; a mathematical development
	of the logical relations approach with several applications; and
	short descriptions of a broad spectrum of Semantics-Based Program
	Analyses.},
  keywords = {partial interpretation, abstract interpretation, flow analysis, static
	program analysis, code specialization},
  pdf = {Jones1994.pdf},
  semno = {D-58},
  url = {http://www.cs.uu.nl/~bastiaan/research.html},
}

@INPROCEEDINGS{Kiczales1993,
  author = {Kiczales, G. and Lamping, J. and Maeda, C. and Keppel, D. and NcManee,
	D.},
  title = {The need for customizable operating systems},
  booktitle = {Fourth Workshop on Workstation Operating Systems},
  year = {1993},
  pages = {165--169},
  abstract = {Although modern operating systems provide powerful abstractions to
	application programs, they often fail to implement those abstractions
	in a way that provides applications programs, especially specialized
	application programs, with the best utilization of the physical resources
	of the computer system. The operating system community has implicitly
	recognized this problem by providing mechanisms that give client
	programmers more access to the physical substrate. The Mach External
	Pager allows clients to replace the paging mechanism. More recent
	work allows client replacement of the paging policy as well. Scheduler
	activations share the job of thread management between clients and
	the system. Apertos allows these and other aspects of operating system
	implementation to be client-controlled. Object-oriented operating
	systems under development also provide these kinds of control. We
	contend that there is a very general issue here, which operating
	systems have been among the first kinds of software to have to face
	head-on: some implementation decisions are crucial strategy decisions
	whose resolution will invariably bias the performance of the resulting
	implementation. Explicitly recognizing this issue helps to make sense
	of current trends and suggests new directions to explore. We consider
	the implications of this issue for operating systems, providing a
	framework with which to analyze systems such as those mentioned above,
	and suggesting connections with similar problems in other domains.},
  keywords = {operating systems},
  lang = {en},
  pdf = {Kiczales1993.pdf},
  url = {http://citeseer.ist.psu.edu/kiczales93need.html},
}

@INCOLLECTION{Kiczales1997,
  author = {Gregor Kiczales and John Lamping and Anurag Menhdhekar and Chris
	Maeda and Cristina Lopes and Jean-Marc Loingtier and John Irwin},
  title = {Aspect-Oriented Programming},
  booktitle = {Proceedings European Conference on Object-Oriented Programming},
  publisher = {Springer-Verlag},
  year = {1997},
  editor = {Mehmet Ak\c{s}it and Satoshi Matsuoka},
  volume = {1241},
  pages = {220--242},
  address = {Berlin, Heidelberg, and New York},
  keywords = {reconfiguration},
  pdf = {Kiczales1997.pdf},
  url = {citeseer.ist.psu.edu/article/kiczales97aspectoriented.html},
}

@ARTICLE{Kon2000a,
  author = {Fabio Kon and Roy Campbell},
  title = {Dependence management in component-based distributed systems},
  journal = {Concurrency, IEEE},
  year = {2000},
  volume = {8},
  pages = {26--36},
  number = {1},
  month = {January},
  abstract = {The authors present a generic model for reifying dependencies in distributed
	component systems. They discuss how a representation model makes
	it possible to develop efficient, reliable and dynamically configurable
	component-based systems.},
  keywords = {2k, operating systems},
  lang = {en},
  pdf = {Kon2000a.pdf},
  url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arNumber=824310&rp=jk},
}

@TECHREPORT{Kon1999,
  author = {Fabio Kon and Roy Campbell and M. Dennis Mickunas and Klara Nahrstedt},
  title = {2K: A Distributed Operating System for Dynamic Heterogeneous Environments},
  institution = {University of Illinois},
  year = {1999},
  abstract = {The first decades of the new millennium will witness an explosive
	growth in the number and diversity of networked devices and portals.
	We foresee high degrees of mobility, heterogeneity, and interactions
	among computing devices connected to global networks. While previous
	research in distributed operating systems solved many problems related
	to resource management, they seldom addressed the problems of heterogeneity
	and dynamic adaptability. On the other hand, middleware solutions,
	like CORBA and Java/Jini, solve part of the heterogeneity problem
	by permitting seamless communication among different platforms. However,
	they do not address dynamic resource management and adaptability
	for applications requiring high-performance distributed computing.
	This paper presents 2K, an integrated operating system architecture
	that addresses the problems of resource management in heterogeneous
	networks, dynamic adaptability, and configuration of component-based
	distributed applications.},
  comment = {See also the sorter version: {[oscustomization.bib, Kon2000]}.},
  keywords = {2k, operating systems},
  pdf = {Kon1999.pdf},
  url = {http://choices.cs.uiuc.edu/2k/},
}

@INPROCEEDINGS{Kon2000,
  author = {Fabio Kon and Roy Campbell and M. Dennis Mickunas and Klara Nahrstedt
	and Francisco J. Ballesteros},
  title = {2K: A Distributed Operating System for Dynamic Heterogeneous Environments},
  booktitle = {9th IEEE International Symposium on High Performance Distributed
	Computing},
  year = {2000},
  address = {Pittsburgh},
  month = {August},
  abstract = {The first decades of the new millennium will witness an explosive
	growth in the number and diversity of networked devices and portals.
	We foresee high degrees of mobility, heterogeneity, and interactions
	among computing devices connected to global networks. While previous
	research in distributed operating systems solved many problems related
	to resource management, they seldom addressed the problems of heterogeneity
	and dynamic adaptability. On the other hand, middleware solutions,
	like CORBA and Java/Jini, solve part of the heterogeneity problem
	by permitting seamless communication among different platforms. However,
	they do not address dynamic resource management and adaptability
	for applications requiring high-performance distributed computing.
	This paper presents 2K, an integrated operating system architecture
	that addresses the problems of resource management in heterogeneous
	networks, dynamic adaptability, and configuration of component-based
	distributed applications.},
  comment = {See also the longer, technical report version: {[oscustomization.bib,
	Kon1999]}.},
  keywords = {2k, operating systems},
  pdf = {Kon2000.pdf},
  url = {http://choices.cs.uiuc.edu/2k/},
}

@INPROCEEDINGS{Kon2001,
  author = {Fabio Kon and Tomonori Yamane and Christopher Hess and Roy Campbell
	and M. Dennis Mickunas},
  title = {Dynamic Resource Management and Automatic Configuration of Distributed
	Component Systems},
  booktitle = {Proceedings of the 6th USENIX Conference on Object-Oriented Technologies
	and Systems (COOTS'2001)},
  year = {2001},
  pages = {15-30},
  address = {San Antonio, Texas},
  month = {February},
  keywords = {java, code specialization},
  lang = {en},
  pdf = {Kon2001.pdf},
  url = {http://choices.cs.uiuc.edu/2k/},
}

@INPROCEEDINGS{Lagosanto2002,
  author = {Lagosanto, Laurent},
  title = {Next-generation embedded Java operating system for smart cards},
  booktitle = {4th Gemplus Developer Conference},
  year = {2002},
  keywords = {java, smart card, embedded systems},
  lang = {en},
  pdf = {Lagosanto2002.pdf},
  url = {http://www.gemplus.com/smart/r_d/publications/pdf/Lag02gdc.pdf},
}

@INPROCEEDINGS{LeMeur2002,
  author = {Le Meur, A.-F. and Lawall, J.L. and Consel, C.},
  title = {Towards Bridging the Gap Between Programming Languages and Partial
	Evaluation},
  booktitle = {ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program
	Manipulation},
  year = {2002},
  pages = {9--18},
  address = {Portland, OR, USA},
  month = JAN,
  publisher = {ACM Press},
  abstract = {Partial evaluation is a program-transformation technique that automatically
	specializes a program with respect to user-supplied invariants. Despite
	successful applications in areas such as graphics, operating systems,
	and software engineering, partial evaluators have yet to achieve
	widespread use. One reason is the difficulty of adequately describing
	specialization opportunities. Indeed, under-specialization or over-specialization
	often occurs, without any direct feedback to the user as to the source
	of the problem. We have developed a high-level, module-based language
	allowing the programmer to guide the choice of both the code to specialize
	and the invariants to exploit during the specialization process.
	To ease the use of partial evaluation, the syntax of this language
	is similar to the declaration syntax of the target language of the
	partial evaluator. To provide feedback to the programmer, declarations
	are checked throughout the analyses performed by partial evaluation.
	The language has been successfully used by a signal-processing expert
	in the design of a specializable Forward Error Correction component.},
  keyword = {Specialization},
  keywords = {partial interpretation, code specialization},
  pdf = {LeMeur2002.pdf},
  url = {http://compose.labri.fr/documentation/papers/lemeur-pepm02.pdf},
}

@MANUAL{Leavens2005,
  title = {JML Reference Manual},
  author = {Gary T. Leavens and Erik Poll and Curtis Clifton and Yoonsik Cheon
	and Clyde Ruby and David Cok and Peter M ller and Joseph Kiniry},
  month = {July},
  year = {2005},
  pdf = {Leavens2005.pdf},
  url = {http://www.cs.iastate.edu/~leavens/JML/documentation.shtml},
}

@INPROCEEDINGS{Lestideau2002,
  author = {Vincent Lestideau and Noureddine Belkhatir and Pierre-Yves Cunin},
  title = {Towards Automated Software Component Configuration and Deployment},
  booktitle = {8th International Conference on Information Systems Analysis and
	Synthesis},
  year = {2002},
  abstract = {Software deployment is a complex process that covers post development
	activities as configuring, releasing, installing, updating, adapting
	until uninstalling a software application. The existing tools do
	not cover all this process and they are ad hoc. This paper presents
	and describes some ideas to create a deployment environment. The
	aim of this environment is to ensure a coherent and secure installation.
	We propose an approach using the federation technology.},
  pdf = {Lestideau2002.pdf},
  url = {citeseer.ist.psu.edu/lestideau02towards.html},
}

@INPROCEEDINGS{Liang1998,
  author = {Liang, Sheng and Bracha, Gilad},
  title = {Dynamic class loading in the {Java} virtual machine},
  booktitle = {Conference on Object-oriented programming, systems, languages, and
	applications ({OOPSLA}'98)},
  year = {1998},
  pages = {36--44},
  keywords = {java, class loading},
  url = {http://citeseer.ist.psu.edu/liang98dynamic.html},
}

@INPROCEEDINGS{Lie1993,
  author = {Jochen Liedtke},
  title = {Improving IPC by Kernel Design},
  booktitle = {14th ACM Symposium on Operating System Principles (SOSP)},
  year = {1993},
  month = {December},
  keywords = {microkernels, operating systems},
  lang = {en},
  url = {citeseer.ist.psu.edu/liedtke93improving.html},
}

@BOOK{Lindholm2000,
  title = {Java Virtual Machine Specification},
  publisher = {Addison-Wesley Longman Publishing Co., Inc.},
  year = {1999},
  author = {Lindholm, Tim and Yellin, Frank},
  abstract = {The nucleus of the Java 2 platform, the Java virtual machine is the
	technology that enables the Java 2 platform to host applications
	on any computer or operating system without rewriting or recompiling.
	This book was written by those directly responsible for the design
	and implementation of the Java virtual machine, and is the complete
	and definitive specification for the technology. It is an essential
	reference for writers of compilers for the Java programming language
	and implementors of the Java virtual machine. This second edition
	specifies the newest version of the Java virtual machine and provides
	a fascinating view into the inner workings of the Java 2 platform.},
  isbn = {0201432943},
  keywords = {java},
  lang = {en},
  url = {http://portal.acm.org/citation.cfm?id=553607},
}

@BOOK{Maes1988,
  title = {Meta-Level Architectures and Reflection},
  publisher = {Elsevier Science Inc.},
  year = {1988},
  author = {Pattie Maes and D. Nardi},
  isbn = {0444703438},
  keywords = {reflection, operating systems},
  lang = {en},
  url = { http://portal.acm.org/citation.cfm?id=576185 },
}

@ARTICLE{McNamee2001,
  author = {Dylan McNamee and Jonathan Walpole and Calton Pu and Crispin Cowan
	and Charles Krasic and Ashvin Goel and Perry Wagle and Charles Consel
	and Gilles Muller and Renauld Marlet},
  title = {Specialization tools and techniques for systematic optimization of
	system software},
  journal = {ACM Trans. Comput. Syst.},
  year = {2001},
  volume = {19},
  pages = {217--251},
  number = {2},
  abstract = {Specialization has been recognized as a powerful technique for optimizing
	operating systems. However, specialization has not been broadly applied
	beyond the research community because current techniques based on
	manual specialization, are time-consuming and error-prone. The goal
	of the work described in this paper is to help operating system tuners
	perform specialization more easily. We have built a specialization
	toolkit that assists the major tasks of specializing operating systems.
	We demonstrate the effectiveness of the toolkit by applying it to
	three diverse operating system components. We show that using tools
	to assist specialization enables significant performance optimizations
	without error-prone manual modifications. Our experience with the
	toolkit suggests new ways of designing systems that combine high
	performance and clean structure.},
  doi = {http://doi.acm.org/10.1145/377769.377778},
  issn = {0734-2071},
  keywords = {code specialization},
  lang = {en},
  pdf = {McNamee2001.pdf},
  publisher = {ACM Press},
  url = {http://portal.acm.org/citation.cfm?id=377778},
}

@INPROCEEDINGS{Mosberger1996,
  author = {David Mosberger and Larry L. Peterson},
  title = {Making Paths Explicit in the Scout Operating System},
  booktitle = {Operating Systems Design and Implementation},
  year = {1996},
  pages = {153-167},
  abstract = {This paper makes a case for paths as an explicit abstraction in operating
	system design. Paths provide a unifying infrastructure for several
	OS mechanisms that have been introduced in the last several years,
	including fbufs, integrated layer processing, packet classifiers,
	code specialization, and migrating threads. This paper articulates
	the potential advantages of a path-based OS structure, describes
	the specific path architecture implemented in the Scout OS, and demonstrates
	the advantages in a particular application domain---receiving, decoding,
	and displaying MPEG-compressed video.},
  comment = {The main contribution of this paper is to give a clear definition
	of paths, a concept that was implicitly used before, and to demonstrate
	their efficiency for customizable I/O intensive operating systems.
	Scout is a framework made of components, each one implementing a
	particular feature (IP, Ethernet, MPEG decompression, ...). During
	build-time, components are connected to each other through their
	interface. The originality of Scout is that a components graph is
	built from these informations, allowing for packets which path into
	the module graph is predictable to adopts a specialized, optimized
	behavior. Scout applies this concept to the whole operating system,
	but it seems that the principles of this paper can easily be applied
	to parts of an OS that deals with I/O - for instance, ideas from
	this paper could probably be used with the TCP/IP stack of JITS,
	since it already makes guesses about where a packet will end upon
	its arrival. This paper shows the advantages that can be taken from
	knowing the path a network packet will follow at run-time: global
	scheduling policies, avoid redundant work, etc. See also Mosberger1996a.},
  keywords = {scout, operating systems},
  lang = {en},
  pdf = {Mosberger1996.pdf},
  url = {http://citeseer.ist.psu.edu/mosberger96making.html},
}

@INPROCEEDINGS{Mosberger1996a,
  author = {David Mosberger and Larry L. Peterson and Patrick G. Bridges and
	Sean O'Malley},
  title = {Analysis of Techniques to Improve Protocol Processing Latency},
  booktitle = {Proceedings of the Conference on Applications, Technologies, Architectures
	and Protocols for Computer Communications (ACM SIGCOMM '96)},
  year = {1996},
  pages = {73--84},
  address = {Stanford, CA USA},
  month = {August},
  organization = {ACM},
  abstract = {This paper describes several techniques designed to improve protocol
	latency, and reports on their effectiveness when measured on a modern
	RISC machine employing the DECAlpha processor. We found that the
	memory system - which has long been known to dominate network throughput
	- is also a key factor in protocol latency. As a result, improving
	instruction cache effectiveness can greatly reduce protocol processing
	overheads. An important metric in this context is the memory cycles
	per instructions (mCPI), which is the average number of cycles that
	an instruction stalls waiting for a memory access to complete. The
	techniques presented in this paper reduce the mCPI by a factor of
	1.35 to 5.8. In analyzing the effectiveness of the techniques, we
	also present a detailed study of the protocol processing behavior
	of two protocol stacks - TCP/IP and RPC - on a modern RISC processor.
	},
  comment = {This paper proposes an analysis of code customization techniques to
	improve protocol latency. They include outlining, cloning and path-inlining.
	The global knowledge of paths a packet will follow greatly helps
	these techniques. See the companion paper first: Mosberger1996.},
  keywords = {scout, operating systems},
  lang = {en},
  pdf = {Mosberger1996a.pdf},
  url = {http://www.cs.princeton.edu/nsg/papers/latency-sigcomm.html},
}

@ARTICLE{Mulchandani1998,
  author = {Mulchandani, Deepak},
  title = {Java for embedded systems},
  journal = {Internet Computing, IEEE},
  year = {1998},
  volume = {2},
  pages = {30 - 39},
  number = {3},
  abstract = {Java requires infrastructure to run on embedded devices. This requirement
	must be traded against the powerful support for dynamic behavior
	that it offers embedded system developers.},
  keywords = {java, embedded systems},
  lang = {en},
  pdf = {Mulchandani1998.pdf},
  url = {http://ieeexplore.ieee.org:80/xpls/abs_all.jsp?isNumber=15040&arNumber=683797&isnumber=15040&arnumber=683797},
}

@INCOLLECTION{Muller1997,
  author = {Gilles Muller and Barbara Moura and Fabrice Bellard and Charles Consel},
  title = {Harissa: a Flexible and Efficient Java Environment Mixing Bytecode
	and Compiled Code},
  booktitle = {Third USENIX Conference on Object-Oriented Technologies (COOTS)},
  publisher = {USENIX},
  year = {1997},
  address = {Portland, Oregon},
  month = {June},
  comment = {Uses interesting static analysis techniques. References to read.},
  keywords = {harissa, java},
  lang = {en},
  pdf = {Muller1997.pdf},
  url = {http://compose.labri.fr/prototypes/harissa/},
}

@ARTICLE{Myers1995,
  author = {Myers, W.},
  title = {Taligent's CommonPoint: the promise of objects},
  journal = {Computer},
  year = {1995},
  volume = {28},
  pages = {78--83},
  number = {3},
  month = {Mar},
  abstract = {Taligent has introduced what promises to be a revolutionary software
	environment. CommonPoint's object-oriented frameworks suggest the
	tantalizing possibility of ?zero-lines-of-code programming?},
  keywords = {taligent, operating systems},
  lang = {en},
  pdf = {Myers1995.pdf},
  url = {http://ieeexplore.ieee.org/xpl/abs_free.jsp?arNumber=366166},
}

@INPROCEEDINGS{Ogasawara2001,
  author = {Takeshi Ogasawara and Hideaki Komatsu and Toshio Nakatani},
  title = {A study of exception handling and its dynamic optimization in Java},
  booktitle = {OOPSLA '01: Proceedings of the 16th ACM SIGPLAN conference on Object
	oriented programming, systems, languages, and applications},
  year = {2001},
  pages = {83--95},
  address = {New York, NY, USA},
  publisher = {ACM Press},
  doi = {http://doi.acm.org/10.1145/504282.504289},
  isbn = {1-58113-335-9},
  location = {Tampa Bay, FL, USA},
  pdf = {Ogasawara2001.pdf},
  url = {http://portal.acm.org/citation.cfm?id=504289},
}

@INPROCEEDINGS{Palsberg1991,
  author = {Jens Palsberg and Michael I. Schwartzbach},
  title = {Object-oriented type inference},
  booktitle = {OOPSLA '91: Conference proceedings on Object-oriented programming
	systems, languages, and applications},
  year = {1991},
  pages = {146--161},
  address = {New York, NY, USA},
  publisher = {ACM Press},
  doi = {http://doi.acm.org/10.1145/117954.117965},
  isbn = {0-201-55417-8},
  location = {Phoenix, Arizona, United States},
  pdf = {Palsberg1991.pdf},
}

@TECHREPORT{JBL05MP,
  author = {Mariela Pavlova},
  title = {Java Bytecode Logic and Specification},
  institution = {INRIA, Sophia-Antipolis},
  year = {2005},
  note = {Draft version.},
  optmonth = {Jan},
}

@INPROCEEDINGS{Proebsting1997,
  author = {Todd A. Proebsting and Gregg Townsend and Patrick Bridges and John
	H. Hartman and Tim Newsham and Scott A. Watterson},
  title = {Toba: Java For Applications: A Way Ahead of Time (WAT) Compiler},
  booktitle = {Third USENIX Conference on Object-Oriented Technologies (COOTS)},
  year = {1997},
  address = {Portland, Oregon},
  month = {June},
  publisher = {University of Arizona},
  abstract = {Toba is a system for generating efficient standalone Java applications.
	Toba includes a Java-bytecode-to-C compiler, a garbage collector,
	a threads package, and Java API support. Toba-compiled Java applications
	execute 1.5--10 times faster than interpreted and Just-In-Time compiled
	applications.},
  institution = {The Department of Computer Science, University of Arizona},
  keywords = {java},
  lang = {en},
  pdf = {Proebsting1997.pdf},
  url = {http://portal.acm.org/citation.cfm?id=893551},
}

@INPROCEEDINGS{Pu1995,
  author = {C. Pu and T. Autrey and A. Black and C. Consel and C. Cowan and J.
	Inouye and L. Kethana and J. Walpole and K. Zhang},
  title = {Optimistic incremental specialization: streamlining a commercial
	operating system},
  booktitle = {Proceedings of the fifteenth ACM symposium on Operating systems principles},
  year = {1995},
  pages = {314--321},
  publisher = {ACM Press},
  doi = {http://doi.acm.org/10.1145/224056.224080},
  isbn = {0-89791-715-4},
  keywords = {synthetix, operating systems},
  lang = {en},
  location = {Copper Mountain, Colorado, United States},
  pdf = {Pu1995.pdf},
  url = {http://portal.acm.org/citation.cfm?id=224080},
}

@ARTICLE{Pu1988,
  author = {Calton Pu and Henry Massalin and John Ioannidis},
  title = {The {S}ynthesis Kernel},
  journal = {Computing Systems},
  year = {1988},
  volume = {1},
  pages = {11--32},
  number = {1},
  comment = {This article is quite old (1988!) but is interesting as an introduction
	to code specialization. It describes the code specialisation process
	used in ''Synthesis''. System code is specialized at run-time according
	to frequently visited system states. The teasing example is how system
	calls to @@read@@ can be made several times faster if its code is
	specialized during the call to @@open@@.[[<<]] [[<<]] Techniques
	explained are ''Factoring Invariants'', ''Collapsing Layers'' and
	''Executable Data Structures''. These techniques are simple and fast
	enough to be performed at run-time, and can be qualified as the basis
	of code customization - this is what makes this article an interesting
	introduction to code specialization.[[<<]][[<<]] The applicability
	of these techniques are obvious for systems with enough RAM to suppport
	several versions of the same code (several specialized version, plus
	one that handles all cases). However, embedded systems could find
	it hard to apply the same principles dynamically - still, they remain
	valid in the context of a static customization. This article is also
	limited in that not every system function of ''Synthesis'' could
	be specialized. It's up to the system programmer to provide a specialization
	function that will generate a specialized version of a function according
	to a set of parameters through a function template. No procedure
	is proposed to automate the specialization process.},
  keywords = {synthesis, operating systems},
  lang = {en},
  pdf = {Pu1988.pdf},
  url = {http://citeseer.ist.psu.edu/22153.html},
}

@INPROCEEDINGS{Rashid1989,
  author = {Richard Rashid and Robert Baron and Alessandro Forin and David Golub
	and Michael Jones and Daniel Julin and Douglas Orr and Richard Sanzi},
  title = {Mach: A Foundation for Open Systems},
  booktitle = {Proceedings of the Second Workshop on Workstation Operating Systems
	(WWOS2)},
  year = {1989},
  month = {September},
  abstract = {This paper is an introduction to the Mach operating system.},
  keywords = {microkernels, operating systems},
  lang = {en},
  pdf = {Rashid1989.pdf},
  url = {http://www-2.cs.cmu.edu/afs/cs/project/mach/public/www/doc/publications.html},
}

@ARTICLE{Rayside2002,
  author = {Derek Rayside and Kostas Kontogiannis},
  title = {Extracting Java library subsets for deployment on embedded systems},
  journal = {Sci. Comput. Program.},
  year = {2002},
  volume = {45},
  pages = {245--270},
  number = {2-3},
  doi = {http://dx.doi.org/10.1016/S0167-6423(02)00059-X},
  issn = {0167-6423},
  keywords = {code specialization},
  pdf = {Rayside2002.pdf},
  publisher = {Elsevier North-Holland, Inc.},
  url = {http://portal.acm.org/citation.cfm?id=781586&coll=Portal&dl=GUIDE&CFID=29272944&CFTOKEN=84887953},
}

@INPROCEEDINGS{Rayside1999,
  author = {Rayside, Derek and Mamas, Evan and Hons, Erik},
  title = {Compact Java binaries for embedded systems},
  booktitle = {Proceedings of the 1999 conference of the Centre for Advanced Studies
	on Collaborative research},
  year = {1999},
  pages = {9},
  publisher = {IBM Press},
  keywords = {code specialization},
  location = {Mississauga, Ontario, Canada},
  pdf = {Rayside1999.pdf},
  url = {http://portal.acm.org/citation.cfm?id=782004&coll=Portal&dl=ACM&CFID=29272944&CFTOKEN=84887953},
}

@ARTICLE{Rippert2003,
  author = {Christophe Rippert},
  title = {Protection in flexible operating system architectures},
  journal = {SIGOPS Oper. Syst. Rev.},
  year = {2003},
  volume = {37},
  pages = {8--18},
  number = {4},
  abstract = { This paper presents our work concerning flexibility and protection
	in operating system kernels. In most existing operating systems,
	security is enforced at the price of flexibility by imposing protection
	models on the system programmer when building his system. We prove
	that flexibility can be preserved by separating the management of
	the protection policy from the tools used to enforce it. We present
	the secure software framework we have implemented in the THINK architecture
	to manage protection policies and guarantee they are carried out
	as specified. We then detail the elementary protection tools provided
	to the programmer so he can protect his system against unauthorized
	accesses and denial of service attacks. These tools are implemented
	in a policy-neutral way so as to guarantee their flexibility. Finally
	we validate our results by evaluating the flexibility of the protection
	provided on selected examples of dynamic modification of the protection
	policy.},
  doi = {http://doi.acm.org/10.1145/958965.958966},
  issn = {0163-5980},
  keywords = {think, security, operating systems},
  lang = {en},
  pdf = {Rippert2003.pdf},
  publisher = {ACM Press},
  url = {http://portal.acm.org/citation.cfm?id=958966&coll=portal&dl=ACM&CFID=26198948&CFTOKEN=23862609},
}

@PHDTHESIS{Rippert2003a,
  author = {Christophe Rippert},
  title = {Protection dans les architectures de syst�es flexibles},
  school = {Universit�Joseph Fourier - Grenoble 1},
  year = {2003},
  month = {October},
  abstract = {This work aims at proving that security and flexibility can coexist
	in an operating system kernel. We show that both security and flexibility
	can be guaranteed by separating the management of the security policy
	from the tools used to enforce it. Our work is composed of two parts.
	In the first part, we propose elementary protection tools which protect
	the system against selected types of attacks while remaining completely
	independent from the security policy. In the second part, we describe
	the security software framework we have implemented, including the
	component in charge of managing security policies which we call the
	security manager. Our results are validated on examples showing the
	flexibility of protection in the system.},
  keywords = {think, operating systems},
  lang = {en},
  pdf = {Rippert2003a.pdf},
  url = {http://www.lifl.fr/~rippert/},
}

@INPROCEEDINGS{Rippert2004,
  author = {Christophe Rippert and Alexandre Courbot and Gilles Grimaud},
  title = {A Low-Footprint Class Loading Mechanism for Embedded Java Virtual
	Machines},
  booktitle = {3rd ACM International Conference on the Principles and Practice of
	Programming in Java},
  year = {2004},
  address = {Las Vegas (USA)},
  abstract = {This paper shows that it is possible to dramatically reduce the memory
	consumption of classes loaded in an embedded Java virtual machine
	without reducing its functionalities. We describe how to pack the
	constant pool by deleting entries which are only used during the
	class loading process. We present some benchmarks which demonstrate
	the efficiency of this mechanism. We finally suggest some additional
	optimizations which can be applied if some restrictions to the functionalities
	of the virtual machine can be tolerated.},
  keywords = {jits,java},
  lang = {en},
  pdf = {Rippert2004.pdf},
  pubdate = {20040618},
  url = {http://www.lifl.fr/RD2P/JITS/Publications?action=bibentry&bibfile=jits.bib&bibref=Rippert2004},
}

@INPROCEEDINGS{Rippert2004b,
  author = {Christophe Rippert and Damien Deville},
  title = {On-The-Fly Metadata Stripping For Embedded Java Operating Systems},
  booktitle = {Proceedings of the 6th IFIP Smart Card Research and Advanced Application
	Conference (Cardis'04)},
  year = {2004},
  address = {Toulouse (France)},
  month = {August},
  keywords = {jits, java},
  lang = {en},
  pubdate = {20040830},
  url = {http://www.lifl.fr/RD2P/JITS/Publications?action=bibentry&bibfile=jits.bib&bibref=Rippert2004a},
}

@TECHREPORT{Rippert2004a,
  author = {Rippert, Christophe and Deville, Damien and Grimaud, Gilles},
  title = {Alternative schemes for low-footprint operating systems building},
  institution = {INRIA-Futurs},
  year = {2004},
  abstract = {This paper presents two ways of building dedicated embedded operating
	systems. The constructive approach consists in starting from a minimal
	kernel and adding abstractions as they are needed, whereas the destructive
	approach promotes the idea of customizing an existing operating system
	by removing unnecessary abstractions. We compare these two approaches
	on the example of building an embedded Java operating system and
	discuss the pros and cons of each method. We conclude by exhibiting
	the weakness of each approaches concerning dynamic adaptation of
	the system.},
  keywords = {jits, operating systems},
  lang = {en},
  pdf = {Rippert2004a.pdf},
  url = {http://www.inria.fr/rrrt/rr-5220.html},
}

@INPROCEEDINGS{Rippert2001,
  author = {Christophe Rippert and Jean-Bernard Stefani},
  title = {Protection in the Think exokernel},
  booktitle = {Proceedings of the 4th European Research Seminar on Advances in Distributed
	Systems},
  year = {2001},
  pages = {245--250},
  address = {Bertinoro (Italy)},
  month = {May},
  abstract = {In this paper, we present our preliminary ideas concerning the adaptation
	of security and protection techniques in the Think exokernel. Think
	is our proposition of a distributed adaptable kernel, designed according
	to the exokernel architecture},
  keywords = {think, operating systems},
  lang = {en},
  pdf = {Rippert2001.pdf},
  url = {http://sardes.inrialpes.fr/research/think.shtml},
}

@INPROCEEDINGS{Schmidt1998,
  author = {Schmidt, David A. and Steffen, Bernhard},
  title = {Program Analysis as Model Checking of Abstract Interpretations},
  booktitle = {Proceedings of the 5th International Symposium on Static Analysis},
  year = {1998},
  pages = {351--380},
  publisher = {Springer-Verlag},
  isbn = {3-540-65014-8},
  keywords = {partial interpretation, code specialization},
  pdf = {Schmidt1998.pdf},
  url = {http://portal.acm.org/citation.cfm?id=760066},
}

@ARTICLE{Schultz2003,
  author = {Ulrik P. Schultz and Julia L. Lawall and Charles Consel},
  title = {Automatic program specialization for Java},
  journal = {ACM Trans. Program. Lang. Syst.},
  year = {2003},
  volume = {25},
  pages = {452--499},
  number = {4},
  abstract = {The object-oriented style of programming facilitates program adaptation
	and enhances program genericness, but at the expense of efficiency.
	We demonstrate experimentally that state-of-the-art Java compilers
	fail to compensate for the use of object-oriented abstractions in
	the implementation of generic programs, and that program specialization
	can eliminate a significant portion of these overheads. We present
	an automatic program specializer for Java, illustrate its use through
	detailed case studies, and demonstrate experimentally that it can
	significantly reduce program execution time. Although automatic program
	specialization could be seen as being subsumed by existing optimizing
	compiler technology, we show that specialization and compiler optimization
	are in fact complementary.},
  comment = {Concrete example of how code specialization can be automatically exploited.
	It is not so Java-specific since the authors are working at the source
	(and not bytecode) level. So the JSpec tool presented here could
	probably perform fine with others languages. This impression of genericity
	is strenghtened by the fact that JSpec transforms the Java source
	into C source to specialize it using Tempo, a partial evaluator for
	C. The C source is then back-transformed into Java. This scheme has
	been adopted to maximize the effort reuse, since Tempo existed and
	worked fine - however, one can wonder if all the potential of Java
	specialization are explored this way.[[<<]][[<<]]The article is of
	interest and has interesting references, good for a state-of-the-art
	on program specialization. It also gives a clear definition of program
	specialization by comparing it to compiler optimization and object-oriented
	languages inheritance.},
  doi = {http://doi.acm.org/10.1145/778559.778561},
  issn = {0164-0925},
  keywords = {java, code specialization},
  lang = {en},
  pdf = {Schultz2003.pdf},
  publisher = {ACM Press},
  url = {http://portal.acm.org/citation.cfm?id=778561&coll=Portal&dl=ACM&CFID=26117448&CFTOKEN=16208425},
}

@INPROCEEDINGS{Schultz2003a,
  author = {Schultz, Ulrik Pagh and Burgaard, Kim and Christensen, Flemming Gram
	and Knudsen, Jorgen Lindskov},
  title = {Compiling java for low-end embedded systems},
  booktitle = {Proceedings of the 2003 ACM SIGPLAN conference on Language, compiler,
	and tool for embedded systems},
  year = {2003},
  pages = {42--50},
  publisher = {ACM Press},
  abstract = { The production of embedded systems is continuously increasing, but
	developing reusable software for such systems is notoriously difficult,
	in particular in the case of low-end embedded systems based on 16-bit
	or 8-bit processors. We have developed a compilation system for executing
	Java byte code on low-end embedded systems, and we demonstrate how
	this system permits object-oriented programming techniques to be
	used on devices with only a few hundred bytes of RAM and a few kilobytes
	of ROM.We analyze the execution overheads of using object-orien\-ted
	programming on low-end embedded systems. Based on the conclusion
	that memory consumption is the major obstacle, we show how the configuration
	features and optimizations integrated into our compiler can be used
	to significantly reduce memory requirements. In particular, we use
	a novel approach based on Java interfaces to control integration
	of Java programs with the hardware, and demonstrate how aggressive
	whole-program optimization can significantly reduce the size of the
	compiled program.},
  comment = {Mainly seems to be an embedded JIT compiler with a very low footprint.[[<<]]Binary
	distribution of JEPES (Windows only): ftp://ftp.mjolner.dk/jepes/r1.3.5/bcc.tar.gz.[[<<]][[http://www.cs.purdue.edu/s3/LCTES03/
	LCTES'03]] Slides: http://kernel.kaist.ac.kr/~jinsoo/course/cs710/slides/JEPES.pdf.[[<<]][[http://www-sop.inria.fr/everest/events/cassis04/
	CASSIS'04]] Slides: http://www-sop.inria.fr/everest/events/cassis04/Slides/cassis04_ulrik.ppt.},
  doi = {http://doi.acm.org/10.1145/780732.780739},
  isbn = {1-58113-647-1},
  keywords = {jepes, code specialization},
  lang = {en},
  location = {San Diego, California, USA},
  url = {http://portal.acm.org/citation.cfm?id=780739},
}

@MANUAL{Searls2002,
  title = {Java 2 Enterprise Edition Deployment API Specification, Version 1.1},
  author = {Rebecca Searls},
  month = {August},
  year = {2002},
  keywords = {java, J2EE},
  pdf = {Searls2002.pdf},
}

@TECHREPORT{Seltzer1997,
  author = {M. Seltzer and Y. Endo and C. Small and K. Smith},
  title = {Issues in extensible operating systems},
  institution = {Harvard University},
  year = {1997},
  number = {TR-18-97},
  abstract = {Operating systems research has traditionally consisted of adding functionality
	to the operating system or inventing and evaluating new methods for
	performing functions. Regardless of the research goal, the single
	constant has been that the size and complexity of operating systems
	increase over time. As a result, operating systems are usually the
	single most complex piece of software in a computer system, containing
	hundreds of thousands, if not millions, of lines of code. Today's
	operating system research is directed at finding new ways to structure
	the operating system in order to increase its flexibility, allowing
	it to adapt to changes in the application set it must support. This
	paper discusses the issues involved in designing such extensible
	systems and the array of choices facing the operating system designer.
	We present a framework for describing extensible operating systems
	and then relate current operating systems to this framework. },
  keywords = {operating systems},
  lang = {en},
  pdf = {Seltzer1997.pdf},
  url = {http://citeseer.ist.psu.edu/article/seltzer97issues.html},
}

@PHDTHESIS{Senart2003,
  author = {Senart, Aline},
  title = {Canevas logiciel pour la construction d'infrastructures logicielles
	dynamiquement adaptables},
  school = {Institut National Polytechnique de Grenoble},
  year = {2003},
  month = {November},
  comment = {Great state-of-the-art about adaptable operating systems and middleware.},
  keywords = {operating systems},
  lang = {fr},
  pdf = {Senart2003.pdf},
  url = {http://sardes.inrialpes.fr/papers/phd.shtml},
}

@INPROCEEDINGS{Shaylor2002,
  author = {Nik Shaylor},
  title = {A Just-in-Time Compiler for Memory-Constrained Low-Power Devices},
  booktitle = {Proceedings of the 2nd Java\& Virtual Machine Research and Technology
	Symposium},
  year = {2002},
  pages = {119--126},
  publisher = {USENIX Association},
  abstract = {Typical just-in-time compilers for the Java platform are often too
	large and too slow to be used in small computing devices such as
	cell phones or PDAs. In contrast, the JIT described here was targeted
	for such devices, and was built on Sun Microsystem's KVM product.
	Key to making the JIT effective were: a pre-compilation transformation
	of the bytecodes to make compilation easier; compilation of only
	a subset of the bytecodes to make the production of the system simpler;
	quick and simple management of the JIT code buffer; and an effective
	heap comparison technique that greatly aided debugging of generated
	code. The JIT speeded up execution by a factor of between 5.7 and
	10.7. Its implementation required only 60KB of ARM machine code.},
  comment = {This article presents an embedded JIT compiler for Java bytecode with
	a footprint of 60KB on the ARM target. Designed on the KVM, it is
	supposed to improve the performances of demanding Java embedded applications
	like games for memory-constrained devices which cannot embed a fully-featured
	JIT. Its limitations over a "normal" JIT are mainly that the bytecode
	must be pre-processed in order to have an empty operands stack at
	points where the system might switch between interpreted and JIT
	modes. This operation can be made ahead-of-time but it requires the
	bytecode to be specialized for the number of registers present on
	the target machine - the bytecode loses part of its portability.
	Another solution is to perform this analysis during the installation
	of the application on the device. Others constraints include that
	not all bytecodes can be compiled, namely those which have a too
	complicated behavior. The incessant switches between compiled and
	native modes have of course an impact on performance, but the overall
	system gains a speedup factor between 5 and 10 on their evaluations.},
  isbn = {1-931971-01-3},
  keywords = {compilation, code specialization},
  lang = {en},
  pdf = {Shaylor2002.pdf},
  url = {http://portal.acm.org/citation.cfm?id=744884},
}

@INPROCEEDINGS{Shaylor2003,
  author = {Shaylor, Nik and Simon, Douglas N. and Bush, William R.},
  title = {A java virtual machine architecture for very small devices},
  booktitle = {Proceedings of the 2003 ACM SIGPLAN conference on Language, compiler,
	and tool for embedded systems},
  year = {2003},
  pages = {34--41},
  publisher = {ACM Press},
  abstract = {The smallest complete Java? virtual machine implementations in use
	today are based on the CLDC standard and are deployed in mobile phones
	and PDAs. These implementations require several tens of kilobytes.
	Smaller Java-like implementations also exist, but these involve compromises
	in Java semantics. This paper describes a JVM? architecture designed
	for very small devices. It supports all the CLDC Java platform semantics,
	including exact garbage collection, dynamic class loading, and verification.
	For portability and ease of debugging, the entire system is written
	in the Java language, with key components automatically translated
	into C and compiled for the target device. The resulting system will
	run on the next generation of smart cards, and has performance comparable
	to the reference CLDC implementation available from Sun?.},
  doi = {http://doi.acm.org/10.1145/780732.780738},
  isbn = {1-58113-647-1},
  keywords = {java, embedded systems, virtual machine, squawk},
  lang = {en},
  location = {San Diego, California, USA},
  pdf = {Shaylor2003.pdf},
  url = {http://portal.acm.org/citation.cfm?id=780738},
}

@TECHREPORT{Small1994,
  author = {C. Small and M. Seltzer},
  title = {{VINO}: An Integrated Platform for Operating Systems and Database
	Research},
  institution = {Harvard University},
  year = {1994},
  number = {TR-30-94},
  address = {Cambridge, MA},
  abstract = {An early paper discussing the motivation for and high-level design
	of the VINO kernel.},
  keywords = {vino, operating systems},
  lang = {en},
  url = {citeseer.ist.psu.edu/small94vino.html},
}

@INPROCEEDINGS{Sundaresan2000,
  author = {Sundaresan, Vijay and Hendren, Laurie and Razafimahefa, Chrislain
	and Vall{\'e}e-Rai, Raja and Lam, Patrick and Gagnon, Etienne and
	Godin, Charles},
  title = {Practical virtual method call resolution for Java},
  booktitle = {OOPSLA '00: Proceedings of the 15th ACM SIGPLAN conference on Object-oriented
	programming, systems, languages, and applications},
  year = {2000},
  pages = {264--280},
  address = {New York, NY, USA},
  publisher = {ACM Press},
  doi = {http://doi.acm.org/10.1145/353171.353189},
  isbn = {1-58113-200-X},
  keywords = {call graph, code specialization},
  location = {Minneapolis, Minnesota, United States},
  pdf = {Sundaresan2000.pdf},
  url = {http://portal.acm.org/citation.cfm?id=264352&coll=Portal&dl=GUIDE&CFID=42547536&CFTOKEN=73837719},
}

@ARTICLE{Thibault2000,
  author = {Thibault, Scott and Consel, Charles and Lawall, Julia L. and Marlet,
	Renaud and Muller, Gilles},
  title = {Static and Dynamic Program Compilation by Interpreter Specialization},
  journal = {Higher Order Symbol. Comput.},
  year = {2000},
  volume = {13},
  pages = {161--178},
  number = {3},
  abstract = {Interpretation and run-time compilation techniques are increasingly
	important because they can support heterogeneous architectures, evolving
	programming languages, and dynamically-loaded code. Interpretation
	is simple to implement, but yields poor performance. Run-time compilation
	yields better performance, but is costly to implement. One way to
	preserve simplicity but obtain good performance is to apply program
	specialization to an interpreter in order to generate an efficient
	implementation of the program automatically. Such specialization
	can be carried out at both compile time and run time. Recent advances
	in program-specialization technology have significantly improved
	the performance of specialized interpreters. This paper presents
	and assesses experiments applying program specialization to both
	bytecode and structured-language interpreters. The results show that
	for some general-purpose bytecode languages, specialization of an
	interpreter can yield speedups of up to a factor of four, while specializing
	certain structured-language interpreters can yield performance comparable
	to that of an implementation in a general-purpose language, compiled
	using an optimizing compiler.},
  doi = {http://dx.doi.org/10.1023/A:1010078412711},
  issn = {1388-3690},
  keywords = {code specialization},
  lang = {en},
  pdf = {Thibault2000.pdf},
  publisher = {Kluwer Academic Publishers},
  url = {http://portal.acm.org/citation.cfm?id=360517},
}

@ARTICLE{Tip2003,
  author = {Tip, Frank and Sweeney, Peter F. and Laffra, Chris},
  title = {Extracting library-based Java applications},
  journal = {Commun. ACM},
  year = {2003},
  volume = {46},
  pages = {35--40},
  number = {8},
  doi = {http://doi.acm.org/10.1145/859670.859695},
  issn = {0001-0782},
  keywords = {code specialization},
  lang = {en},
  pdf = {Tip2003.pdf},
  publisher = {ACM Press},
  url = {http://portal.acm.org/citation.cfm?id=859695},
}

@INPROCEEDINGS{Raja1999,
  author = {Raja Vall\'ee-Rai and Laurie Hendren and Vijay Sundaresan and Patrick
	Lam and Etienne Gagnon and Phong Co},
  title = {Soot - a Java Optimization Framework},
  booktitle = {Proceedings of CASCON 1999},
  year = {1999},
  pages = {125--135},
  pdf = {Raja1999.pdf},
  url = {http://www.sable.mcgill.ca/publications},
}

@INPROCEEDINGS{Volanschi1997,
  author = {Volanschi, Eugen N. and Consel, Charles and Muller, Gilles and Cowan,
	Crispin},
  title = {Declarative specialization of object-oriented programs},
  booktitle = {Proceedings of the 12th ACM SIGPLAN conference on Object-oriented
	programming, systems, languages, and applications},
  year = {1997},
  pages = {286--300},
  publisher = {ACM Press},
  abstract = {Designing and implementing generic software components is encouraged
	by languages such as object-oriented ones and commonly advocated
	in most application areas. Generic software components have many
	advantages among which the most important is reusability. However,
	it comes at a price: genericity often incurs a loss of efficiency.This
	paper presents an approach aimed at reconciling genericity and efficiency.
	To do so, we introduce declarations to the Java language to enable
	a programmer to specify how generic programs should be specialized
	for a particular usage pattern. Our approach has been implemented
	as a compiler from our extended language into standard Java.},
  doi = {http://doi.acm.org/10.1145/263698.263749},
  isbn = {0-89791-908-4},
  keywords = {code specialization},
  lang = {en},
  location = {Atlanta, Georgia, United States},
  pdf = {Volanschi1997.pdf},
  url = {http://portal.acm.org/citation.cfm?id=263698.263749},
}

@INPROCEEDINGS{Yessick2002,
  author = {Donald E. Yessick and Joel Jones},
  title = {Removal of Bounds Checks In An Annotation Aware JVM},
  booktitle = {SoutheastCon, 2002},
  year = {2002},
  editor = {IEEE},
  pages = {226--228},
  pdf = {Yessick2002.pdf},
}

@BOOK{OSGi,
  title = {{OSGi} Service Platform, Release 3},
  publisher = {IOS Press, Inc.},
  year = {2003},
  author = {{OSGi Alliance}},
  isbn = {1586033115},
  keywords = {java, osgi},
}

@MANUAL{JEFF,
  title = {JEFF Draft Specification},
  author = {{The J-Consortium}},
  month = {March},
  year = {2002},
  keywords = {java},
  url = {http://www.j-consortium.org/jeffwg/index.shtml},
}

@MANUAL{JavaCard,
  title = {The Java Card Virtual Machine Specification},
  year = {2003},
  keywords = {java card},
  pdf = {JavaCard.pdf},
  publisher = {Sun Microsystems},
}

@MANUAL{J2MEWhitePaper,
  title = {J2ME Building Blocks for Mobile Devices},
  organization = {Sun Microsystems},
  year = {2000},
  keywords = {java},
  pdf = {J2MEWhitePaper.pdf},
  url = {http://java.sun.com/products/cldc/wp/KVMwp.pdf},
}

@MANUAL{ELFSpec,
  title = {Executable and Linkable Format ({ELF})},
  organization = {Tools Interface Standards Committee},
  pdf = {ELFSpec.pdf},
  url = {http://www.x86.org/intel.doc/tools.htm},
}

@MISC{JCVM,
  title = {{J}{C} {V}irtual {M}achine},
  howpublished = {http://jcvm.sourceforge.net/},
}

@MISC{JITSWebsite,
  author={LIFL},
  title = {{J}ava {I}n {T}he {S}mall},
  howpublished = {http://www.lifl.fr/RD2P/JITS/},
}

@MISC{LeJOS,
  title = {{L}e{J}{O}{S}},
  howpublished = {http://lejos.sourceforge.net/},
}

@MISC{SPECJVM98,
  title = {{SPEC} {JVM}98 Benchmarks},
  howpublished = {http://www.spec.org/jvm98},
}

@MISC{TinyVM,
  title = {{T}iny{V}{M}},
  howpublished = {http://tinyvm.sourceforge.net/},
}

@INPROCEEDINGS{BRL-JACK,
  AUTHOR = {L. Burdy and A. Requet and J.-L. Lanet},
  TITLE = {Java Applet Correctness: A Developer-Oriented Approach},
  CROSSREF = {fme03},
  PAGES = {422--439},
  PSURL = {ftp://ftp-sop.inria.fr/everest/publis/2003/BRL03fme.ps.gz},
  TOPICS = {team}
}

@PROCEEDINGS{fme03,
  BOOKTITLE = {FME 2003: Formal Methods: International Symposium of Formal Methods Europe},
  TITLE = {FME 2003: Formal Methods: International Symposium of Formal Methods Europe},
  EDITOR = {K. Araki and S. Gnesi and D. Mandrioli},
  VOLUME = {2805},
  SERIES = {Lecture Notes in Computer Science},
  PUBLISHER = {Springer-Verlag},
  YEAR = {2003}
}


@comment{jabref-meta: selector_publisher:USENIX;}

@comment{jabref-meta: groupsversion:2;}

@comment{jabref-meta: groupstree:
0 AllEntriesGroup:;
1 KeywordGroup:Embedded systems\;keywords\;embedded systems\;0\;1\;;
1 KeywordGroup:Java\;keywords\;java\;0\;1\;;
1 KeywordGroup:Compilation\;keywords\;compilation\;0\;1\;;
1 KeywordGroup:Partial interpretation\;keywords\;partial interpretatio
n\;0\;1\;;
1 KeywordGroup:Exokernels\;keywords\;exokernels\;0\;1\;;
1 KeywordGroup:Microkernels\;keywords\;microkernels\;0\;1\;;
1 KeywordGroup:Reconfiguration\;keywords\;reconfiguration\;0\;1\;;
1 KeywordGroup:Reflection\;keywords\;reflection\;0\;1\;;
1 KeywordGroup:Security\;keywords\;security\;0\;1\;;
1 KeywordGroup:Smart card\;keywords\;smart card\;0\;1\;;
1 KeywordGroup:Survey\;keywords\;survey\;0\;1\;;
1 ExplicitGroup:Platforms\;;
2 KeywordGroup:choices\;keywords\;choices\;0\;1\;;
2 KeywordGroup:Vino\;keywords\;vino\;0\;1\;;
2 KeywordGroup:Think\;keywords\;think\;0\;1\;;
2 KeywordGroup:Taligent\;keywords\;taligent\;0\;1\;;
2 KeywordGroup:Synthetix\;keywords\;synthetix\;0\;1\;;
2 KeywordGroup:Spin\;keywords\;spin\;0\;1\;;
2 KeywordGroup:Scout\;keywords\;scout\;0\;1\;;
2 KeywordGroup:Synthesis\;keywords\;synthesis\;0\;1\;;
2 KeywordGroup:OSKit\;keywords\;oskit\;0\;1\;;
2 KeywordGroup:JITS\;keywords\;jits\;0\;1\;;
2 KeywordGroup:JEPES\;keywords\;jepes\;0\;1\;;
2 KeywordGroup:EPOS\;keywords\;epos\;0\;1\;;
2 KeywordGroup:Deimos\;keywords\;deimos\;0\;1\;;
2 KeywordGroup:Choices\;keywords\;choices\;0\;1\;;
2 KeywordGroup:2k\;keywords\;2k\;0\;1\;;
2 KeywordGroup:MMlite\;keywords\;mmlite\;0\;1\;;
}

