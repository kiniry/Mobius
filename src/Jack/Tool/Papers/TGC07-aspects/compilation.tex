The next step after the specifications are desugared is the
compilation of aspects to their {\it effects} on the program. The
approach presented here restricts itself to advices and fields 
introduction. 

Aspects are first turned into model class, a specification only class.
Fields are translated into their model versions.
Advices are turned to model methods, which are bodyless.
To respect the semantic of AspectJ, a static method {\tt aspectOf()}
has to be added. This method returns the current instance of the aspect.
These transformations are direct, but the
specifications of the advices have to be enriched with the pointcuts
conditions that cannot be determined statically.  In the weaving
described in \cite{weaving04}, the code of non static joint point are
added to the program directly.  Here we add this condition to the
specification of the model method representing the advice, since we
only manipulate the specifications and the signature of the method
representing the advice.

\vspace{-0.4cm}
\subsubsection{Translation of the specifications}
The annotations are translated directly to the model methods. The
method has the same signature of the corresponding advice, and the
specifications are copied entirely to the model method. It works
smoothly for most of the cases except for the around advice which is
split into 2 model methods: the one corresponding to the first part,
and the one corresponding to the part after the {\tt then}
construction.  The {\tt proceed} instruction has to be translated to
 JML as well: it becomes a global ghost variable of type bool.  For an
 around advice the model method corresponding to the first part has to
 be modified consequently.  The ensures has the equality {\tt (proceed
 == proc\_cond)} where {\tt proc\_cond} was the argument to the
 annotation {\tt proceed}. The assignable clause is also modified: the
 {\tt proceed} global variable is added to it.
\subsubsection{Translation of the point cuts}
The pointcuts are not directly translated to the model methods, though
the conditions over the pointcut which are not purely syntactical (the
ones not taking only patterns as arguments) are added to the
specification of the method.  More precisely the algorithm is the
following:
\begin{enumerate}
\item 
the point cuts are fully resolved and unfolded to simple boolean
expressions (only a combination of {\tt $||$}, {\tt \&\&}, or {\tt !}
with the point cuts specific keywords).
\item 
then the point cuts expression is ordered in two group: the pattern
related (the one which take an argument of type pattern) and the
others. Typically it will be separated by an {\tt and} ({\tt \&\&}),
but it won't be always the case.
\item 
if the sepation between the pattern point cuts and the other point
cuts is:
\begin{enumerate}
\item 
an {\tt and}: the method {\tt requires} clause is conjuncted with the
expression of the non pattern point cuts and a new behaviour is added
to the methods, where only the {\tt requires} is precised and is the
negation of the expression of the non pattern point cuts.
\item 
a {\tt or}: the method is duplicated, with one version with conjuncted
 to its {\tt requires} clause the expression of the non pattern point
 cuts. This case should most likely be an error in the specification
 of the point cut.
\end{enumerate}
\end{enumerate}

On our example, the Security Manager aspect, the transformation is
straight-forward (Figure \ref{sm_model}).
 The field is turned to an equivalent model field. The 
aspect invariant becomes a class invariant. The advice becomes a normal 
method. The pointcut was entirely static so the specifications do not have
to be enriched with the dynamic elements of the pointcut. The method
{\tt aspectOf()} is added as well.


\vspace{-0.4cm}
\begin{figure}
\begin{center}
\begin{tabular}{ll} \begin{minipage}{3cm}\bcode
/*\=@ pu\=blic model class SM \{\+\\
    @ \>public invariant s != null;\\
    @ \>model Set$<$String$>$ s;\\
    @ \\
    @ \>requires o != null \&\& s != null;\\
    @ \>assignable $\backslash$nothing;\\
    @ \>ensures  s.contains\=(o.getClass().getPackage().toString())\\
    @ \>        \> \&\& !(o.getClass().getPackage().equals("b"));\\
    @ \>exsures (SecurityE\=xception) !s.contains("b")\\
    @ \>                   \>\&\& (o.getClass().getPackage().equals("b"));\\
    @ \>public model void beforeAnyPublicMethod (\=Object o);\\
    @\\
    @ \>assignable $\backslash$nothing; \\
    @ \>ensures $\backslash$result != null;\\
    @ \>public model static SM aspectOf();\\
    @  \}\\
    @*/
\ecode
\end{minipage}
\end{tabular}
\end{center}
\vspace{-0.4cm}
\caption{The model Security Manager}
\label{sm_model}
\vspace{-0.4cm}
\end{figure}
\vspace{-0.4cm}