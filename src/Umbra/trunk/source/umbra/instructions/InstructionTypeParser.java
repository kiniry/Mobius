/*
 * @title       "Umbra"
 * @description "An editor for the Java bytecode and BML specifications"
 * @copyright   "(c) 2007-2009 University of Warsaw"
 * @license     "All rights reserved. This program and the accompanying
 *               materials are made available under the terms of the LGPL
 *               licence see LICENCE.txt file"
 */
package umbra.instructions;

import umbra.lib.BytecodeStrings;

/**
 * This class is the part of the byte code instruction parser which contributes
 * the parsing of various type representations.
 *
 * @author Tomasz Olejniczak (to236111@students.mimuw.edu.pl)
 * @author Aleksy Schubert (alx@mimuw.edu.pl)
 * @version a-01
 */
public class InstructionTypeParser extends InstructionNameParser {


  /**
   * The number of the last parsed mnemonic. The number is an index in the
   * array given as the parameter to {@link #swallowMnemonic(String[])}.
   * If no sensible mnemonic have been found the field has the value -1;
   */
  private int my_mnemonicno = -1;

  /**
   * This constructor sets the string to be parsed and resets the parser
   * so that it is ready to analyse the content. It relies on the
   * work in the superclass.
   *
   * @param a_line the line with the content to parse
   */
  protected InstructionTypeParser(final String a_line) {
    super(a_line);
  }

  /**
   * This method swallows a filed type descriptor. This method may not
   * advance the index in case the first character to be analysed is not the
   * proper first character of an array descriptor. We assume the string is not
   * finished before the method is called.
   *
   * As JVMS, 4.3.3 Method Descriptors says, a filed type descriptor is
   * a series of characters generated by the grammar:
   * <pre>
   * FiledType:
   *   BaseType
   *   ArrayType
   *   ObjectType ;
   * </pre>
   *
   * @return <code>true</code> when a return descriptor is successfully
   *   swallowed, <code>false</code> otherwise
   */
  public boolean swallowFieldType() {
    final String line = getLine();
    final int index = getIndex();
    boolean res = false;
    if (InstructionParserHelper.isBaseTypeDescriptor(
                        line.charAt(index))) {
      incIndex();
      res = true;
    } else {
      res =  swallowRefTypeDescriptor();
    }
    return res;
  }

  /**
   * This method swallows a reference type descriptor. This method may not
   * advance the index in case the first character to be analysed is not the
   * proper first character of an array descriptor. We assume the string is not
   * finished before the method is called.
   *
   * As JVMS, 4.3.3 Method Descriptors says, a filed type descriptor is
   * a series of characters generated by the grammar:
   * <pre>
   * FiledType:
   *   BaseType
   *   ArrayType
   *   ObjectType ;
   * </pre>
   * We omit here the BaseType case.
   *
   * @return <code>true</code> when a parameter descriptor is successfully
   *   swallowed, <code>false</code> otherwise
   */
  protected boolean swallowRefTypeDescriptor() {
    final String line = getLine();
    final int index = getIndex();
    if (InstructionParserHelper.isArrayTypeDescriptor(
                    line.charAt(index))) {
      incIndex();
      return swallowArrayTypeDescriptor();
    }
    if (InstructionParserHelper.isObjectTypeDescriptor(
                    line.charAt(index))) {
      incIndex();
      return swallowObjectTypeDescriptor();
    }
    return false;
  }

  /**
   * This method swallows an array type descriptor. This method may not
   * advance the index in case the first character to be analysed is not the
   * proper first character of an array descriptor. We assume the string is not
   * finished before the method is called.
   *
   * As JVMS, 4.3.3 Method Descriptors says, an object type descriptor is
   * a series of characters generated by the grammar:
   * <pre>
   * ArrayType:
   *   [ ComponentType ;
   * </pre>
   * we assume [ is already swallowed so we swallow here only the component
   * type.
   *
   * @return <code>true</code> when a return descriptor is successfully
   *   swallowed, <code>false</code> otherwise
   */
  private boolean swallowArrayTypeDescriptor() {
    boolean res = false;
    res = swallowFieldType(); //ComponentType :: = FieldType
    return res;
  }

  /**
   * This method swallows an object type descriptor. This method may not
   * advance the index in case the first character to be analysed is not the
   * proper first character of an object type descriptor. We assume the string
   * is not finished before the method is called.
   *
   * As JVMS, 4.3.3 Method Descriptors says, an object type descriptor is
   * a series of characters generated by the grammar:
   * <pre>
   * ObjectType:
   *   L &lt;classname&gt; ;
   * </pre>
   * we assume L is already swallowed so we swallow here only the class name.
   *
   * @return <code>true</code> when a return descriptor is successfully
   *   swallowed, <code>false</code> otherwise
   */
  private boolean swallowObjectTypeDescriptor() {
    final boolean res = swallowClassnameWithDelim('/');
    return res && swallowDelimiter(';');
  }

  /**
   * Checks if the line at the current position starts with a mnemonic from
   * the inventory.
   *
   * @param the_inventory the array of the mnemonics to be checked
   * @return the index to the entry in the inventory which contains the
   *   mnemonic or -1 in case no mnemonic from the inventory occurs
   */
  public int swallowMnemonic(final String[] the_inventory) {
    final String line = getLine();
    final int index = getIndex();
    my_mnemonicno  = -1;
    for (int i = 0; i < the_inventory.length; i++) {
      if (line.indexOf(the_inventory[i], index) == index) {
        if (my_mnemonicno == -1 ||
            the_inventory[my_mnemonicno].length() >  the_inventory[i].length())
          my_mnemonicno = i;
      }
    }
    if (my_mnemonicno >= 0) {
      moveIndex(the_inventory[my_mnemonicno].length());
    }
    return my_mnemonicno;
  }

  /**
   * Checks if the line at the current position starts with a given
   * mnemonic.
   *
   * @param a_mnemonic the mnemonics to be checked
   * @return true if the line starts with the given mnemonic, false
   * otherwise
   */
  public boolean swallowSingleMnemonic(final String a_mnemonic) {
    final String line = getLine();
    final int index = getIndex();
    if (line.indexOf(a_mnemonic, index) == index) {
      moveIndex(a_mnemonic.length());
      return true;
    }
    return false;
  }

  /**
   * This method swallows a type which may be followed by the array type
   * marker []. This is parsed as the grammar in BML Reference Manual
   * section Class Member Declarations:
   *
   *  arr-type ::= [ ownership-modifiers ] type [ dims ]
   *
   * TODO: Ownership modifiers are missing
   *
   * @return <code>true</code> when an array type is successfully
   *   swallowed, <code>false</code> otherwise
   */
  public boolean swallowArrType() {
    boolean res = true;
    if (swallowMnemonic(BytecodeStrings.PRIMITIVE_TYPE_NAMES) >= 0) {
      res = true;
    } else {
      res = res && swallowClassname();
    }
    res = res && swallowWhitespace();
    if (swallowDelimiter('[')) {
      res = res && swallowWhitespace();
      res = res && swallowDelimiter(']');
      res = res && swallowWhitespace();
    }
    return res;
  }

  /**
   * Returns the index of the last mnemonic found by
   * {@link #swallowMnemonic(String[])}. In case no mnemonic was found, the
   * method returns -1.
   *
   * @return the number of the last mnemonic found
   */
  public final int getMnemonic() {
    return my_mnemonicno;
  }

}
