static_diagram STATIC_DIAGRAM
component 
	cluster SENSOR
  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  -- SENSOR_CLUSTER cluster classes
  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   
		component
  			-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  			-- TYPE cluster classes
  			-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
  		cluster TYPE
 			component
	
			class LIGHT_SENSOR_TYPE 
		     indexing
		    	about:        "This class represents light sensor type.";
		  		title:        "LightSensorType";
		  		author:       "Dragan Stosic";
		  		copyright:    "none";
		  		organisation: "School of Computer Science and Informatics, UCD";
		  		date:         "2009/07/05";
		  		version:      "Revision: 1.00";
		  	feature{NONE}
		      make
		    
		    feature
		     -- The enum values, which are stored in an array, is constant and that 
		    -- all fields declared as that type are of that type.
		     array: SEQUENCE[INTEGER]
		        ensure
		          Result = old array;
		          Result /=Void;
		        end
		      
		      PCC: INTEGER		--The Photo-conductive Cells light sensor.
		        ensure
		          Result = 1;
		          Result /=Void;
		        end
		      
		      PEC: INTEGER		--The Photo-emissive Cells light sensor.
		        ensure
		          Result = 0;
		          Result /=Void;
		        end
		      
		      PJU: INTEGER		--The Photo-junction light sensor.
		        ensure
		          Result = 3;
		          Result /=Void;
		        end
		      
		      PVC: INTEGER		--The Photo-voltaic Cells light sensor.
		        ensure
		          Result = 2;
		          Result /=Void;
		        end
		    
		    feature
		      
		      legal_LightSensorType: BOOLEAN -> e: INTEGER
		        require
		          e /= Void;
		        ensure
		          Result /= Void;
		          (e = array.item(0) or e = array.item(1) or e = array.item(2) or e = array.item(3)) <-> Result;
		        end
		
		    invariant
		      legal_LightSensorType(PEC);
		      legal_LightSensorType(PCC);
		      legal_LightSensorType(PVC);
		      legal_LightSensorType(PJU);
		    end
    
		    class THERMISTOR_SENSOR_TYPE 
		    indexing
		    	about:        "This class represents an implementation of sensor types.";
		  		title:        "SensorType";
		  		author:       "Dragan Stosic";
		  		copyright:    "none";
		  		organisation: "School of Computer Science and Informatics, UCD";
		  		date:         "2009/07/05";
		  		version:      "Revision: 1.00";
		    feature{NONE}
		      make  
		    feature
		      -- The enum values, which are stored in an array, is constant and that 
		      -- all fields declared as that type are of that type.
		      array: SEQUENCE[INTEGER]
		        ensure
		          Result = old array;
		          Result /=Void;
		        end
		       -- The Negative temperature coefficient thermistor.
		       -- For NTCs, the resistance decreases with temperature.
		      NTC: INTEGER
		        ensure
		          Result = 0;
		          Result /=Void;
		        end
		      
		       -- The Positive temperature coefficient thermistor. 
			   -- For PTCs, the resistance increases with temperature.
		      PTC: INTEGER
		        ensure
		          Result = 1;
		          Result /=Void;
		        end
		       
		      legal_ThermSensorType: BOOLEAN -> e: INTEGER
		        require
		          e /= Void;
		        ensure
		          Result /= Void;
		          (e = array.item(0) or e = array.item(1)) <-> Result;
		        end
		    
		    invariant
		      legal_ThermSensorType(NTC);
		      legal_ThermSensorType(PTC);
		    end
		    
		    class ULTRASONIC_SENSOR_TYPE 
		    indexing
		    	about:        "This class represents ultrasonic sensor type.";
		  		title:        "UltrasonicSensorType";
		  		author:       "Dragan Stosic";
		  		copyright:    "none";
		  		organisation: "School of Computer Science and Informatics, UCD";
		  		date:         "2009/07/05";
		  		version:      "Revision: 1.00";
		    feature{NONE}
		      make
		    feature
		      -- The enum values, which are stored in an array, is constant and that 
		      -- all fields declared as that type are of that type.
		      array: SEQUENCE[INTEGER]
		        ensure
		          Result = old array;
		          Result /=Void;
		        end
		        
		      PROX: INTEGER			--The Proximity ultrasonic sensor.
		        ensure
		          Result = 0;
		          Result /=Void;
		        end
		      RANG: INTEGER			--The Ranging ultrasonic sensor.
		        ensure
		          Result = 1;
		          Result /=Void;
		        end
		        
		    
		      legal_UltraSensorType: BOOLEAN -> e: INTEGER
		        require
		          e /= Void;
		        ensure
		          Result /= Void;
		          (e = array.item(0) or e = array.item(1)) <-> Result;
		        end
		
		    invariant
		      legal_UltraSensorType(PROX);
		      legal_UltraSensorType(RANG);
		      end
    
		    class SOUND_SENSOR_TYPE 
		    indexing
		    	about:        "This class represents microphone sensor type.";
		  		title:        "SoundSensorType";
		  		author:       "Dragan Stosic";
		  		copyright:    "none";
		  		organisation: "School of Computer Science and Informatics, UCD";
		  		date:         "2009/07/05";
		  		version:      "Revision: 1.00";
		    feature{NONE}
		      make
		    -- The enum values, which are stored in an array, is constant and that 
		    -- all fields declared as that type are of that type.
		    feature
		       arraySound: SEQUENCE[INTEGER]
		        ensure
		          Result = old arraySound;
		          Result /=Void;
		        end
		      CCEM: INTEGER		--Condenser, capacitor or electrostatic microphone sensor.
		        ensure
		          Result = 8;
		          Result /=Void;
		        end
		      CMS: INTEGER		--The Carbon microphone sensor.
		        ensure
		          Result = 1;
		          Result /=Void;
		        end
		      DMS: INTEGER		--The Dynamic microphone sensor.
		        ensure
		          Result = 0;
		          Result /=Void;
		        end
		      FOS: INTEGER		--The Fiber optical microphone sensor.    
		        ensure
		          Result = 3;
		          Result /=Void;
		        end
		      LMS: INTEGER		--The Laser microphone sensor.
		        ensure
		          Result = 4;
		          Result /=Void;
		        end
		      LQMS: INTEGER		--The Liquid microphone sensor.
		        ensure
		          Result = 5;
		          Result /=Void;
		        end
		      MEMS: INTEGER		--The MEMS microphone sensor.
		        ensure
		          Result = 6;
		          Result /=Void;
		        end
		      PMS: INTEGER		--The Piezoelectric microphone sensor.
		        ensure
		          Result = 2;
		          Result /=Void;
		        end
		      SMS: INTEGER 		--The Speaker as microphone sensor.
		        ensure
		          Result = 7;
		          Result /=Void;
		        end
		      
		      legal_SoundSensorType: BOOLEAN -> e: INTEGER
		        require
		          e /= Void;
		        ensure
		          Result <-> (e = arraySound.item(0) or e = arraySound.item(1) or e = arraySound.item(2) or e = arraySound.item(3) or 
		          e = arraySound.item(4) or e = arraySound.item(5) or e = arraySound.item(6) or e = arraySound.item(7) or e = arraySound.item(8));
		       	  Result /= Void;
		        end
		
		    invariant
				legal_SoundSensorType(CMS);
				legal_SoundSensorType(PMS);
				legal_SoundSensorType(FOS);
				legal_SoundSensorType(LMS);
				legal_SoundSensorType(LQMS);
				legal_SoundSensorType(MEMS);
				legal_SoundSensorType(SMS);
				legal_SoundSensorType(CCEM);
				legal_SoundSensorType(DMS);  
		     end
		     
		    class PRESSURE_SENSOR_TYPE 
		    indexing
		    	about:        "This class represents pressure sensor type.";
		  		title:        "PressureSensorType";
		  		author:       "Dragan Stosic";
		  		copyright:    "none";
		  		organisation: "School of Computer Science and Informatics, UCD";
		  		date:         "2009/07/05";
		  		version:      "Revision: 1.00";
		    feature{NONE}
		      make
      
		    feature
		    -- The enum values, which are stored in an array, is constant and that 
		    -- all fields declared as that type are of that type.
		     array: SEQUENCE[INTEGER]
		        ensure
		          Result = old array;
		          Result /= Void;
		        end
		      
		      APS: INTEGER		-- The Absolute pressure sensor.
		        ensure
		          Result = 0;
		          Result /= Void;
		        end
		      
		      DPS: INTEGER		--The Differential pressure sensor.
		        ensure
		          Result = 3;
		          Result /= Void;
		        end
		      GPS: INTEGER		--The Gauge pressure sensor.
		        ensure
		          Result = 1;
		          Result /= Void;
		        end
		      SPS: INTEGER		--The Sealed pressure sensor.
		        ensure
		          Result = 4;
		          Result /= Void;
		        end
		      VPS: INTEGER		--The Vacuum pressure sensor.
		        ensure
		          Result = 2;
		          Result /= Void;
		        end
		    
		    
		      legal_PressSensorType: BOOLEAN -> e: INTEGER
		        require
		          e /= Void;
		        ensure
		          Result /= Void; 
		          (e = array.item(0) or e = array.item(1) or e = array.item(2) or e = array.item(3) or e = array.item(4)) <-> Result;
		        end
		   
		    invariant
		      legal_PressSensorType(APS);
		      legal_PressSensorType(GPS);
		      legal_PressSensorType(VPS);
		      legal_PressSensorType(DPS);
		      legal_PressSensorType(SPS);
		      end
		      
		      class ACCELEROMETER_SENSOR_TYPE 
			    indexing
			    	about:        "This class represents accelerometer sensor type.";
			  		title:        "AccelerometerSensorType";
			  		author:       "Dragan Stosic";
			  		copyright:    "none";
			  		organisation: "School of Computer Science and Informatics, UCD";
			  		date:         "2009/07/05";
			  		version:      "Revision: 1.00";
			    feature{NONE}
			      make
			    feature
			     -- The enum values, which are stored in an array, is constant and that 
			    -- all fields declared as that type are of that type.    
			      array: SEQUENCE[INTEGER]
			        ensure
			          Result = old array;
			          Result /= Void;
			        end
			        
			      MEMS: INTEGER		--The Surface Micromachined Capacitive.
			        ensure
			          Result = 2;
			          Result /= Void;
			        end
			      
			      PFPS: INTEGER		--The Piezo-film or piezoelectric sensor.
			        ensure
			          Result = 0;
			          Result /= Void;
			        end
			      
			      SMA: INTEGER		--The Shear Mode Accelerometer.
			        ensure
			          Result = 1;
			          Result /= Void;
			        end
			      
			      TCMOS: INTEGER	--Thermal (submicrometre CMOS process).
			        ensure
			          Result = 3;
			          Result /= Void;
			        end
			    
			      legal_AccSensorType: BOOLEAN -> e: INTEGER
			        require
			          e /= Void;
			        ensure
			          Result /= Void;
			          (e = array.item(0) or e = array.item(1) or 
			           e = array.item(2) or e = array.item(3)) <-> Result;
			        end
			
			    invariant
			      legal_AccSensorType(PFPS);
			      legal_AccSensorType(SMA);
			      legal_AccSensorType(MEMS);
			      legal_AccSensorType(TCMOS)
			      end
	            class SENSOR_TYPE 
			    indexing
			    	about:        "This class represents an implementation of sensor types.";
			  		title:        "SensorType";
			  		author:       "Dragan Stosic";
			  		copyright:    "none";
			  		organisation: "School of Computer Science and Informatics, UCD";
			  		date:         "2009/07/05";
			  		version:      "Revision: 1.00";
			    feature{NONE}
			      make
			    feature
			    -- The enum values, which are stored in an array, is constant and that 
			    -- all fields declared as that type are of that type.
			       array: SEQUENCE[INTEGER]
			        ensure
			          Result = old array;
			          Result /= Void;
			        end
			      ACCEL_X: INTEGER		-- Accelerometer sensor - X axe orientation.
			        ensure
			          Result = 5;
			          Result /= Void;
			        end
			      ACCEL_Y: INTEGER		-- Accelerometer sensor - Y axe orientation.
			        ensure
			          Result = 6;
			          Result /= Void;
			        end
			      ACCEL_Z: INTEGER		-- Accelerometer sensor - Z axe orientation.
			        ensure
			          Result = 7;
			          Result /= Void;
			        end
			      
			      LIGHT: INTEGER		-- The Light sensor type.
			        ensure
			          Result = 1;
			          Result /= Void;
			        end
			      PRESS: INTEGER		-- The Pressure sensor type.
			        ensure
			          Result = 2;
			          Result /= Void;
			        end
			      SOUND: INTEGER		-- The Sound sensor type.
			        ensure
			          Result = 3;
			          Result /= Void;
			        end
			      THERM: INTEGER		-- The Thermistor sensor type.
			        ensure
			          Result = 0;
			          Result /= Void;
			        end
			      ULTRA: INTEGER		-- The Ultrasonic sensor type.
			        ensure
			          Result = 4;
			          Result /= Void;
			        end
			    
			      legal_SensorType: BOOLEAN -> e: INTEGER
			        require
			          e /= Void;
			          e >= THERM;
			          e <= ACCEL_Z;
			        ensure
			          (e = array.item(0) or e = array.item(1) or 
			           e = array.item(2) or e = array.item(3) or 
			           e = array.item(4) or e = array.item(5) or 
			           e = array.item(6) or e = array.item(7)) <-> Result;
			           Result /= Void;
			        end
			        
			        isValidAxis: BOOLEAN -> e: INTEGER
			        require
			          e /= Void;
			          e >= ACCEL_X;
			          e <= ACCEL_Z;
			        ensure
			          Result /= Void;
			          (legal_SensorType(5) or legal_SensorType(6) or legal_SensorType(7)) <-> Result;
			        end
			
			    invariant
			      
			      legal_SensorType(THERM);
			      legal_SensorType(LIGHT);
			      legal_SensorType(PRESS);
			      legal_SensorType(SOUND);
			      legal_SensorType(ULTRA);
			      legal_SensorType(ACCEL_X);
			      legal_SensorType(ACCEL_Y);
			      legal_SensorType(ACCEL_Z);
			    end
		      
     
   end -- end cluster type
   
   deferred class ISENSOR
    indexing
    	about:        "This deffered class represents an abstract sensor.";
  		title:        "ISensor";
  		author:       "Dragan Stosic";
  		copyright:    "none";
  		organisation: "School of Computer Science and Informatics, UCD";
  		date:         "2009/07/05";
  		version:      "Revision: 1.00";
    feature
      mod_enabled: BOOLEAN      -- @.Model @.Instance boolean mod_enabled;
        ensure
          Result /= Void;
        end
      mod_max: INTEGER 			-- @.Model @.Instance int mod_max;
        ensure
          Result /= Void;
        end
      mod_mesure: JMLDATA_GROUP -- @.Model @.Instance JMLDataGroup mod_mesure;
        ensure
          Result /= Void;
        end
      mod_min: INTEGER			-- @.Model @.Instance int mod_min;
        ensure
          Result /= Void;
        end
      mod_type: INTEGER			-- @.Model @.Instance int mod_type;
        ensure
          Result /= Void;
        end
      mod_value: INTEGER		-- @.Model @.Instance int mod_value;
        ensure
          Result /= Void;
        end
      feature {SENSOR }
      
      deferred isEnabled : BOOLEAN --Are you enabled ?
        ensure
          Result /= Void;
        end
      
      deferred getMax: INTEGER --What is the maximal value for this component ?
        require 
           isEnabled;
        ensure
          Result /= Void;
          Result = mod_max;
        end
      
      deferred getMin: INTEGER --What is the minimal value for this component ?
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = mod_min;
        end
      deferred getSensorType: INTEGER --Which type of sensor are you?
        ensure
          Result /= Void;
          Result = mod_type;
        end
        
      deferred getValue: INTEGER --What is the measured value for this component ?
        require
          isEnabled ;
        ensure
          Result /= Void;
          Result = mod_value;
        end
      
      deferred measure --Measure current value.If sensor is not available notify client class.
        require
          isEnabled;
        ensure
          delta {mod_mesure, mod_value};
          mod_min <= mod_value;
          mod_value <= mod_max;
        end
      
      deferred setEnable -> theFlag: BOOLEAN		--Turn off / on this component.
        require
          theFlag /= Void;
        ensure
          delta mod_enabled;
          mod_enabled = theFlag;
        end
     
     invariant					--Measured value must to be between minimum and maximum value.
      mod_min <= mod_value;
      mod_value <= mod_max;
    end
    
    class MEASUREMENT_UNIT 
    indexing
      about: "This class represents typesafe implementation of measurement units.";
      title:        "MeasurementUnit";
  	  author:       "Dragan Stosic";
  	  copyright:    "none";
  	  organisation: "School of Computer Science and Informatics, UCD";
  	  date:         "2009/07/05";
  	  version:      "Revision: 1.00";
	
	feature{NONE}
      make    
    
    feature
    -- The enum values, which are stored in an array, is constant and that 
    -- all fields declared as that type are of that type.   
       array: SEQUENCE[INTEGER]
        ensure
          Result = old array;
          Result /=Void;
        end
        
      AMPER: INTEGER	--A -Amper (currency).
        ensure
          Result = 0;
          Result /=Void;
        end
      
      CELSIUS: INTEGER	--C - Temperature - Celsius.
        ensure
          Result = 5;
          Result /=Void;
        end
      
      DECIBEL: INTEGER	--dB - Decibel.
        ensure
          Result = 4;
          Result /=Void;
        end
      
      HERTZ: INTEGER	--Hz - Hertz (frequency).
        ensure
          Result = 3;
          Result /=Void;
        end
      
      LUX: INTEGER		--lux - light - lux.
        ensure
          Result = 7;
          Result /=Void;
        end
      
      MVOLT: INTEGER	--mV -mili Voltage (voltage).
        ensure
          Result = 2;
          Result /=Void;
        end
      
      PASCAL: INTEGER	--pa - pressure - Pascal.
        ensure
          Result = 6;
          Result /=Void;
        end
      
      VOLT: INTEGER		--V -Voltage (voltage).
        ensure
          Result = 1;
          Result /=Void;
        end
        
    
      legal_unit: BOOLEAN -> e: INTEGER
        require
          e /= Void;
        ensure
          Result /= Void;
          (e = array.item(0) or e = array.item(1) or 
           e = array.item(2) or e = array.item(3) or 
           e = array.item(4) or e = array.item(5) or 
           e = array.item(6) or e = array.item(7)) <-> Result;
        end

    invariant
      legal_unit(AMPER);
      legal_unit(VOLT);
      legal_unit(MVOLT);
      legal_unit(HERTZ);
      legal_unit(DECIBEL);
      legal_unit(CELSIUS);
      legal_unit(PASCAL);
      legal_unit(LUX);
      end
   
   effective class MISSING_SENSOR_EXCEPTION  
     indexing
      about: "Class implementation of sensor.MissingSensorException. Exception is used during measurement operations.";
      title:        "MissingChannelException";
  	  author:       "Dragan Stosic";
  	  copyright:    "none";
  	  organisation: "School of Computer Science and Informatics, UCD";
  	  date:         "2009/07/05";
  	  version:      "Revision: 1.00";
  	  
     feature
      make
      make0 -> message: STRING
        require
          message /= Void;
        end
        
      make1 -> cause: THROWABLE
        require
          cause /= Void;
        end
             
    feature{MISSING_SENSOR_EXCEPTION}
      serialVersionUID: INTEGER
      ensure
          Result = 221198;
          Result /=Void;
        end
    end
    
    effective class ULTRASONIC_SENSOR 
    indexing
      about: "This class represents Ultrasonic sensor.";
      title:        "UltrasonicSensor";
  	  author:       "Dragan Stosic";
  	  copyright:    "none";
  	  organisation: "School of Computer Science and Informatics, UCD";
  	  date:         "2009/07/05";
  	  version:      "Revision: 1.00";
  	  
  	  inherit ISENSOR
  	  
  	  feature 
    	make -> arr: SEQUENCE
        require
          arr /= Void;
        ensure
          delta {mod_enabled, mod_set};
          mod_enabled = true;
          for_all i:INTEGER such_that 0 <= i and i < arr.length it_holds a_set.item(i) = arr.item(i);
          mod_type = SensorType.ULTRA;
          a_type = UltrasonicSensorType.PROX;
          a_unit = MeasurementUnit.DECIBEL;
        end
        
    feature{NONE}
      index: INTEGER
        ensure
          Result /= Void;
        end
      MAX: INTEGER
        ensure
          Result = "-43";
        end
      MIN: INTEGER
        ensure
          Result = "-51";
        end
      setUltraSound -> index: INTEGER
        require
          index /= Void;
          index >= 0;
          index < mod_set.count;
        ensure
          delta mod_value;
          mod_min <= mod_value;
          mod_value <= mod_max;
          mod_max = -43;
          mod_min = -51;
          mod_type = SensorType.ULTRA;
          a_type = UltrasonicSensorType.PROX;
          a_unit = MeasurementUnit.DECIBEL;
        end
        
    feature
      a_sensType: INTEGER
        ensure
          Result = 4;
          Result /= Void;
        end
        
      a_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
        
      a_type: INTEGER
        ensure
          Result = 0;
          Result /= Void;
        end
      
      a_unit: INTEGER
        ensure
          Result = 4;
          Result /= Void;
        end
      
      enabled: BOOLEAN
        ensure
          Result /= Void;
        end
      
      getType: INTEGER
        require
          isEnabled;
        ensure
          Result = UltrasonicSensorType.PROX;
          Result /= Void;
        end
       
       getValue: INTEGER
		require
          isEnabled;        
        ensure
          Result /= Void;
         
        end
        
      getUnit: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = MeasurementUnit.DECIBEL;
        end
       
       isEnabled: BOOLEAN
        ensure
          Result /= Void;
        end
        
      mod_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      value: INTEGER
        ensure
          Result /= Void;
        end
      
      measure
        ensure
          mod_type = SensorType.ULTRA;
          a_type = UltrasonicSensorType.PROX;
          a_unit = MeasurementUnit.DECIBEL;
        end
      
      setEnable -> theFlag: BOOLEAN
        require
          theFlag /= Void;
        ensure
          mod_type = SensorType.ULTRA;
          a_type = UltrasonicSensorType.PROX;
          a_unit = MeasurementUnit.DECIBEL;
        end
      
      getMax: INTEGER
        ensure
          Result /= Void;
        end
      
      getMin: INTEGER
        ensure
          Result /= Void;
        end
      
      
      getSensorType: INTEGER
        ensure
          Result /= Void;
          Result = SensorType.ULTRA;
        end
        
      end
      
   effective class LIGHT_SENSOR 
    indexing
      about: "This class represents Light sensor.";
      title:        "LightSensor";
  	  author:       "Dragan Stosic";
  	  copyright:    "none";
  	  organisation: "School of Computer Science and Informatics, UCD";
  	  date:         "2009/07/05";
  	  version:      "Revision: 1.00";
  	  
  	 inherit ISENSOR
  	      
    feature{NONE}
      index: INTEGER
        ensure
          Result /= Void;
        end
      MAX: INTEGER
        ensure
          Result = 1000;
        end
      MIN: INTEGER
        ensure
          Result = 0;
        end
      setLight
        -> index: INTEGER
        require
          index /= Void;
          index >= 0;
          index < mod_set.count;
        ensure
          delta mod_value;
          mod_min <= mod_value;
          mod_value <= mod_max;
          mod_max = 1000;
          mod_min = 0;
          mod_type = SensorType.LIGHT;
          a_type = LightSensorType.PEC;
          a_unit = MeasurementUnit.LUX;
        end
        
    feature
      make -> arr: SEQUENCE
        require
          arr /= Void;
        ensure
          delta {mod_enabled, mod_set};
          mod_enabled = true;
          for_all i:INTEGER such_that 0 <= i and i < arr.length it_holds a_set.item(i) = arr.item(i);
          -- ((\forall  int i,;0 <= i && i < arr.length;arr[i] == a_set[i]));
          mod_max = 1000;
          mod_min = 0;
          mod_type = SensorType.LIGHT;
          a_type = LightSensorType.PEC;
          a_unit = MeasurementUnit.LUX;
        end
      
      a_sensType: INTEGER
        ensure
          Result = 1;
          Result /= Void;
        end
      
      a_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      a_type: INTEGER
        ensure
          Result = 0;
          Result /= Void;
        end
      
      a_unit: INTEGER
        ensure
          Result = 7;
          Result /= Void;
        end
      
      enabled: BOOLEAN
        ensure
          Result /= Void;
        end
      
      getType: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = LightSensorType.PEC;
        end
      
      getUnit: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = MeasurementUnit.LUX;
        end
      
      getValue: INTEGER
		require
          isEnabled;        
        ensure
          Result /= Void;
        end
      
       isEnabled: BOOLEAN
        ensure
          Result /= Void;
        end
        
      mod_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      value: INTEGER
        ensure
          Result /= Void;
        end
      measure
        ensure
          mod_max = 1000;
          mod_min = 0;
          mod_type = SensorType.LIGHT;
          a_type = LightSensorType.PEC;
          a_unit = MeasurementUnit.LUX;
        end
      
      setEnable -> theFlag: BOOLEAN
        require
          theFlag /= Void;
        ensure
          mod_max = 1000;
          mod_min = 0;
          mod_type = SensorType.LIGHT;
          a_type = LightSensorType.PEC;
          a_unit = MeasurementUnit.LUX;
        end
      
      getMax: INTEGER
        ensure
          Result /= Void;
        end
      
      getMin: INTEGER
        ensure
          Result /= Void;
        end
      
      getSensorType: INTEGER
        ensure
          Result /= Void;
          Result = SensorType.LIGHT;
        end
    end
    
    effective class PRESSURE_SENSOR
       indexing
      about: "This class represents pressure sensor.";
      title:        "PressureSensor";
  	  author:       "Dragan Stosic";
  	  copyright:    "none";
  	  organisation: "School of Computer Science and Informatics, UCD";
  	  date:         "2009/07/05";
  	  version:      "Revision: 1.00";
  	 
  	 inherit ISENSOR
  	  
  	  
    feature{NONE}
      index: INTEGER
        ensure
          Result /= Void;
        end
      MAX: INTEGER
        ensure
          Result = 115000;
        end
      MIN: INTEGER
        ensure
          Result = 15000;
        end
      setPressure -> index: INTEGER
        require
          index /= Void;
          index >= 0;
          index < mod_set.count;
        ensure
          delta mod_value;
          mod_min <= mod_value;
          mod_value <= mod_max;
          mod_max = 115000;
          mod_min = 15000;
          mod_type = SensorType.PRESS;
          a_type = PressureSensorType.APS;
          a_unit = MeasurementUnit.PASCAL;
        end
    
    feature
      make -> arr: SEQUENCE
        require
          arr /= Void;
        ensure
          delta {mod_enabled, mod_set};
          mod_enabled = true;
          for_all i:INTEGER such_that 0 <= i and i < arr.length it_holds a_set.item(i) = arr.item(i);
          -- ((\forall  int i,;0 <= i && i < arr.length;arr[i] == a_set[i]));
          mod_max = 115000;
          mod_min = 15000;
          mod_type = SensorType.PRESS;
          a_type = PressureSensorType.APS;
          a_unit = MeasurementUnit.PASCAL;
        end
      
      a_sensType: INTEGER
        ensure
          Result = 2;
          Result /= Void;
        end
      
      a_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      a_type: INTEGER
        ensure
          Result = 0;
          Result /= Void;
        end
      
      a_unit: INTEGER
        ensure
          Result = 6;
          Result /= Void;
        end
      
      enabled: BOOLEAN
        ensure
          Result /= Void;
        end
      
      getType: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = PressureSensorType.APS;
        end
      
      getUnit: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = MeasurementUnit.PASCAL;
        end
        
        getValue: INTEGER
		require
          isEnabled;        
        ensure
          Result /= Void;
        end
      
       isEnabled: BOOLEAN
        ensure
          Result /= Void;
        end
        
      mod_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      value: INTEGER
        ensure
          Result /= Void;
        end
      
      measure
        ensure
          mod_max = 115000;
          mod_min = 15000;
          mod_type = SensorType.PRESS;
          a_type = PressureSensorType.APS;
          a_unit = MeasurementUnit.PASCAL;
        end
      
      setEnable -> theFlag: BOOLEAN
        require
          theFlag /= Void;
        ensure
          mod_max = 115000;
          mod_min = 15000;
          mod_type = SensorType.PRESS;
          a_type = PressureSensorType.APS;
          a_unit = MeasurementUnit.PASCAL;
        end
      
      getMax: INTEGER
        ensure
          Result /= Void;
        end
      
      getMin: INTEGER
        ensure
          Result /= Void;
        end
      
      getSensorType: INTEGER
        ensure
          Result /= Void;
          Result = SensorType.PRESS;
        end
      end
      
    effective class SOUND_SENSOR 
      indexing
      about: "This class represents sound sensor.";
      title:        "SoundSensor";
  	  author:       "Dragan Stosic";
  	  copyright:    "none";
  	  organisation: "School of Computer Science and Informatics, UCD";
  	  date:         "2009/07/05";
  	  version:      "Revision: 1.00";
  	  
  	  inherit ISENSOR
  	  
    feature{NONE}
      index: INTEGER
        ensure
          Result /= Void;
        end
      MAX: INTEGER
        ensure
          Result = -31;
          Result /= Void;
        end
      MIN: INTEGER
        ensure
          Result = -39;
          Result /= Void;
        end
      setSound
        -> index: INTEGER
        require
          index /= Void;
          index >= 0;
          index < mod_set.count;
        ensure
          delta mod_value;
          mod_min <= mod_value;
          mod_value <= mod_max;
          mod_max = -31;
          mod_min = -39;
          mod_type = SensorType.SOUND;
          a_type = SoundSensorType.DMS;
          a_unit = MeasurementUnit.DECIBEL;
        end
    feature
      make -> arr: SEQUENCE
        require
          arr /= Void;
        ensure
          delta {mod_enabled, mod_set};
          mod_enabled = true;
          for_all i:INTEGER such_that 0 <= i and i < arr.length it_holds a_set.item(i) = arr.item(i);
          -- ((\forall  int i,;0 <= i && i < arr.length;arr[i] == a_set[i]));
          mod_max = -31;
          mod_min = -39;
          mod_type = SensorType.SOUND;
          a_type = SoundSensorType.DMS;
          a_unit = MeasurementUnit.DECIBEL;
        end
        
      a_sensType: INTEGER
        ensure
          Result = 3;
          Result /= Void;
        end
      
      a_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      a_type: INTEGER
        ensure
          Result = 0;
          Result /= Void;
        end
      
      a_unit: INTEGER
        ensure
          Result = 4;
          Result /= Void;
        end
      
      enabled: BOOLEAN
        ensure
          Result /= Void;
        end
      
      getType: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = SoundSensorType.DMS;
        end
      
      getUnit: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = MeasurementUnit.DECIBEL;
        end
      
      getValue: INTEGER
		require
          isEnabled;        
        ensure
          Result /= Void;
        end
      
       isEnabled: BOOLEAN
        ensure
          Result /= Void;
        end
      
      mod_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      value: INTEGER
        ensure
          Result /= Void;
        end
      
      measure
        ensure
          
          mod_type = SensorType.SOUND;
          a_type = SoundSensorType.DMS;
          a_unit = MeasurementUnit.DECIBEL;
        end
      
      setEnable -> theFlag: BOOLEAN
        require
          theFlag /= Void;
        ensure
          mod_type = SensorType.SOUND;
          a_type = SoundSensorType.DMS;
          a_unit = MeasurementUnit.DECIBEL;
        end
      
      getMax: INTEGER
        ensure
          Result /= Void;
        end
      
      getMin: INTEGER
        ensure
          Result /= Void;
        end
      
      getSensorType: INTEGER
        ensure
          Result /= Void;
          Result = SensorType.SOUND;
        end
      end
      
      effective class THERMISTOR_SENSOR
       indexing
      about: "This class represents thermistor sensor.";
      title:        "ThermistorSensor";
  	  author:       "Dragan Stosic";
  	  copyright:    "none";
  	  organisation: "School of Computer Science and Informatics, UCD";
  	  date:         "2009/07/05";
  	  version:      "Revision: 1.00";
  	
  	inherit ISENSOR
  	
    feature{NONE}
      index: INTEGER
        ensure
          Result /= Void;
        end
      MAX: INTEGER
        ensure
          Result = 127;
        end
      MIN: INTEGER
        ensure
          Result = -55;
        end
      setTemp
        -> index: INTEGER
        require
          index /= Void;
          index >= 0;
          index < mod_set.count;
        ensure
          delta mod_value;
          mod_min <= mod_value;
          mod_value <= mod_max;
          mod_max = 127;
          mod_min = -55;
          mod_type = SensorType.THERM;
          a_type = ThermistorSensorType.NTC;
          a_unit = MeasurementUnit.CELSIUS;
        end
    
    feature
      make:THERMISTOR_SENSOR -> arr: SEQUENCE
        require
          arr /= Void;
        ensure
          delta {mod_enabled, mod_set};
          mod_enabled = true;
          for_all i:INTEGER such_that 0 <= i and i < arr.length it_holds a_set.item(i) = arr.item(i);
          -- ((\forall  int i,;0 <= i && i < arr.length;arr[i] == a_set[i]));
          mod_max = 127;
          mod_min = -55;
          mod_type = SensorType.THERM;
          a_type = ThermistorSensorType.NTC;
          a_unit = MeasurementUnit.CELSIUS;
        end
        
      a_sensType: INTEGER
        ensure
          Result = 0;
          Result /= Void;
        end
        
      a_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      a_type: INTEGER
        ensure
          Result = 0;
          Result /= Void;
        end
      
      a_unit: INTEGER
        ensure
          Result = 5;
          Result /= Void;
        end
      
      enabled: BOOLEAN
        ensure
          Result /= Void;
        end
      
      getType: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = ThermistorSensorType.NTC;
        end
      
      getUnit: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = MeasurementUnit.CELSIUS;
        end
      
      getValue: INTEGER
		require
          isEnabled;        
        ensure
          Result /= Void;
        end
      
       isEnabled: BOOLEAN
        ensure
          Result /= Void;
        end
        
      mod_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      value: INTEGER
        ensure
          Result /= Void;
        end
      
      measure
        ensure
          mod_max = 127;
          mod_type = SensorType.THERM;
          a_type = ThermistorSensorType.NTC;
          a_unit = MeasurementUnit.CELSIUS;
        end
      
      setEnable -> theFlag: BOOLEAN
        require
          theFlag /= Void;
        ensure
          mod_max = 127;
          mod_type = SensorType.THERM;
          a_type = ThermistorSensorType.NTC;
          a_unit = MeasurementUnit.CELSIUS;
        end
      
      getMax: INTEGER
        ensure
          Result /= Void;
        end
      
      getMin: INTEGER
        ensure
          Result /= Void;
        end
      
      getSensorType: INTEGER
        ensure
          Result /= Void;
          Result = SensorType.THERM;
        end
      end
      
      
     effective class AXIS_ACCELEROMETER_SENSOR 
    indexing
      about: "An accelerometer measures the acceleration it experiences",
      		 "relative to freefall. Single model is available",
        	 "to detect magnitude and direction of the acceleration as",
        	 "a vector quantity, and can be used to sense orientation,",
             "vibration and shock.";
      title:        "AxisAccelerometerSensor";
  	  author:       "Dragan Stosic";
  	  copyright:    "none";
  	  organisation: "School of Computer Science and Informatics, UCD";
  	  date:         "2009/07/05";
  	  version:      "Revision: 1.00";
  	  
    inherit
      ISENSOR
    
    feature{NONE}
      index: INTEGER
        ensure
          Result /= Void;
        end
      MAX: INTEGER
        ensure
          Result = 15300;
        end
      MIN: INTEGER
        ensure
          Result = 14700;
        end
      setVoltage -> index: INTEGER
        require
          index /= Void;
          index >= 0;
          index < mod_set.count;
        ensure
          delta mod_value;
          mod_min <= mod_value;
          mod_value <= mod_max;
          mod_max = 15300;
          mod_min = 14700;
          a_unit = MeasurementUnit.MVOLT;
          a_type = AccelerometerSensorType.PFPS;
        end
      
    feature
      make -> arr: SEQUENCE -> type: INTEGER
        require
          arr /= Void;
          type /= Void;
          SensorType.isValidAxis(type);
        ensure
          delta {mod_enabled, mod_set, mod_type};
          mod_type = type;
          mod_enabled = true;
          for_all i:INTEGER such_that 0 <= i and i < arr.length it_holds a_set.item(i) = arr.item(i);
          -- ((\forall  int i,;0 <= i && i < arr.length;arr[i] == a_set[i]));
          mod_max = 15300;
          mod_min = 14700;
          a_unit = MeasurementUnit.MVOLT;
          a_type = AccelerometerSensorType.PFPS;
          SensorType.isValidAxis(mod_type);
        end
        
      a_sensType: INTEGER
        ensure
          Result /= Void;
        end
      
      a_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      a_type: INTEGER
        ensure
          Result = 0;
          Result /= Void;
        end
      
      a_unit: INTEGER
        ensure
          Result = 2;
          Result /= Void;
        end
      
      enabled: BOOLEAN
        ensure
          Result /= Void;
        end
      
      getType: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = AccelerometerSensorType.PFPS;
        end
      
      getUnit: INTEGER
        require
          isEnabled;
        ensure
          Result /= Void;
          Result = MeasurementUnit.MVOLT;
        end
      
      getValue: INTEGER
		require
          isEnabled;        
        ensure
          Result /= Void;
        end
      
       isEnabled: BOOLEAN
        ensure
          Result /= Void;
        end
        
        
      mod_set: SEQUENCE[INTEGER]
        ensure
          Result /= Void;
        end
      
      value: INTEGER
        ensure
          Result /= Void;
        end
      
      measure
        ensure
          mod_max = 15300;
          mod_min = 14700;
          a_unit = MeasurementUnit.MVOLT;
          a_type = AccelerometerSensorType.PFPS;
        end
      
      setEnable -> theFlag: BOOLEAN
        require
          theFlag /= Void;
        ensure
          mod_max = 15300;
          mod_min = 14700;
          a_unit = MeasurementUnit.MVOLT;
          a_type = AccelerometerSensorType.PFPS;
        end
        
      getMax: INTEGER
        ensure
          Result /= Void;
        end
      
      getMin: INTEGER
        ensure
          Result /= Void;
        end
      
       getSensorType: INTEGER
        ensure
          Result /= Void;
          SensorType.isValidAxis(Result);
        end

    invariant
       SensorType.isValidAxis(a_sensType);
    end
    
       
	effective class SENSOR_BUILDER 
	    indexing
	      about: "Represents an sensor builder implementation.";
	       title:        "SensorBuilder";
  	       author:       "Dragan Stosic";
  	       copyright:    "none";
  	       organisation: "School of Computer Science and Informatics, UCD";
  	       date:         "2009/08/08";
  	       version:      "Revision: 1.00";
  	    feature
	      sensors: LIST
	        ensure
	          Result /= Void;
	        end
	      mod_size: INTEGER
	        ensure
	          Result /= Void;
	        end
	      
	      initialize
	        require
	          mod_size = 0;
	         
	        ensure
	          mod_size = 1;
	          mod_size <= 8;
	        end
	      
	      getSensor: ISENSOR -> typeIndex: INTEGER
	        require
	          typeIndex /= Void;
	          mod_size = 8;
	          typeIndex >= 0;
	          typeIndex <= 7;
	          SensorType.legal_SensorType(typeIndex);
	        ensure
	          Result /= Void;
	        end
	        
	        make
	        ensure
	          delta sensors;
	          mod_size <= 8;
	        end
	        
	        feature{NONE}
	        
	      g_arr: SEQUENCE[INTEGER]
	        ensure
	          Result /= Void;
	        end
	      g_sensor: ISENSOR
	        ensure
	          Result /= Void;
	        end
	    
	     feature{NONE}
	      
	      createAxesXSensor
	        require
	          mod_size = 5;
	        ensure
	          mod_size = old(mod_size) + 1;
	          (g_sensor.mod_enabled = false <-> g_arr.count = 0);
	          mod_size <= 8;
	        end
	      createAxesYSensor
	        require
	          mod_size = 6;
	        ensure
	          mod_size = old(mod_size) + 1;
	          (g_sensor.mod_enabled = false <-> g_arr.count = 0);
	          mod_size <= 8;
	        end
	      createAxesZSensor
	        require
	          mod_size = 7;
	        ensure
	          mod_size = old(mod_size) + 1;
	          (g_sensor.mod_enabled = false <-> g_arr.count = 0);
	          mod_size <= 8;
	        end
	        
	      createLightSensor
	        require
	          mod_size = 1;
	        ensure
	          mod_size = old(mod_size) + 1;
	          (g_sensor.mod_enabled = false <-> g_arr.count = 0);
	          mod_size <= 8;
	        end
	        
	      createPressureSensor
	        require
	          mod_size = 3;
	        ensure
	          mod_size = old(mod_size) + 1;
	          (g_sensor.mod_enabled = false <-> g_arr.count = 0);
	          mod_size <= 8;
	        end
	        
	      createSoundSensor
	        require
	          mod_size = 2;
	        ensure
	          mod_size = old(mod_size) + 1;
	          (g_sensor.mod_enabled = false <-> g_arr.count = 0);
	          mod_size <= 8;
	        end
	        
	      createThermistorSensor
	        require
	          mod_size = 0;
	        ensure
	          mod_size = old(mod_size) + 1;
	          (not g_sensor.isEnabled <-> g_arr.count = 0);
	          mod_size <= 8;
	        end
	      
	      createUltrasonicSensor
	        require
	          mod_size = 4;
	        ensure
	          mod_size = old(mod_size) + 1;
	          (g_sensor.mod_enabled = false <-> g_arr.count = 0);
	          mod_size <= 8;
	        end 
	        invariant 
	        not sensors.containsNull;       
	 end 
      
 end -- end cluster Sensor 
end -- end static-diagram
