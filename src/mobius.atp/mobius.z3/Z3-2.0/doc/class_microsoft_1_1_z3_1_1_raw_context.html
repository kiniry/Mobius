 <HTML>
    <HEAD>
    <meta name="author" content="Leonardo de Moura" />
    <meta name="author" content="Nikolaj Bjorner" />
    <meta name="description" content="Z3: SMT solver" />
    <meta name="keywords" content="decision procedure, theorem prover, SMT-LIB, SMTLIB, SMT LIB, SMT Solver, SMTCOMP, SMT-COMP, SAT solver, formal methods, constraint solver, software verification, hardware verification" />
      <TITLE>Z3: SMT solver</TITLE>
      <LINK HREF="z3.css" REL="stylesheet" TYPE="text/css">
      <LINK href="tabs.css" rel="stylesheet" type="text/css">
    </HEAD>
<BODY BGCOLOR="#FFFFFF">
<table class="centered-small">
  <tr>
    <th><a href="index.html"><span>Home</span></a></th>
    <th> &bull; </th>
    <th><a href="documentation.html"><span>Docs</span></a></th>
    <th> &bull; </th>
    <th><a href="download.html"><span>Download</span></a></th>
    <th> &bull; </th>
    <th><a href="mail.html"><span>Mail</span></a></th>
    <th> &bull; </th>
    <th><a href="faq.html"><span>FAQ</span></a></th>
    <th> &bull; </th>
    <th><a href="awards.html"><span>Awards</span></a></th>
    <th> &bull; </th>
    <th><a href="status.html"><span>Status</span></a></th>
    <th> &bull; </th>
    <th><a href="http://research.microsoft.com"><span>MSR</span></a></th>
  </tr>
</table>
<p class="Z3Title"><img align="middle" src="z3.png" alt="Z3" /> An Efficient SMT Solver</p>
<!-- Generated by Doxygen 1.5.9 -->
  <div class="navpath"><b>Microsoft</b>::<b>Z3</b>::<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html">RawContext</a>
  </div>
<div class="contents">
<h1>RawContext Class Reference<br>
<small>
[<a class="el" href="group__mapi.html">Managed (.NET) API</a>]</small>
</h1><!-- doxytag: class="Microsoft::Z3::RawContext" --><!-- doxytag: inherits="MarshalByRefObject" -->Z3 API object.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#fb2f967c3369cea3be9967c33403e7c7">RawContext</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_config.html">Config</a>^config)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a logical context using the given configuration.  <a href="#fb2f967c3369cea3be9967c33403e7c7"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Tracing and logging</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#f622c78d9a22842b33472d6c1d27b1b4">TraceToFile</a> (String^trace_file)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable trace messages to a file.  <a href="#f622c78d9a22842b33472d6c1d27b1b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#fa21ce7520ec673cb5c14141d0dd1b55">TraceToStdErr</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable trace messages to a standard error.  <a href="#fa21ce7520ec673cb5c14141d0dd1b55"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#1eec1643da6c92de4e9a5398cb39bb19">TraceToStdOut</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable trace messages to a standard output.  <a href="#1eec1643da6c92de4e9a5398cb39bb19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#03ea692af0111fc416c43a565f17e938">TraceOff</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable trace messages.  <a href="#03ea692af0111fc416c43a565f17e938"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#e767eef7c521b644401e58a4adfb11a6">EnableDebugTrace</a> (String^tag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable debug tracing of tagged log.  <a href="#e767eef7c521b644401e58a4adfb11a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#96aec8fa83ecdac0ac136c0cf6c74fe8">OpenLog</a> (String^filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Log assertions to a file.  <a href="#96aec8fa83ecdac0ac136c0cf6c74fe8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#260b097dfa36861173bf7fdfd6594cf7">AppendLog</a> (String^string)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append instruction or comment to log with assertion.  <a href="#260b097dfa36861173bf7fdfd6594cf7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#b100e8973788ce566b11cda8bb09fc32">CloseLog</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close file with logged assertions.  <a href="#b100e8973788ce566b11cda8bb09fc32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#74d274e8e6fc3ccc4ac39a375c0cc536">ToggleWarningMessages</a> (bool enabled)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable or disable warning messages sent to the console out/error.  <a href="#74d274e8e6fc3ccc4ac39a375c0cc536"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Symbols</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#4e1f9e0325bac5897d7d4099eca72ed0">MkSymbol</a> (int i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a Z3 symbol using an intege or a string.  <a href="#4e1f9e0325bac5897d7d4099eca72ed0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="09d8a08a1734819f7a353936f46e56a1"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSymbol" ref="09d8a08a1734819f7a353936f46e56a1" args="(String^s)" -->
<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkSymbol</b> (String^s)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Types</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#5111a4b70cadfbdb76491c889b57a312">MkSort</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a free (uninterpreted) type using the given name (symbol).  <a href="#5111a4b70cadfbdb76491c889b57a312"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="49a159fb80840f71583471f066a1fe23"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSort" ref="49a159fb80840f71583471f066a1fe23" args="(String^s)" -->
SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkSort</b> (String^s)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="646a11b4d9e0f97d2adb789f5ab6daa0"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSort" ref="646a11b4d9e0f97d2adb789f5ab6daa0" args="(int i)" -->
SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkSort</b> (int i)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#5a24352b12189b45134064790859850a">MkBoolSort</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the boolean type.  <a href="#5a24352b12189b45134064790859850a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#04bf543bb7b59788f7b7d40d4738648b">MkIntSort</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an integer type.  <a href="#04bf543bb7b59788f7b7d40d4738648b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#9fc32a94ce1e1064c04f7fe4e1678e81">MkRealSort</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a real type.  <a href="#9fc32a94ce1e1064c04f7fe4e1678e81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#df17186c4a5ece22ff7d95d1b6722e7d">MkBvSort</a> (unsigned sz)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a bit-vector type of the given size.  <a href="#df17186c4a5ece22ff7d95d1b6722e7d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#011fb26d01e3b5e696f5148da6d53d91">MkArraySort</a> (SortPtr domain, SortPtr range)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an array type.  <a href="#011fb26d01e3b5e696f5148da6d53d91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#6af9bcdeb7cc9617f480af2b70a269c0">MkTupleSort</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^mk_tuple_name, array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&gt;^field_names, array&lt; SortPtr &gt;^field_types,[Runtime::InteropServices::Out] FuncDeclPtr%mk_tuple_decl,[Runtime::InteropServices::In][Runtime::InteropServices::Out] array&lt; FuncDeclPtr &gt;^proj_decl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a tuple type.  <a href="#6af9bcdeb7cc9617f480af2b70a269c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ac675d78632779299d9bcb91fae7419c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkTupleSort" ref="ac675d78632779299d9bcb91fae7419c" args="(String^mk_tuple_name, array&lt; String^&gt;^field_names, array&lt; SortPtr &gt;^field_types,[Runtime::InteropServices::Out] FuncDeclPtr%mk_tuple_decl,[Runtime::InteropServices::In][Runtime::InteropServices::Out] array&lt; FuncDeclPtr &gt;^proj_decl)" -->
SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkTupleSort</b> (String^mk_tuple_name, array&lt; String^&gt;^field_names, array&lt; SortPtr &gt;^field_types,[Runtime::InteropServices::Out] FuncDeclPtr%mk_tuple_decl,[Runtime::InteropServices::In][Runtime::InteropServices::Out] array&lt; FuncDeclPtr &gt;^proj_decl)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#72b2b9b3967c4638276bdccbdb0c9471">MkEnumerationSort</a> (String^name, array&lt; String^&gt;^enum_names, array&lt; FuncDeclPtr &gt;^enum_consts, array&lt; FuncDeclPtr &gt;^enum_testers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create an enumeration type.  <a href="#72b2b9b3967c4638276bdccbdb0c9471"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#0180bc7478b5c26f1d2c145187c31130">MkListSort</a> (String^name, SortPtr elem_sort,[Runtime::InteropServices::Out] FuncDeclPtr%nil_decl,[Runtime::InteropServices::Out] FuncDeclPtr%is_nil_decl,[Runtime::InteropServices::Out] FuncDeclPtr%cons_decl,[Runtime::InteropServices::Out] FuncDeclPtr%is_cons_decl,[Runtime::InteropServices::Out] FuncDeclPtr%head_decl,[Runtime::InteropServices::Out] FuncDeclPtr%tail_decl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create list sort.  <a href="#0180bc7478b5c26f1d2c145187c31130"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#30d1032d60ebd18e9d99d5c4191ab7b8">MkConstructor</a> (String^name, String^tester, array&lt; String^&gt;^field_names, array&lt; SortPtr &gt;^field_sorts, array&lt; unsigned &gt;^field_refs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create constructor object for datatype declarations. The object must be disposed with manually.  <a href="#30d1032d60ebd18e9d99d5c4191ab7b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#d778d157f274c72a2e88b806b41df89c">GetConstructor</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>^c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">retrieve constructor function declaration.  <a href="#d778d157f274c72a2e88b806b41df89c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#97a7320cd3d9a7d77f52bf789f5c8839">GetTester</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>^c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">retrieve test function for constructor.  <a href="#97a7320cd3d9a7d77f52bf789f5c8839"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">array&lt; FuncDeclPtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#b3ed56054afb442b0c26b073104c330e">GetAccessors</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>^c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">retrieve accessors for datatype.  <a href="#b3ed56054afb442b0c26b073104c330e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#db386d1976b2c6587844fe995444c46f">MkDataType</a> (String^name, array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>^&gt;^constructors)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create datatype sort.  <a href="#db386d1976b2c6587844fe995444c46f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">array&lt; SortPtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a44dbeb0d3495a206820ffa9ce249a0a">MkDataTypes</a> (array&lt; String^&gt;^names, array&lt; array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>^&gt;^&gt;^constructors)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create datatype sorts.  <a href="#a44dbeb0d3495a206820ffa9ce249a0a"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constants and Applications</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#2bb4cecfa5619dbf2ed8f53d3b2f5749">MkFuncDecl</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^s, array&lt; SortPtr &gt;^domain, SortPtr range)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare a constant or function.  <a href="#2bb4cecfa5619dbf2ed8f53d3b2f5749"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f8cba05a2404c3c1e665ac951566eca4"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkFuncDecl" ref="f8cba05a2404c3c1e665ac951566eca4" args="(String^s, array&lt; SortPtr &gt;^domain, SortPtr range)" -->
FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkFuncDecl</b> (String^s, array&lt; SortPtr &gt;^domain, SortPtr range)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ea3b49f96cf036380d14a048ff676475"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkConstDecl" ref="ea3b49f96cf036380d14a048ff676475" args="(Symbol^s, SortPtr ty)" -->
FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkConstDecl</b> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^s, SortPtr ty)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6088cc8ce911201229b364f1341b5aaf"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkFuncDecl" ref="6088cc8ce911201229b364f1341b5aaf" args="(Symbol^s, SortPtr domain, SortPtr range)" -->
FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkFuncDecl</b> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^s, SortPtr domain, SortPtr range)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6c579ac1d186ef01534d6a396740a527"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkFuncDecl" ref="6c579ac1d186ef01534d6a396740a527" args="(Symbol^s, SortPtr d1, SortPtr d2, SortPtr range)" -->
FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkFuncDecl</b> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^s, SortPtr d1, SortPtr d2, SortPtr range)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="93fedafeae678cac892223d88d29f7ff"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkConstDecl" ref="93fedafeae678cac892223d88d29f7ff" args="(String^s, SortPtr ty)" -->
FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkConstDecl</b> (String^s, SortPtr ty)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6f7d1875b95ff5851f5d5efd593a99cc"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkFuncDecl" ref="6f7d1875b95ff5851f5d5efd593a99cc" args="(String^s, SortPtr domain, SortPtr range)" -->
FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkFuncDecl</b> (String^s, SortPtr domain, SortPtr range)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bb5e3934f525cf1f6bf1e10887bdbd95"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkFuncDecl" ref="bb5e3934f525cf1f6bf1e10887bdbd95" args="(String^s, SortPtr d1, SortPtr d2, SortPtr range)" -->
FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkFuncDecl</b> (String^s, SortPtr d1, SortPtr d2, SortPtr range)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">AppPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8a8ba273adfaadc01562b901524fd50">MkApp</a> (FuncDeclPtr d, array&lt; TermPtr &gt;^args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a constant or function application.  <a href="#a8a8ba273adfaadc01562b901524fd50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1a7ce2ea730c4e1e5819919524b10782"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkApp" ref="1a7ce2ea730c4e1e5819919524b10782" args="(FuncDeclPtr d, TermPtr arg)" -->
AppPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkApp</b> (FuncDeclPtr d, TermPtr arg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="015b7c8c3603e50e4d16c1c40c09ecbf"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkApp" ref="015b7c8c3603e50e4d16c1c40c09ecbf" args="(FuncDeclPtr d, TermPtr arg1, TermPtr arg2)" -->
AppPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkApp</b> (FuncDeclPtr d, TermPtr arg1, TermPtr arg2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5325f64b80a469970b7687ceab1e5cc2"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkApp" ref="5325f64b80a469970b7687ceab1e5cc2" args="(FuncDeclPtr d, TermPtr arg1, TermPtr arg2, TermPtr arg3)" -->
AppPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkApp</b> (FuncDeclPtr d, TermPtr arg1, TermPtr arg2, TermPtr arg3)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">AppPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#4119e0d04b9b4b8e95969e261b06aab7">MkConst</a> (FuncDeclPtr d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare and create a constant.  <a href="#4119e0d04b9b4b8e95969e261b06aab7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1b0770d3a236d24800348b296eed2e8a"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkConst" ref="1b0770d3a236d24800348b296eed2e8a" args="(String^s, SortPtr ty)" -->
AppPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkConst</b> (String^s, SortPtr ty)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9e7cd6efbeb680da34246288ddb7dcfc"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkConst" ref="9e7cd6efbeb680da34246288ddb7dcfc" args="(Symbol^s, SortPtr ty)" -->
AppPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkConst</b> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^s, SortPtr ty)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#5251d6fc152aea96eac0e9e702dad707">MkFreshFuncDecl</a> (String^prefix, array&lt; SortPtr &gt;^domain, SortPtr range)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare a fresh constant or function.  <a href="#5251d6fc152aea96eac0e9e702dad707"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#abc8469e3803c5413a1a69c7cd001672">MkFreshConst</a> (String^prefix, SortPtr ty)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Declare and create a fresh constant.  <a href="#abc8469e3803c5413a1a69c7cd001672"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ebcce24f39e8ce68930346c48ac5a57f">MkLabel</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^name, bool pos, TermPtr fml)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create labeled formula.  <a href="#ebcce24f39e8ce68930346c48ac5a57f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#b462a1d684499a2265ee02801dfcb4f4">MkTrue</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>true</code>.  <a href="#b462a1d684499a2265ee02801dfcb4f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#4c138a08931900ebb7396484a6294cff">MkFalse</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>false</code>.  <a href="#4c138a08931900ebb7396484a6294cff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#b5b455baaffd7f2bf2a9508f801819de">MkEq</a> (TermPtr l, TermPtr r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>l = r</code>.  <a href="#b5b455baaffd7f2bf2a9508f801819de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#89bdd6aba66dab2a90592cea3263eb74">MkDistinct</a> (array&lt; TermPtr &gt;^args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>distinct(args[0], ..., args[args.Length-1])</code>.  <a href="#89bdd6aba66dab2a90592cea3263eb74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#fc672bf3d4167000f8511454ef05a83d">MkNot</a> (TermPtr arg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>not(a)</code>.  <a href="#fc672bf3d4167000f8511454ef05a83d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#4c1882945cd1a8462070e5d92e7a6b93">MkIte</a> (TermPtr t1, TermPtr t2, TermPtr t3)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing an if-then-else: <code>ite(t1, t2, t3)</code>.  <a href="#4c1882945cd1a8462070e5d92e7a6b93"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#f0019c9b938cbfc228d538500e25ab1f">MkIff</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>t1 iff t2</code>.  <a href="#f0019c9b938cbfc228d538500e25ab1f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#fcbf82213943aa0a30efb51dbf81b7dd">MkImplies</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>t1 implies t2</code>.  <a href="#fcbf82213943aa0a30efb51dbf81b7dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#80631b59bd60e34b88cdc676274334b0">MkXor</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>t1 xor t2</code>.  <a href="#80631b59bd60e34b88cdc676274334b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#8793a422c6c2d7b34000cc0032a4cdc4">MkAnd</a> (array&lt; TermPtr &gt;^args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>args[0] and ... and args[args.Length-1]</code>.  <a href="#8793a422c6c2d7b34000cc0032a4cdc4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e9f066dd8874ff5cf46e98000e7a8b70"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkAnd" ref="e9f066dd8874ff5cf46e98000e7a8b70" args="(TermPtr arg1, TermPtr arg2)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkAnd</b> (TermPtr arg1, TermPtr arg2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#72a8f73bed309b8924dd49eba903bb24">MkOr</a> (array&lt; TermPtr &gt;^args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>args[0] or ... or args[args.Length-1]</code>.  <a href="#72a8f73bed309b8924dd49eba903bb24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d8c4978b2f3002563c99febd28722fda"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkOr" ref="d8c4978b2f3002563c99febd28722fda" args="(TermPtr arg1, TermPtr arg2)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkOr</b> (TermPtr arg1, TermPtr arg2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#5668c488c12e405f662807b4f47860da">MkAdd</a> (array&lt; TermPtr &gt;^args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>args[0] + ... + args[args.Length-1]</code>.  <a href="#5668c488c12e405f662807b4f47860da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="05f1e9e13ed994d2d6b3da91f3ae53d6"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkAdd" ref="05f1e9e13ed994d2d6b3da91f3ae53d6" args="(TermPtr arg1, TermPtr arg2)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkAdd</b> (TermPtr arg1, TermPtr arg2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a20eacf8d7fa0e446c1081e5ff01de77">MkMul</a> (array&lt; TermPtr &gt;^args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>args[0] * ... * args[args.Length-1]</code>.  <a href="#a20eacf8d7fa0e446c1081e5ff01de77"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f98a6c9470b5f2f39f418ce49f29e619"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkMul" ref="f98a6c9470b5f2f39f418ce49f29e619" args="(TermPtr arg1, TermPtr arg2)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkMul</b> (TermPtr arg1, TermPtr arg2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#01178a7c619ac2bd6c2e4d4f3da743d2">MkSub</a> (array&lt; TermPtr &gt;^args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>args[0] - ... - args[args.Length - 1]</code>.  <a href="#01178a7c619ac2bd6c2e4d4f3da743d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0f7f345609875c3279b167a92e9e4df3"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSub" ref="0f7f345609875c3279b167a92e9e4df3" args="(TermPtr arg1, TermPtr arg2)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkSub</b> (TermPtr arg1, TermPtr arg2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#4314bcfc4435b1f79028bc11b8774c28">MkUnaryMinus</a> (TermPtr arg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an AST node representing <code>- arg</code>.  <a href="#4314bcfc4435b1f79028bc11b8774c28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#e7f8e2e8eb754c5a87fa3faa51ff8baf">MkDiv</a> (TermPtr arg1, TermPtr arg2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create integer or real division.  <a href="#e7f8e2e8eb754c5a87fa3faa51ff8baf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#5a9f33467a473c739edac3721e0d56ea">MkMod</a> (TermPtr arg1, TermPtr arg2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create integer modulus.  <a href="#5a9f33467a473c739edac3721e0d56ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#5e8abfb87c0e9eb2be93a85af185038e">MkRem</a> (TermPtr arg1, TermPtr arg2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create integer remainder.  <a href="#5e8abfb87c0e9eb2be93a85af185038e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a817a455803ab79b220b0182b48e2ae5">MkLt</a> (TermPtr arg1, TermPtr arg2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create less than.  <a href="#a817a455803ab79b220b0182b48e2ae5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a4993b3a46531ed7c4924d64185344d2">MkLe</a> (TermPtr arg1, TermPtr arg2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create less than or equal to.  <a href="#a4993b3a46531ed7c4924d64185344d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#5935871bfbeda8fcd6bc467d8d49afc2">MkGt</a> (TermPtr arg1, TermPtr arg2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create greater than.  <a href="#5935871bfbeda8fcd6bc467d8d49afc2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#7a08b71116843992a1078d9df3889f09">MkGe</a> (TermPtr arg1, TermPtr arg2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create greater than or equal to.  <a href="#7a08b71116843992a1078d9df3889f09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#fb42590f21003d708f6dacbb95a7c995">MkInt2Real</a> (TermPtr arg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Coerce integer term to real type.  <a href="#fb42590f21003d708f6dacbb95a7c995"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#45b8b6397e45ac3fc6b38e873eed9d33">MkBvNot</a> (TermPtr t1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitwise negation.  <a href="#45b8b6397e45ac3fc6b38e873eed9d33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#add6a00031fb92a88ca6c177d4d75509">MkBvAnd</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitwise and.  <a href="#add6a00031fb92a88ca6c177d4d75509"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#472170308fc0ce228ad1ee1b683811cd">MkBvOr</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitwise or.  <a href="#472170308fc0ce228ad1ee1b683811cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#684ce5c64067b6d5d4cddfbfe32789b4">MkBvXor</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitwise exclusive-or.  <a href="#684ce5c64067b6d5d4cddfbfe32789b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#5d58dfc570dde7e49faab8ed4dcfbfc7">MkBvNand</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitwise nand.  <a href="#5d58dfc570dde7e49faab8ed4dcfbfc7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a486a9f49b3fc395f37b56f0975a243b">MkBvNor</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitwise nor.  <a href="#a486a9f49b3fc395f37b56f0975a243b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#0112b7f61d18dcd15369566cdcf4b05f">MkBvXnor</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitwise xnor.  <a href="#0112b7f61d18dcd15369566cdcf4b05f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#e21724e2d70e5aec94cfa59726565063">MkBvNeg</a> (TermPtr t1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Standard two's complement unary minus.  <a href="#e21724e2d70e5aec94cfa59726565063"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#30237a1d6603428640b6db89d5d157fa">MkBvAdd</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Standard two's complement addition.  <a href="#30237a1d6603428640b6db89d5d157fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ea836bb8f5dcec3f401d77538e31e248">MkBvSub</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Standard two's complement subtraction.  <a href="#ea836bb8f5dcec3f401d77538e31e248"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#e5585802bf0ff4f5188bfbe1fd361470">MkBvMul</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Standard two's complement multiplication.  <a href="#e5585802bf0ff4f5188bfbe1fd361470"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#98ee5b832fa8f1a44998a2541bf4114c">MkBvUdiv</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsigned division.  <a href="#98ee5b832fa8f1a44998a2541bf4114c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#e96a3f936b75c53d7ab8eed094eb7b94">MkBvSdiv</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two's complement signed division.  <a href="#e96a3f936b75c53d7ab8eed094eb7b94"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#30f13a71debd51968bc2129eaa26121d">MkBvUrem</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsigned remainder.  <a href="#30f13a71debd51968bc2129eaa26121d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#1db91c0489ac65927dc14613e0b2225b">MkBvSrem</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two's complement signed remainder (sign follows dividend).  <a href="#1db91c0489ac65927dc14613e0b2225b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#094b16beaa982ef3500633b3482d2603">MkBvSmod</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two's complement signed remainder (sign follows divisor).  <a href="#094b16beaa982ef3500633b3482d2603"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#71e25df68e31503191875d9348c9f823">MkBvUlt</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsigned less than.  <a href="#71e25df68e31503191875d9348c9f823"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#8352294e2808ce534fc83ec39bca8fbd">MkBvSlt</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two's complement signed less than.  <a href="#8352294e2808ce534fc83ec39bca8fbd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a434742064f523ecf5a7e13a113df86b">MkBvUle</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsigned less than or equal to.  <a href="#a434742064f523ecf5a7e13a113df86b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#c37363c17a7308be4ca999068da16fbb">MkBvSle</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two's complement signed less than or equal to.  <a href="#c37363c17a7308be4ca999068da16fbb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#cb5149b9f7b1d823cd93ed6f43db5a17">MkBvUge</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsigned greater than or equal to.  <a href="#cb5149b9f7b1d823cd93ed6f43db5a17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#27a2d12f9e8d5639fa86b4d0997e2b17">MkBvSge</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two's complement signed greater than or equal to.  <a href="#27a2d12f9e8d5639fa86b4d0997e2b17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#fcb8b1208ec0cc2c1579c29158b3815e">MkBvUgt</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsigned greater than.  <a href="#fcb8b1208ec0cc2c1579c29158b3815e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#013910a4fa70b37878520b4400b1c107">MkBvSgt</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two's complement signed greater than.  <a href="#013910a4fa70b37878520b4400b1c107"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#faba9154d1be03ec6d738951e94d37cb">MkBvConcat</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Concatenate the given bit-vectors.  <a href="#faba9154d1be03ec6d738951e94d37cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#c2c8940627f740c9ec3b637ef2031887">MkBvExtract</a> (unsigned high, unsigned low, TermPtr t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract the bits <code>high</code> down to <code>low</code> from a bitvector of size <code>m</code> to yield a new bitvector of size <code>n</code>, where <code>n = high - low + 1</code>.  <a href="#c2c8940627f740c9ec3b637ef2031887"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#f94e12dbe34a66f358baebe8ef6848fc">MkBvSignExt</a> (unsigned i, TermPtr t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sign-extend of the given bit-vector to the (signed) equivalent bitvector of size <code>m+i</code>, where <code>m</code> is the size of the given bit-vector.  <a href="#f94e12dbe34a66f358baebe8ef6848fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#dd245de4256b820ef7d66ce58fd43385">MkBvZeroExt</a> (unsigned i, TermPtr t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extend the given bit-vector with zeros to the (unsigned) equivalent bitvector of size <code>m+i</code>, where <code>m</code> is the size of the given bit-vector.  <a href="#dd245de4256b820ef7d66ce58fd43385"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#484c128e627a79c8af7fcbb531b0ba39">MkBvShl</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shift left.  <a href="#484c128e627a79c8af7fcbb531b0ba39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#2de5b050301845c2fa902a8a910db8ed">MkBvLshr</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Logical shift right.  <a href="#2de5b050301845c2fa902a8a910db8ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#4e8836887c24503234e99a94dd31a660">MkBvAshr</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Arithmetic shift right.  <a href="#4e8836887c24503234e99a94dd31a660"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#decfc831ae6c9135828e3095b27a4956">MkBvRotateLeft</a> (unsigned i, TermPtr t1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate bits of <code>t1</code> to the left <code>i</code> times.  <a href="#decfc831ae6c9135828e3095b27a4956"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#3df09da772a462d74c9f08546a44562b">MkBvRotateRight</a> (unsigned i, TermPtr t1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate bits of <code>t1</code> to the right <code>i</code> times.  <a href="#3df09da772a462d74c9f08546a44562b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#711b2b4ca79395d1d56820b7b3f9b3cc">MkBv2Int</a> (TermPtr t1, bool is_signed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert bit vector to integer.  <a href="#711b2b4ca79395d1d56820b7b3f9b3cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#43be2bceee8a6d4a870733196a149612">MkInt2Bv</a> (unsigned size, TermPtr t1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert integer to bit vector.  <a href="#43be2bceee8a6d4a870733196a149612"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#202fffba746c16499d216354e97ac74b">MkBvAddNoOverflow</a> (TermPtr t1, TermPtr t2, bool is_signed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that addition does not overflow.  <a href="#202fffba746c16499d216354e97ac74b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#421fc4943889a1c10d2dddbdaac5d09d">MkBvAddNoUnderflow</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that addition does not underflow.  <a href="#421fc4943889a1c10d2dddbdaac5d09d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#44065d4fa565d6efa0f351f266c61c58">MkBvSubNoOverflow</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that subtraction does not overflow.  <a href="#44065d4fa565d6efa0f351f266c61c58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#3386aa55309ead169a54aeeed1cef0d6">MkBvSubNoUnderflow</a> (TermPtr t1, TermPtr t2, bool is_signed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that subtraction does not underflow.  <a href="#3386aa55309ead169a54aeeed1cef0d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#c537f6c8529718162b4a16a926f145f8">MkBvSDivNoOverflow</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that division does not overflow.  <a href="#c537f6c8529718162b4a16a926f145f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#7dcdbe9ddac5ccf9744174f4a20aac19">MkBvNegNoOverflow</a> (TermPtr t1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that negation does not overflow.  <a href="#7dcdbe9ddac5ccf9744174f4a20aac19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#688f2a2cb04cb30f68dca62c6477f14b">MkBvMulNoOverflow</a> (TermPtr t1, TermPtr t2, bool is_signed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that multiplication does not overflow.  <a href="#688f2a2cb04cb30f68dca62c6477f14b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#036fccd286efdc90134941defd6a1df8">MkBvMulNoUnderflow</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that multiplication does not underflow.  <a href="#036fccd286efdc90134941defd6a1df8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#f0606dc016c08c4086d43d43ed45794c">MkArraySelect</a> (TermPtr a, TermPtr i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array read.  <a href="#f0606dc016c08c4086d43d43ed45794c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aed9edcce01c069fcb982262ae01e14d">MkArrayStore</a> (TermPtr a, TermPtr i, TermPtr v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array update.  <a href="#aed9edcce01c069fcb982262ae01e14d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#3fcbf7757a9ffdb56c4bdd145c145246">MkArrayMap</a> (FuncDeclPtr d, array&lt; TermPtr &gt;^args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array map.  <a href="#3fcbf7757a9ffdb56c4bdd145c145246"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#b5341894979c077ef1ad93ef67691c2a">MkArrayConst</a> (SortPtr domain, TermPtr v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant array.  <a href="#b5341894979c077ef1ad93ef67691c2a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#c645da9e615bc4e20515ef3cd8f74893">MkArrayDefault</a> (TermPtr a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the array default.  <a href="#c645da9e615bc4e20515ef3cd8f74893"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Sets</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#4fd038edb773b86952a3f4890d6bb0f5">MkSetSort</a> (SortPtr ty)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create Set type.  <a href="#4fd038edb773b86952a3f4890d6bb0f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#e3a1a555a0fce2e8c1dfdfb863b56216">MkEmptySet</a> (SortPtr ty)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the empty set.  <a href="#e3a1a555a0fce2e8c1dfdfb863b56216"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#71d300776d9303680e79f784a2644e4c">MkFullSet</a> (SortPtr ty)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the full set.  <a href="#71d300776d9303680e79f784a2644e4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#443543c80f0ace5c902df3589d3154c4">MkSetAdd</a> (TermPtr set, TermPtr elem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an element to a set.  <a href="#443543c80f0ace5c902df3589d3154c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#99a686c0e68a6862f47f066eac39f84e">MkSetDel</a> (TermPtr set, TermPtr elem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an element to a set.  <a href="#99a686c0e68a6862f47f066eac39f84e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#72da2154689afc36a91ba955e9ccf081">MkSetUnion</a> (array&lt; TermPtr &gt;^sets)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take the union of a arrays of sets.  <a href="#72da2154689afc36a91ba955e9ccf081"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3a621809e5409417fe6c15543391378c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetUnion" ref="3a621809e5409417fe6c15543391378c" args="(TermPtr set1, TermPtr set2)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkSetUnion</b> (TermPtr set1, TermPtr set2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#1bb3e567ae8090d8a659ad556c083e32">MkSetIntersect</a> (array&lt; TermPtr &gt;^sets)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take the intersection of a arrays of sets.  <a href="#1bb3e567ae8090d8a659ad556c083e32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ea3abcabd7822795387885d0f8dff43c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetIntersect" ref="ea3abcabd7822795387885d0f8dff43c" args="(TermPtr set1, TermPtr set2)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkSetIntersect</b> (TermPtr set1, TermPtr set2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#d51d6429450362ce9dc9f476b86d22e1">MkSetDifference</a> (TermPtr arg1, TermPtr arg2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take the set difference between two sets.  <a href="#d51d6429450362ce9dc9f476b86d22e1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#e33216f5018efff4077640204c219dc2">MkSetComplement</a> (TermPtr arg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Take the complement of a set.  <a href="#e33216f5018efff4077640204c219dc2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#8449281ead0996eccbe5867d3b6ca96c">MkSetMember</a> (TermPtr elem, TermPtr set)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check for set membership.  <a href="#8449281ead0996eccbe5867d3b6ca96c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#c05b3fbb60eecb46617782cd53e2b293">MkSetSubset</a> (TermPtr arg1, TermPtr arg2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check for subsetness of sets.  <a href="#c05b3fbb60eecb46617782cd53e2b293"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Injective functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#1c4f013234b21f0c4599f3c44fb778fb">MkInjectiveFunction</a> (String^name, array&lt; SortPtr &gt;^domain, SortPtr range)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create injective function.  <a href="#1c4f013234b21f0c4599f3c44fb778fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="47bac504c0044a005351db1ff40ddf28"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkInjectiveFunction" ref="47bac504c0044a005351db1ff40ddf28" args="(Symbol^name, array&lt; SortPtr &gt;^domain, SortPtr range)" -->
FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkInjectiveFunction</b> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^name, array&lt; SortPtr &gt;^domain, SortPtr range)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Numerals</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#d04ee26dbb08422102bdc1189e293196">MkNumeral</a> (String^numeral, SortPtr ty)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a numeral of a given type.  <a href="#d04ee26dbb08422102bdc1189e293196"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d87299eff0469717b9d4e4605ced2644"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkNumeral" ref="d87299eff0469717b9d4e4605ced2644" args="(int n, SortPtr ty)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkNumeral</b> (int n, SortPtr ty)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="68c052546b106dd7ce0958b7fc8f8ae1"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkNumeral" ref="68c052546b106dd7ce0958b7fc8f8ae1" args="(unsigned n, SortPtr ty)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkNumeral</b> (unsigned n, SortPtr ty)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6740ac1dd6beaa381b5aa8c0e3e9e7f8"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkNumeral" ref="6740ac1dd6beaa381b5aa8c0e3e9e7f8" args="(__int64 n, SortPtr ty)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkNumeral</b> (__int64 n, SortPtr ty)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="051610b11665f400cf4aa443b4b8c6fc"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkNumeral" ref="051610b11665f400cf4aa443b4b8c6fc" args="(unsigned __int64 n, SortPtr ty)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkNumeral</b> (unsigned __int64 n, SortPtr ty)</td></tr>

<tr><td colspan="2"><div class="groupHeader">Quantifiers</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PatternPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#8a941e796cdc983459602aeb22178d8a">MkPattern</a> (array&lt; TermPtr &gt;^terms)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a pattern for quantifier instantiation.  <a href="#8a941e796cdc983459602aeb22178d8a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#2e1ef04d234928c64248ce7eaf73502a">MkBound</a> (unsigned index, SortPtr ty)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a bound variable.  <a href="#2e1ef04d234928c64248ce7eaf73502a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#d7d64f035d843f300b7fffcfb148e1fe">MkForall</a> (unsigned weight, array&lt; PatternPtr &gt;^patterns, array&lt; SortPtr &gt;^types, array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&gt;^names, TermPtr body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a forall formula.  <a href="#d7d64f035d843f300b7fffcfb148e1fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#810d22421101b29aef8864c6e2aa3a3f">MkForall</a> (unsigned weight, array&lt; PatternPtr &gt;^patterns, array&lt; SortPtr &gt;^types, array&lt; String^&gt;^names, TermPtr body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a forall formula.  <a href="#810d22421101b29aef8864c6e2aa3a3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#8c6471e0eb3e8a5a5a6c7c7e9e5bd8d7">MkForall</a> (unsigned weight, array&lt; AppPtr &gt;^bound, array&lt; PatternPtr &gt;^patterns, TermPtr body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a forall formula.  <a href="#8c6471e0eb3e8a5a5a6c7c7e9e5bd8d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#60c9cdf799990ce4ed2dd7f8caa914e9">MkExists</a> (unsigned weight, array&lt; PatternPtr &gt;^patterns, array&lt; SortPtr &gt;^types, array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&gt;^names, TermPtr body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an exists formula. Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#d7d64f035d843f300b7fffcfb148e1fe" title="Create a forall formula.">MkForall</a>.  <a href="#60c9cdf799990ce4ed2dd7f8caa914e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="29b180bdd8f7dab8a79fef081d6c6e83"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkExists" ref="29b180bdd8f7dab8a79fef081d6c6e83" args="(unsigned weight, array&lt; PatternPtr &gt;^patterns, array&lt; SortPtr &gt;^types, array&lt; String^&gt;^names, TermPtr body)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkExists</b> (unsigned weight, array&lt; PatternPtr &gt;^patterns, array&lt; SortPtr &gt;^types, array&lt; String^&gt;^names, TermPtr body)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bbd2d3966ec0fa20840339907a090a85"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkExists" ref="bbd2d3966ec0fa20840339907a090a85" args="(unsigned weight, array&lt; AppPtr &gt;^bound, array&lt; PatternPtr &gt;^patterns, TermPtr body)" -->
TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>MkExists</b> (unsigned weight, array&lt; AppPtr &gt;^bound, array&lt; PatternPtr &gt;^patterns, TermPtr body)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#3f6fe0d5e63e2aec779538fef2669a3c">MkQuantifier</a> (bool is_forall, unsigned weight, array&lt; PatternPtr &gt;^patterns, array&lt; TermPtr &gt;^no_patterns, array&lt; SortPtr &gt;^types, array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&gt;^names, TermPtr body)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a quantifier with no-pattern directives.  <a href="#3f6fe0d5e63e2aec779538fef2669a3c"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessors</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__mapi.html#g05812818de02fb4b202d7513ce50745d">SymbolKind</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#0e5e137439c1194fe6ceadd130c32844">GetSymbolKind</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>SymbolKind.Int</code> if the symbol was constructed using MkIntSymbol, and <code>SymbolKind.String</code> if the symbol was constructed using MkStringSymbol.  <a href="#0e5e137439c1194fe6ceadd130c32844"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#fabdd4c7aa7001151713568aaf4e27b9">GetSymbolInt</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the symbol int value.  <a href="#fabdd4c7aa7001151713568aaf4e27b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#63af55d0bc85edc1a08938fe94d059c3">GetSymbolString</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the symbol name.  <a href="#63af55d0bc85edc1a08938fe94d059c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#95167a48c7a40a4acf32631a527758da">IsEq</a> (TermPtr t1, TermPtr t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return <code>true</code> if the two given AST nodes are equal.  <a href="#95167a48c7a40a4acf32631a527758da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__mapi.html#g4b115a647ef9efa7c5fdfd8f376050dc">TermKind</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a92cc97ea26a5d7ca06f7337a750c964">GetTermKind</a> (TermPtr a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the kind of the given AST.  <a href="#a92cc97ea26a5d7ca06f7337a750c964"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__mapi.html#gc25bfa6294c0cc5dcf0e42e4bfa2b425">DeclKind</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#b5bd163cb2dff9a325fd961d413a8c22">GetDeclKind</a> (FuncDeclPtr d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the kind of the built-in operator.  <a href="#b5bd163cb2dff9a325fd961d413a8c22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">array&lt; <a class="el" href="interface_microsoft_1_1_z3_1_1_i_raw_parameter.html">IRawParameter</a>^&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ccdc25299d9fe8c5a7fa0889c46cbdf5">GetDeclParameters</a> (FuncDeclPtr d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return auxiliary parameters associated with the built-in operator. For example, the operator for bit-vector extraction uses two parameters, the upper and lower bit-index for extraction.  <a href="#ccdc25299d9fe8c5a7fa0889c46cbdf5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#6aebc549137b2458e195ebe6d9d4c4ba">GetAppDecl</a> (AppPtr a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the declaration of a constant or function application.  <a href="#6aebc549137b2458e195ebe6d9d4c4ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">array&lt; TermPtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#b021d6b4e58c052472ec3cd6d2dd0fac">GetAppArgs</a> (AppPtr a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the arguments of an application. If <code>t</code> is an constant, then array is empty.  <a href="#b021d6b4e58c052472ec3cd6d2dd0fac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ea8f522b8fd2fd2d7e48296b5c7a9512">GetNumeralString</a> (TermPtr a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of a numeric ast.  <a href="#ea8f522b8fd2fd2d7e48296b5c7a9512"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a00bb4f5b7abc37cf6c24e1c8ce08f4a">GetNumeralInt</a> (TermPtr v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a>, but only succeeds if the value can fit in a machine int. Throw InvalidArgument if the call fails.  <a href="#a00bb4f5b7abc37cf6c24e1c8ce08f4a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a33fb76faef085c88e4b3a44af23d55f"></a><!-- doxytag: member="Microsoft::Z3::RawContext::TryGetNumeralInt" ref="a33fb76faef085c88e4b3a44af23d55f" args="(TermPtr v,[Runtime::InteropServices::Out] int%i)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>TryGetNumeralInt</b> (TermPtr v,[Runtime::InteropServices::Out] int%i)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#e40d08d8f9fc05ea8bb0b035f0da9f09">GetNumeralUInt</a> (TermPtr v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a>, but only succeeds if the value can fit in a machine unsigned int. Throw InvalidArgument if the call fails.  <a href="#e40d08d8f9fc05ea8bb0b035f0da9f09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dc6de1542027f11650d56b413be165a5"></a><!-- doxytag: member="Microsoft::Z3::RawContext::TryGetNumeralUInt" ref="dc6de1542027f11650d56b413be165a5" args="(TermPtr v,[Runtime::InteropServices::Out] unsigned int%u)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>TryGetNumeralUInt</b> (TermPtr v,[Runtime::InteropServices::Out] unsigned int%u)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned __int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a78f20144c40600d63c87ebc8bd5d85e">GetNumeralUInt64</a> (TermPtr v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a>, but only succeeds if the value can fit in a machine unsigned long long int. Throw InvalidArgument if the call fails.  <a href="#a78f20144c40600d63c87ebc8bd5d85e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="016b21c53ad240403d13aa61b6c12072"></a><!-- doxytag: member="Microsoft::Z3::RawContext::TryGetNumeralUInt64" ref="016b21c53ad240403d13aa61b6c12072" args="(TermPtr v,[Runtime::InteropServices::Out] unsigned __int64%u)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>TryGetNumeralUInt64</b> (TermPtr v,[Runtime::InteropServices::Out] unsigned __int64%u)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">__int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#016d026fcaf6c2299687ae4407533390">GetNumeralInt64</a> (TermPtr v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a>, but only succeeds if the value can fit in a machine long long int. Throw InvalidArgument if the call fails.  <a href="#016d026fcaf6c2299687ae4407533390"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d50671878167c87c5aecaff5b7925b63"></a><!-- doxytag: member="Microsoft::Z3::RawContext::TryGetNumeralInt64" ref="d50671878167c87c5aecaff5b7925b63" args="(TermPtr v,[Runtime::InteropServices::Out] __int64%i)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>TryGetNumeralInt64</b> (TermPtr v,[Runtime::InteropServices::Out] __int64%i)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__mapi.html#g2a6d3c91705945a27b9f264add662179">LBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#74ec06b79df90539553d1c53c2a02bdd">GetBoolValue</a> (TermPtr a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the Boolean value of a truth constant. Return LBool::Undef if a is not a boolean constant (true or false).  <a href="#74ec06b79df90539553d1c53c2a02bdd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#780dfcb5088965199c45d8a958a489c0">TryGetArrayValue</a> (TermPtr a,[Runtime::InteropServices::Out] <a class="el" href="class_microsoft_1_1_z3_1_1_raw_array_value.html">RawArrayValue</a>^%av)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return decomposed sequence of stores as an array value.  <a href="#780dfcb5088965199c45d8a958a489c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#17499379d443ca6ee0bf3770d18135af">GetVarIndex</a> (TermPtr a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the index of a de-Brujin bound variable.  <a href="#17499379d443ca6ee0bf3770d18135af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RawQuantifier&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#4dc623c04dfdeaef8d17f88034aab270">GetQuantifier</a> (TermPtr a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return components of a quantifier.  <a href="#4dc623c04dfdeaef8d17f88034aab270"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">array&lt; TermPtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#029d7befda8b1da2f597b3c9d3b5b998">GetPatternTerms</a> (PatternPtr p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return array of terms in the pattern.  <a href="#029d7befda8b1da2f597b3c9d3b5b998"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#7c62d9f2161dec8b726996082f05875c">GetDeclName</a> (FuncDeclPtr d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the constant declaration name as a symbol.  <a href="#7c62d9f2161dec8b726996082f05875c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#16e84dca2b1d23ce89a98276e943eb59">GetSortName</a> (SortPtr ty)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the type name as a symbol.  <a href="#16e84dca2b1d23ce89a98276e943eb59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#d563e3268d5034c9147c98190c4327d6">GetSort</a> (TermPtr a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the type of an AST node.  <a href="#d563e3268d5034c9147c98190c4327d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">array&lt; SortPtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#612c60dae8dbc7cc04ebf8a299d7f78d">GetDomain</a> (FuncDeclPtr d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the domain of a function declaration.  <a href="#612c60dae8dbc7cc04ebf8a299d7f78d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#84d2dfcc3f579dcce0820cad12686f42">GetRange</a> (FuncDeclPtr d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the range of the given declaration.  <a href="#84d2dfcc3f579dcce0820cad12686f42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__mapi.html#g7664c6569cf130a5d166ec8c8dc27101">SortKind</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#c105e2a1c10a81fcbbda92338319b821">GetSortKind</a> (SortPtr t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the type kind (e.g., array, tuple, int, bool, etc).  <a href="#c105e2a1c10a81fcbbda92338319b821"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#423fc3c6dda476f6799a85a2168c78b1">GetBvSortSize</a> (SortPtr t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the size of the given bit-vector type.  <a href="#423fc3c6dda476f6799a85a2168c78b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#d230ba9177f3ca00d509b1ee4f1ab8a5">GetArraySortDomain</a> (SortPtr t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the domain of the given array type.  <a href="#d230ba9177f3ca00d509b1ee4f1ab8a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SortPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#3de655e8182580662528e278b9bef566">GetArraySortRange</a> (SortPtr t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the range of the given array type.  <a href="#3de655e8182580662528e278b9bef566"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">FuncDeclPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#8faadbc0b5b7aa7e1f5fb988eddb0467">GetTupleConstructor</a> (SortPtr t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the constructor declaration of the given tuple type.  <a href="#8faadbc0b5b7aa7e1f5fb988eddb0467"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">array&lt; FuncDeclPtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#91e7e6ddb2615bb55ee58ea57c34f308">GetTupleFields</a> (SortPtr t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the field declarations of a given tuple type.  <a href="#91e7e6ddb2615bb55ee58ea57c34f308"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constraints</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#447d9c1a5a8c1d7ea7ff8d1b8c9a834c">Push</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a backtracking point.  <a href="#447d9c1a5a8c1d7ea7ff8d1b8c9a834c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac40326c3b51f26bf05a823061429cc1">Pop</a> (unsigned num_scopes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Backtrack.  <a href="#ac40326c3b51f26bf05a823061429cc1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="701a584ce72cccbcce9cb0656b6c898b"></a><!-- doxytag: member="Microsoft::Z3::RawContext::Pop" ref="701a584ce72cccbcce9cb0656b6c898b" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>Pop</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#268029705dabf988d7655c85df1b548e">PersistTerm</a> (TermPtr t, unsigned num_scopes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Persist a term during num_scopes of pops.  <a href="#268029705dabf988d7655c85df1b548e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#48d8c58bf4484b54bf612a3b81526648">AssertCnstr</a> (TermPtr a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assert a constraing into the logical context.  <a href="#48d8c58bf4484b54bf612a3b81526648"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__mapi.html#g2a6d3c91705945a27b9f264add662179">LBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#e593a36dbabec6c3fd92941c556e5abf">CheckAndGetModel</a> ([Runtime::InteropServices::Out] <a class="el" href="class_microsoft_1_1_z3_1_1_raw_model.html">RawModel</a>^%m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the given logical context is consistent or not.  <a href="#e593a36dbabec6c3fd92941c556e5abf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__mapi.html#g2a6d3c91705945a27b9f264add662179">LBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#338b5a83abb0751e1485885f7f6f513a">Check</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the given logical context is consistent or not.  <a href="#338b5a83abb0751e1485885f7f6f513a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__mapi.html#g2a6d3c91705945a27b9f264add662179">LBool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#869b99127a040ab11671d5599fe2bae6">CheckAssumptions</a> ([Runtime::InteropServices::Out] <a class="el" href="class_microsoft_1_1_z3_1_1_raw_model.html">RawModel</a>^%m,[Runtime::InteropServices::In] array&lt; TermPtr &gt;^assumptions,[Runtime::InteropServices::Out] TermPtr%proof,[Runtime::InteropServices::Out] array&lt; TermPtr &gt;^%core)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the given logical context is consistent or not with respect to auxiliary assumptions.  <a href="#869b99127a040ab11671d5599fe2bae6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__mapi.html#gd1c87dc0c2486f35f7ebe425f2041a3e">SearchFailureExplanation</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#3c2e03935c06e79eb6c4b249b910307d">GetSearchFailureExplanation</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain explanation for search failure.  <a href="#3c2e03935c06e79eb6c4b249b910307d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#4db4d536f2203faa741073c01f61fb0e">GetAssignments</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return conjunction of literals and formulas assigned to true in the current state.  <a href="#4db4d536f2203faa741073c01f61fb0e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_microsoft_1_1_z3_1_1_labeled_literals.html">LabeledLiterals</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#c91878a6a5fd8cb8173aed946528f42f">GetRelevantLabels</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve set of labels set in current satisfying assignment.  <a href="#c91878a6a5fd8cb8173aed946528f42f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_microsoft_1_1_z3_1_1_labeled_literals.html">LabeledLiterals</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ed54018936a4d19c92a05d8c770d3c33">GetRelevantLiterals</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve set of literals satisfying the current assignment.  <a href="#ed54018936a4d19c92a05d8c770d3c33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_microsoft_1_1_z3_1_1_labeled_literals.html">LabeledLiterals</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#9522ebeb37a88abbb1a4a1c4cf75ac9f">GetGuessedLiterals</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve set of guessed literals satisfying the current assignment.  <a href="#9522ebeb37a88abbb1a4a1c4cf75ac9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#712b529cbbcd86eb099bcb97289f9a77">BlockLiterals</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_labeled_literals.html">LabeledLiterals</a>^labels)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block the combination of remaining non-disabled labels.  <a href="#712b529cbbcd86eb099bcb97289f9a77"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#21c01788a1c75b8e9ee86634aec4ca8c">GetLiteral</a> (<a class="el" href="class_microsoft_1_1_z3_1_1_labeled_literals.html">LabeledLiterals</a>^labels, unsigned idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain literal corresponding to index in list of literals.  <a href="#21c01788a1c75b8e9ee86634aec4ca8c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ea36484f844217cc37a206be0fe565f6">Simplify</a> (TermPtr a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface to simplifier.  <a href="#ea36484f844217cc37a206be0fe565f6"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">String conversion</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#17471e6be035651820a92e6c4e31d673">SetPrintMode</a> (<a class="el" href="group__mapi.html#g8fcc700aeeee633213b4e5f433e5e12e">PrintMode</a> mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Select mode for the format used for pretty-printing AST nodes.  <a href="#17471e6be035651820a92e6c4e31d673"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#eacea454f727994d3088b0a329ce0994">ToString</a> (AstPtr a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the given AST node into a string.  <a href="#eacea454f727994d3088b0a329ce0994"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aaf92bee9704e9bafb7cd576d4d0b4ef"></a><!-- doxytag: member="Microsoft::Z3::RawContext::Display" ref="aaf92bee9704e9bafb7cd576d4d0b4ef" args="(System::IO::TextWriter^w, AstPtr a)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>Display</b> (System::IO::TextWriter^w, AstPtr a)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#08d99b52685eab1e9d5ac4d9223cb2be">ToString</a> () override</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the given logical context into a string.  <a href="#08d99b52685eab1e9d5ac4d9223cb2be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="af8bef9b1d9ed1692886459d39821267"></a><!-- doxytag: member="Microsoft::Z3::RawContext::Display" ref="af8bef9b1d9ed1692886459d39821267" args="(System::IO::TextWriter^w)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>Display</b> (System::IO::TextWriter^w)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#0c7570d3474aec2457249e00de34c51a">StatisticsToString</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the given logical context into a string.  <a href="#0c7570d3474aec2457249e00de34c51a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c57794a2c82648589e3ff80d27701c85"></a><!-- doxytag: member="Microsoft::Z3::RawContext::DisplayStatistics" ref="c57794a2c82648589e3ff80d27701c85" args="(System::IO::TextWriter^w)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>DisplayStatistics</b> (System::IO::TextWriter^w)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#0805c579c20f25fec2c0f293259d9473">BenchmarkToSmtlib</a> (String^name, String^logic, String^status, String^attributes, array&lt; TermPtr &gt;^assumptions, TermPtr formula)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the given benchmark into SMT-LIB formatted string.  <a href="#0805c579c20f25fec2c0f293259d9473"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Parser interface</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#7f0e4f0c8890c7566103ce77c3cc5f92">ParseSmtlibString</a> (String^string,[Runtime::InteropServices::In] array&lt; SortPtr &gt;^types,[Runtime::InteropServices::In] array&lt; FuncDeclPtr &gt;^old_decls,[Runtime::InteropServices::Out] array&lt; TermPtr &gt;^%assumptions,[Runtime::InteropServices::Out] array&lt; TermPtr &gt;^%formulas,[Runtime::InteropServices::Out] array&lt; FuncDeclPtr &gt;^%new_decls)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse the given string using the SMT-LIB parser.  <a href="#7f0e4f0c8890c7566103ce77c3cc5f92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#256a1746a11837c32de0458e34aedfd2">ParseSmtlibFile</a> (String^file,[Runtime::InteropServices::In] array&lt; SortPtr &gt;^types,[Runtime::InteropServices::In] array&lt; FuncDeclPtr &gt;^old_decls,[Runtime::InteropServices::Out] array&lt; TermPtr &gt;^%assumptions,[Runtime::InteropServices::Out] array&lt; TermPtr &gt;^%formulas,[Runtime::InteropServices::Out] array&lt; FuncDeclPtr &gt;^%new_decls)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#7f0e4f0c8890c7566103ce77c3cc5f92" title="Parse the given string using the SMT-LIB parser.">ParseSmtlibString</a>, but reads the benchmark from a file.  <a href="#256a1746a11837c32de0458e34aedfd2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#de46bed01c907e799528075996072637">ParseZ3String</a> (String^s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse a string in the native Z3 format.  <a href="#de46bed01c907e799528075996072637"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#bb1e2e3a1d96aa625758845ed3b8d534">ParseZ3File</a> (String^filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse a file containing formulas in the Simplify format.  <a href="#bb1e2e3a1d96aa625758845ed3b8d534"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#33c542e7816039e5f121bdbe280c8ef1">ParseSimplifyString</a> (String^s, String^%parser_out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse a string in the simplify format.  <a href="#33c542e7816039e5f121bdbe280c8ef1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TermPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#253ab5e7464695d6242629d372b62e24">ParseSimplifyFile</a> (String^filename, String^%parser_out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse a file containing formulas in the Simplify format.  <a href="#253ab5e7464695d6242629d372b62e24"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#14c2ca3446adb29eab226e6bb89ec692">GetVersion</a> ([Runtime::InteropServices::Out] unsigned%major,[Runtime::InteropServices::Out] unsigned%minor,[Runtime::InteropServices::Out] unsigned%build_number,[Runtime::InteropServices::Out] unsigned%revision_number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return Z3 version number information.  <a href="#14c2ca3446adb29eab226e6bb89ec692"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Errors</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#22af33e79aad8e443bfe2c249c6255ef">SetErrorHandler</a> (<a class="el" href="interface_microsoft_1_1_z3_1_1_i_error_handler.html">IErrorHandler</a>^h)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a Z3 error handler.  <a href="#22af33e79aad8e443bfe2c249c6255ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#8478b135914c2e8c78127a50361331c4">GetErrorMessage</a> (<a class="el" href="group__mapi.html#g59e56af19e754a6aa26a612ebf91d05f">ErrorCode</a> err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a string describing the given error code.  <a href="#8478b135914c2e8c78127a50361331c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#6bcc908b9ba41cd95dae64006321b34b">ResetMemory</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free all resources allocated for Z3.  <a href="#6bcc908b9ba41cd95dae64006321b34b"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Z3 API object. 
<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l00716">716</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="fb2f967c3369cea3be9967c33403e7c7"></a><!-- doxytag: member="Microsoft::Z3::RawContext::RawContext" ref="fb2f967c3369cea3be9967c33403e7c7" args="(Config^config)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html">RawContext</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_config.html">Config</a>^&nbsp;</td>
          <td class="paramname"> <em>config</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a logical context using the given configuration. 
<p>
After a context is created, the configuration cannot be changed. All main interaction with Z3 happens in the context of a <code><a class="el" href="class_microsoft_1_1_z3_1_1_context.html" title="Type safe contexts.">Context</a></code>.<p>
All contexts that are created must be disposed (call Dispose). Failure to dispose contexts cause memory leaks. Garbage collection will not free resources allocated in contexts. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="260b097dfa36861173bf7fdfd6594cf7"></a><!-- doxytag: member="Microsoft::Z3::RawContext::AppendLog" ref="260b097dfa36861173bf7fdfd6594cf7" args="(String^string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AppendLog           </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>string</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append instruction or comment to log with assertion. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#96aec8fa83ecdac0ac136c0cf6c74fe8" title="Log assertions to a file.">OpenLog</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="48d8c58bf4484b54bf612a3b81526648"></a><!-- doxytag: member="Microsoft::Z3::RawContext::AssertCnstr" ref="48d8c58bf4484b54bf612a3b81526648" args="(TermPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AssertCnstr           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assert a constraing into the logical context. 
<p>
After one assertion, the logical context may become inconsistent.<p>
The functions <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#338b5a83abb0751e1485885f7f6f513a" title="Check whether the given logical context is consistent or not.">Check</a> or <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#e593a36dbabec6c3fd92941c556e5abf" title="Check whether the given logical context is consistent or not.">CheckAndGetModel</a> should be used to check whether the logical context is consistent or not.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#338b5a83abb0751e1485885f7f6f513a" title="Check whether the given logical context is consistent or not.">Check</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#e593a36dbabec6c3fd92941c556e5abf" title="Check whether the given logical context is consistent or not.">CheckAndGetModel</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="0805c579c20f25fec2c0f293259d9473"></a><!-- doxytag: member="Microsoft::Z3::RawContext::BenchmarkToSmtlib" ref="0805c579c20f25fec2c0f293259d9473" args="(String^name, String^logic, String^status, String^attributes, array&lt; TermPtr &gt;^assumptions, TermPtr formula)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String BenchmarkToSmtlib           </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>logic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>assumptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>formula</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert the given benchmark into SMT-LIB formatted string. 
<p>

</div>
</div><p>
<a class="anchor" name="712b529cbbcd86eb099bcb97289f9a77"></a><!-- doxytag: member="Microsoft::Z3::RawContext::BlockLiterals" ref="712b529cbbcd86eb099bcb97289f9a77" args="(LabeledLiterals^labels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BlockLiterals           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_labeled_literals.html">LabeledLiterals</a>^&nbsp;</td>
          <td class="paramname"> <em>labels</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Block the combination of remaining non-disabled labels. 
<p>
Subsequent calls to Check will not contain satisfying assignments with the same combination of labels. 
</div>
</div><p>
<a class="anchor" name="338b5a83abb0751e1485885f7f6f513a"></a><!-- doxytag: member="Microsoft::Z3::RawContext::Check" ref="338b5a83abb0751e1485885f7f6f513a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapi.html#g2a6d3c91705945a27b9f264add662179">LBool</a> Check           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check whether the given logical context is consistent or not. 
<p>
The function GetModel should be used when models are needed.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>GetModel </dd></dl>

</div>
</div><p>
<a class="anchor" name="e593a36dbabec6c3fd92941c556e5abf"></a><!-- doxytag: member="Microsoft::Z3::RawContext::CheckAndGetModel" ref="e593a36dbabec6c3fd92941c556e5abf" args="([Runtime::InteropServices::Out] RawModel^%m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapi.html#g2a6d3c91705945a27b9f264add662179">LBool</a> CheckAndGetModel           </td>
          <td>(</td>
          <td class="paramtype">[Runtime::InteropServices::Out] <a class="el" href="class_microsoft_1_1_z3_1_1_raw_model.html">RawModel</a>^%&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check whether the given logical context is consistent or not. 
<p>
If the logical context is not unsatisfiable (i.e., the return value is different from <code>false</code>) and model construction is enabled (see Config), then a model is stored in <code>m</code>. Otherwise, the value <code>null</code> is stored in <code>m</code>. The caller is responsible for deleting the model using its Dispose method.<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Model construction must be enabled using configuration parameters (See, Config).</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#338b5a83abb0751e1485885f7f6f513a" title="Check whether the given logical context is consistent or not.">Check</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="869b99127a040ab11671d5599fe2bae6"></a><!-- doxytag: member="Microsoft::Z3::RawContext::CheckAssumptions" ref="869b99127a040ab11671d5599fe2bae6" args="([Runtime::InteropServices::Out] RawModel^%m,[Runtime::InteropServices::In] array&lt; TermPtr &gt;^assumptions,[Runtime::InteropServices::Out] TermPtr%proof,[Runtime::InteropServices::Out] array&lt; TermPtr &gt;^%core)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapi.html#g2a6d3c91705945a27b9f264add662179">LBool</a> CheckAssumptions           </td>
          <td>(</td>
          <td class="paramtype">[Runtime::InteropServices::Out] <a class="el" href="class_microsoft_1_1_z3_1_1_raw_model.html">RawModel</a>^%&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::In] array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>assumptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::Out] TermPtr%&nbsp;</td>
          <td class="paramname"> <em>proof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::Out] array&lt; TermPtr &gt;^%&nbsp;</td>
          <td class="paramname"> <em>core</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check whether the given logical context is consistent or not with respect to auxiliary assumptions. 
<p>
If the logical context is not unsatisfiable (i.e., the return value is different from <code>false</code>) and model construction is enabled (see Config), then a model is stored in <code>m</code>. Otherwise, the value <code>null</code> is stored in <code>m</code>. The caller is responsible for deleting the model using its Dispose method. If the logical context is unsatisfiable, then a proof object is return and stored in <code>proof</code>. An unsatisfiable core (subset) for the set of supplied assumptions is returned.<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Model construction must be enabled using configuration parameters (See, Config).</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>returned model. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>assumptions</em>&nbsp;</td><td>array of auxiliary assumptions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proof</em>&nbsp;</td><td>proof object. Proofs must be enabled for this value to be returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>core</em>&nbsp;</td><td>subset of assumptions that is an unsatisfiable core.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#338b5a83abb0751e1485885f7f6f513a" title="Check whether the given logical context is consistent or not.">Check</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b100e8973788ce566b11cda8bb09fc32"></a><!-- doxytag: member="Microsoft::Z3::RawContext::CloseLog" ref="b100e8973788ce566b11cda8bb09fc32" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CloseLog           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close file with logged assertions. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#96aec8fa83ecdac0ac136c0cf6c74fe8" title="Log assertions to a file.">OpenLog</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e767eef7c521b644401e58a4adfb11a6"></a><!-- doxytag: member="Microsoft::Z3::RawContext::EnableDebugTrace" ref="e767eef7c521b644401e58a4adfb11a6" args="(String^tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EnableDebugTrace           </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>tag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable debug tracing of tagged log. 
<p>

</div>
</div><p>
<a class="anchor" name="b3ed56054afb442b0c26b073104c330e"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetAccessors" ref="b3ed56054afb442b0c26b073104c330e" args="(Constructor^c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">array&lt;FuncDeclPtr&gt; GetAccessors           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>^&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
retrieve accessors for datatype. 
<p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01018">1018</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01018"></a>01018 { <span class="keywordflow">return</span> c-&gt;GetAccessors(); }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b021d6b4e58c052472ec3cd6d2dd0fac"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetAppArgs" ref="b021d6b4e58c052472ec3cd6d2dd0fac" args="(AppPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">array&lt;TermPtr&gt; GetAppArgs           </td>
          <td>(</td>
          <td class="paramtype">AppPtr&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the arguments of an application. If <code>t</code> is an constant, then array is empty. 
<p>

</div>
</div><p>
<a class="anchor" name="6aebc549137b2458e195ebe6d9d4c4ba"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetAppDecl" ref="6aebc549137b2458e195ebe6d9d4c4ba" args="(AppPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FuncDeclPtr GetAppDecl           </td>
          <td>(</td>
          <td class="paramtype">AppPtr&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the declaration of a constant or function application. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>GetTermKind(a) == TermKind.App </dd></dl>

</div>
</div><p>
<a class="anchor" name="d230ba9177f3ca00d509b1ee4f1ab8a5"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetArraySortDomain" ref="d230ba9177f3ca00d509b1ee4f1ab8a5" args="(SortPtr t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr GetArraySortDomain           </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the domain of the given array type. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>GetSortKind(t) == SortKind.Array</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#011fb26d01e3b5e696f5148da6d53d91" title="Create an array type.">MkArraySort</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#c105e2a1c10a81fcbbda92338319b821" title="Return the type kind (e.g., array, tuple, int, bool, etc).">GetSortKind</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3de655e8182580662528e278b9bef566"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetArraySortRange" ref="3de655e8182580662528e278b9bef566" args="(SortPtr t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr GetArraySortRange           </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the range of the given array type. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>GetSortKind(t) == SortKind.Array</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#011fb26d01e3b5e696f5148da6d53d91" title="Create an array type.">MkArraySort</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#c105e2a1c10a81fcbbda92338319b821" title="Return the type kind (e.g., array, tuple, int, bool, etc).">GetSortKind</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4db4d536f2203faa741073c01f61fb0e"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetAssignments" ref="4db4d536f2203faa741073c01f61fb0e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr GetAssignments           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return conjunction of literals and formulas assigned to true in the current state. 
<p>

</div>
</div><p>
<a class="anchor" name="74ec06b79df90539553d1c53c2a02bdd"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetBoolValue" ref="74ec06b79df90539553d1c53c2a02bdd" args="(TermPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapi.html#g2a6d3c91705945a27b9f264add662179">LBool</a> GetBoolValue           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the Boolean value of a truth constant. Return LBool::Undef if a is not a boolean constant (true or false). 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>GetTermKind(a) == TermKind.App </dd></dl>

</div>
</div><p>
<a class="anchor" name="423fc3c6dda476f6799a85a2168c78b1"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetBvSortSize" ref="423fc3c6dda476f6799a85a2168c78b1" args="(SortPtr t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned GetBvSortSize           </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the size of the given bit-vector type. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>GetSortKind(t) = SortKind.Bv</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#df17186c4a5ece22ff7d95d1b6722e7d" title="Create a bit-vector type of the given size.">MkBvSort</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#c105e2a1c10a81fcbbda92338319b821" title="Return the type kind (e.g., array, tuple, int, bool, etc).">GetSortKind</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d778d157f274c72a2e88b806b41df89c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetConstructor" ref="d778d157f274c72a2e88b806b41df89c" args="(Constructor^c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FuncDeclPtr GetConstructor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>^&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
retrieve constructor function declaration. 
<p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01008">1008</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01008"></a>01008 { <span class="keywordflow">return</span> c-&gt;GetConstructor(); }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="b5bd163cb2dff9a325fd961d413a8c22"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetDeclKind" ref="b5bd163cb2dff9a325fd961d413a8c22" args="(FuncDeclPtr d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapi.html#gc25bfa6294c0cc5dcf0e42e4bfa2b425">DeclKind</a> GetDeclKind           </td>
          <td>(</td>
          <td class="paramtype">FuncDeclPtr&nbsp;</td>
          <td class="paramname"> <em>d</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the kind of the built-in operator. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>GetTermKind(a) == TermKind.App </dd></dl>

</div>
</div><p>
<a class="anchor" name="7c62d9f2161dec8b726996082f05875c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetDeclName" ref="7c62d9f2161dec8b726996082f05875c" args="(FuncDeclPtr d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a> GetDeclName           </td>
          <td>(</td>
          <td class="paramtype">FuncDeclPtr&nbsp;</td>
          <td class="paramname"> <em>d</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the constant declaration name as a symbol. 
<p>

</div>
</div><p>
<a class="anchor" name="ccdc25299d9fe8c5a7fa0889c46cbdf5"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetDeclParameters" ref="ccdc25299d9fe8c5a7fa0889c46cbdf5" args="(FuncDeclPtr d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">array&lt;<a class="el" href="interface_microsoft_1_1_z3_1_1_i_raw_parameter.html">IRawParameter</a>^&gt; GetDeclParameters           </td>
          <td>(</td>
          <td class="paramtype">FuncDeclPtr&nbsp;</td>
          <td class="paramname"> <em>d</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return auxiliary parameters associated with the built-in operator. For example, the operator for bit-vector extraction uses two parameters, the upper and lower bit-index for extraction. 
<p>

</div>
</div><p>
<a class="anchor" name="612c60dae8dbc7cc04ebf8a299d7f78d"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetDomain" ref="612c60dae8dbc7cc04ebf8a299d7f78d" args="(FuncDeclPtr d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">array&lt;SortPtr&gt; GetDomain           </td>
          <td>(</td>
          <td class="paramtype">FuncDeclPtr&nbsp;</td>
          <td class="paramname"> <em>d</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the domain of a function declaration. 
<p>

</div>
</div><p>
<a class="anchor" name="8478b135914c2e8c78127a50361331c4"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetErrorMessage" ref="8478b135914c2e8c78127a50361331c4" args="(ErrorCode err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static String GetErrorMessage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mapi.html#g59e56af19e754a6aa26a612ebf91d05f">ErrorCode</a>&nbsp;</td>
          <td class="paramname"> <em>err</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a string describing the given error code. 
<p>

</div>
</div><p>
<a class="anchor" name="9522ebeb37a88abbb1a4a1c4cf75ac9f"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetGuessedLiterals" ref="9522ebeb37a88abbb1a4a1c4cf75ac9f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_microsoft_1_1_z3_1_1_labeled_literals.html">LabeledLiterals</a> GetGuessedLiterals           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve set of guessed literals satisfying the current assignment. 
<p>

</div>
</div><p>
<a class="anchor" name="21c01788a1c75b8e9ee86634aec4ca8c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetLiteral" ref="21c01788a1c75b8e9ee86634aec4ca8c" args="(LabeledLiterals^labels, unsigned idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr GetLiteral           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_labeled_literals.html">LabeledLiterals</a>^&nbsp;</td>
          <td class="paramname"> <em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>idx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain literal corresponding to index in list of literals. 
<p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l02496">2496</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l02496"></a>02496                                                                   {
<a name="l02497"></a>02497             <span class="keywordflow">return</span> labels-&gt;GetLiteral(idx);
<a name="l02498"></a>02498         }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="a00bb4f5b7abc37cf6c24e1c8ce08f4a"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetNumeralInt" ref="a00bb4f5b7abc37cf6c24e1c8ce08f4a" args="(TermPtr v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetNumeralInt           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a>, but only succeeds if the value can fit in a machine int. Throw InvalidArgument if the call fails. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>GetTermKind(v) == TermKind.Numeral &amp;&amp; IsInt32(v)</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="016d026fcaf6c2299687ae4407533390"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetNumeralInt64" ref="016d026fcaf6c2299687ae4407533390" args="(TermPtr v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__int64 GetNumeralInt64           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a>, but only succeeds if the value can fit in a machine long long int. Throw InvalidArgument if the call fails. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>GetTermKind(v) == TermKind.Numeral</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>GetNumeralTermPtrString </dd></dl>

</div>
</div><p>
<a class="anchor" name="ea8f522b8fd2fd2d7e48296b5c7a9512"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetNumeralString" ref="ea8f522b8fd2fd2d7e48296b5c7a9512" args="(TermPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String GetNumeralString           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of a numeric ast. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>GetTermKind(a) == TermKind.Numeral </dd></dl>

</div>
</div><p>
<a class="anchor" name="e40d08d8f9fc05ea8bb0b035f0da9f09"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetNumeralUInt" ref="e40d08d8f9fc05ea8bb0b035f0da9f09" args="(TermPtr v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GetNumeralUInt           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a>, but only succeeds if the value can fit in a machine unsigned int. Throw InvalidArgument if the call fails. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>GetTermKind(v) == TermKind.Numeral</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a78f20144c40600d63c87ebc8bd5d85e"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetNumeralUInt64" ref="a78f20144c40600d63c87ebc8bd5d85e" args="(TermPtr v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned __int64 GetNumeralUInt64           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a>, but only succeeds if the value can fit in a machine unsigned long long int. Throw InvalidArgument if the call fails. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>GetTermKind(v) == TermKind.Numeral</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ea8f522b8fd2fd2d7e48296b5c7a9512" title="Return the number of a numeric ast.">GetNumeralString</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="029d7befda8b1da2f597b3c9d3b5b998"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetPatternTerms" ref="029d7befda8b1da2f597b3c9d3b5b998" args="(PatternPtr p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">array&lt;TermPtr&gt; GetPatternTerms           </td>
          <td>(</td>
          <td class="paramtype">PatternPtr&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return array of terms in the pattern. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>GetTermKind(a) = TermKind.Pattern </dd></dl>

</div>
</div><p>
<a class="anchor" name="4dc623c04dfdeaef8d17f88034aab270"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetQuantifier" ref="4dc623c04dfdeaef8d17f88034aab270" args="(TermPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RawQuantifier GetQuantifier           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return components of a quantifier. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>GetTermKind(a) = TermKind.Quantifier </dd></dl>

</div>
</div><p>
<a class="anchor" name="84d2dfcc3f579dcce0820cad12686f42"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetRange" ref="84d2dfcc3f579dcce0820cad12686f42" args="(FuncDeclPtr d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr GetRange           </td>
          <td>(</td>
          <td class="paramtype">FuncDeclPtr&nbsp;</td>
          <td class="paramname"> <em>d</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the range of the given declaration. 
<p>
If <code>d</code> is a constant (i.e., has zero arguments), then this function returns the type of the constant. 
</div>
</div><p>
<a class="anchor" name="c91878a6a5fd8cb8173aed946528f42f"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetRelevantLabels" ref="c91878a6a5fd8cb8173aed946528f42f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_microsoft_1_1_z3_1_1_labeled_literals.html">LabeledLiterals</a> GetRelevantLabels           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve set of labels set in current satisfying assignment. 
<p>

</div>
</div><p>
<a class="anchor" name="ed54018936a4d19c92a05d8c770d3c33"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetRelevantLiterals" ref="ed54018936a4d19c92a05d8c770d3c33" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_microsoft_1_1_z3_1_1_labeled_literals.html">LabeledLiterals</a> GetRelevantLiterals           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve set of literals satisfying the current assignment. 
<p>

</div>
</div><p>
<a class="anchor" name="3c2e03935c06e79eb6c4b249b910307d"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetSearchFailureExplanation" ref="3c2e03935c06e79eb6c4b249b910307d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapi.html#gd1c87dc0c2486f35f7ebe425f2041a3e">SearchFailureExplanation</a> GetSearchFailureExplanation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Obtain explanation for search failure. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#338b5a83abb0751e1485885f7f6f513a" title="Check whether the given logical context is consistent or not.">Check()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d563e3268d5034c9147c98190c4327d6"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetSort" ref="d563e3268d5034c9147c98190c4327d6" args="(TermPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr GetSort           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the type of an AST node. 
<p>
The AST node must be a constant, application, numeral, bound variable, or quantifier. 
</div>
</div><p>
<a class="anchor" name="c105e2a1c10a81fcbbda92338319b821"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetSortKind" ref="c105e2a1c10a81fcbbda92338319b821" args="(SortPtr t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapi.html#g7664c6569cf130a5d166ec8c8dc27101">SortKind</a> GetSortKind           </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the type kind (e.g., array, tuple, int, bool, etc). 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>SortKind </dd></dl>

</div>
</div><p>
<a class="anchor" name="16e84dca2b1d23ce89a98276e943eb59"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetSortName" ref="16e84dca2b1d23ce89a98276e943eb59" args="(SortPtr ty)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a> GetSortName           </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>ty</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the type name as a symbol. 
<p>

</div>
</div><p>
<a class="anchor" name="fabdd4c7aa7001151713568aaf4e27b9"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetSymbolInt" ref="fabdd4c7aa7001151713568aaf4e27b9" args="(Symbol^s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GetSymbolInt           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the symbol int value. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>GetSymbolKind(s) == SymbolKind.Int</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>MkIntSymbol </dd></dl>

</div>
</div><p>
<a class="anchor" name="0e5e137439c1194fe6ceadd130c32844"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetSymbolKind" ref="0e5e137439c1194fe6ceadd130c32844" args="(Symbol^s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapi.html#g05812818de02fb4b202d7513ce50745d">SymbolKind</a> GetSymbolKind           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return <code>SymbolKind.Int</code> if the symbol was constructed using MkIntSymbol, and <code>SymbolKind.String</code> if the symbol was constructed using MkStringSymbol. 
<p>

</div>
</div><p>
<a class="anchor" name="63af55d0bc85edc1a08938fe94d059c3"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetSymbolString" ref="63af55d0bc85edc1a08938fe94d059c3" args="(Symbol^s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String GetSymbolString           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the symbol name. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>GetSymbolKind(s) = SymbolKind.String</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>MkStringSymbol </dd></dl>

</div>
</div><p>
<a class="anchor" name="a92cc97ea26a5d7ca06f7337a750c964"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetTermKind" ref="a92cc97ea26a5d7ca06f7337a750c964" args="(TermPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__mapi.html#g4b115a647ef9efa7c5fdfd8f376050dc">TermKind</a> GetTermKind           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the kind of the given AST. 
<p>

</div>
</div><p>
<a class="anchor" name="97a7320cd3d9a7d77f52bf789f5c8839"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetTester" ref="97a7320cd3d9a7d77f52bf789f5c8839" args="(Constructor^c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FuncDeclPtr GetTester           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>^&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
retrieve test function for constructor. 
<p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01013">1013</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01013"></a>01013 { <span class="keywordflow">return</span> c-&gt;GetTester(); }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8faadbc0b5b7aa7e1f5fb988eddb0467"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetTupleConstructor" ref="8faadbc0b5b7aa7e1f5fb988eddb0467" args="(SortPtr t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FuncDeclPtr GetTupleConstructor           </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the constructor declaration of the given tuple type. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>GetSortKind(t) == SortKind.Tuple</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#6af9bcdeb7cc9617f480af2b70a269c0" title="Create a tuple type.">MkTupleSort</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#c105e2a1c10a81fcbbda92338319b821" title="Return the type kind (e.g., array, tuple, int, bool, etc).">GetSortKind</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="91e7e6ddb2615bb55ee58ea57c34f308"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetTupleFields" ref="91e7e6ddb2615bb55ee58ea57c34f308" args="(SortPtr t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">array&lt;FuncDeclPtr&gt; GetTupleFields           </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the field declarations of a given tuple type. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>GetSortKind(t) == SortKind.Tuple</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#6af9bcdeb7cc9617f480af2b70a269c0" title="Create a tuple type.">MkTupleSort</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#c105e2a1c10a81fcbbda92338319b821" title="Return the type kind (e.g., array, tuple, int, bool, etc).">GetSortKind</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="17499379d443ca6ee0bf3770d18135af"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetVarIndex" ref="17499379d443ca6ee0bf3770d18135af" args="(TermPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned GetVarIndex           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the index of a de-Brujin bound variable. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>GetTermKind(a) == TermKind.Var </dd></dl>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l02214">2214</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l02214"></a>02214                                         {
<a name="l02215"></a>02215             <span class="keywordflow">return</span> <a class="code" href="group__capi.html#gba865ef17f1692ab14dbd304987db411" title="Return index of de-Brujin bound variable.">Z3_get_index_value</a>(m_context, get_ast(a));
<a name="l02216"></a>02216         }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="14c2ca3446adb29eab226e6bb89ec692"></a><!-- doxytag: member="Microsoft::Z3::RawContext::GetVersion" ref="14c2ca3446adb29eab226e6bb89ec692" args="([Runtime::InteropServices::Out] unsigned%major,[Runtime::InteropServices::Out] unsigned%minor,[Runtime::InteropServices::Out] unsigned%build_number,[Runtime::InteropServices::Out] unsigned%revision_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GetVersion           </td>
          <td>(</td>
          <td class="paramtype">[Runtime::InteropServices::Out] unsigned%&nbsp;</td>
          <td class="paramname"> <em>major</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::Out] unsigned%&nbsp;</td>
          <td class="paramname"> <em>minor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::Out] unsigned%&nbsp;</td>
          <td class="paramname"> <em>build_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::Out] unsigned%&nbsp;</td>
          <td class="paramname"> <em>revision_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return Z3 version number information. 
<p>

</div>
</div><p>
<a class="anchor" name="95167a48c7a40a4acf32631a527758da"></a><!-- doxytag: member="Microsoft::Z3::RawContext::IsEq" ref="95167a48c7a40a4acf32631a527758da" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IsEq           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return <code>true</code> if the two given AST nodes are equal. 
<p>

</div>
</div><p>
<a class="anchor" name="5668c488c12e405f662807b4f47860da"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkAdd" ref="5668c488c12e405f662807b4f47860da" args="(array&lt; TermPtr &gt;^args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkAdd           </td>
          <td>(</td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>args</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an AST node representing <code>args[0] + ... + args[args.Length-1]</code>. 
<p>
All arguments must have int or real type.<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The number of arguments must be greater than zero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8793a422c6c2d7b34000cc0032a4cdc4"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkAnd" ref="8793a422c6c2d7b34000cc0032a4cdc4" args="(array&lt; TermPtr &gt;^args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkAnd           </td>
          <td>(</td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>args</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an AST node representing <code>args[0] and ... and args[args.Length-1]</code>. 
<p>
All arguments must have Boolean type.<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The number of arguments must be greater than zero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a8a8ba273adfaadc01562b901524fd50"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkApp" ref="a8a8ba273adfaadc01562b901524fd50" args="(FuncDeclPtr d, array&lt; TermPtr &gt;^args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AppPtr MkApp           </td>
          <td>(</td>
          <td class="paramtype">FuncDeclPtr&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a constant or function application. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b5341894979c077ef1ad93ef67691c2a"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkArrayConst" ref="b5341894979c077ef1ad93ef67691c2a" args="(SortPtr domain, TermPtr v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkArrayConst           </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constant array. 
<p>
The node <code>a</code> must have an array type <code>[range]</code>, <code>domain</code> indicates the domain of the array. The type of the result is <code>[domain -&gt; range]</code>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#011fb26d01e3b5e696f5148da6d53d91" title="Create an array type.">MkArraySort</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#f0606dc016c08c4086d43d43ed45794c" title="Array read.">MkArraySelect</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aed9edcce01c069fcb982262ae01e14d" title="Array update.">MkArrayStore</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c645da9e615bc4e20515ef3cd8f74893"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkArrayDefault" ref="c645da9e615bc4e20515ef3cd8f74893" args="(TermPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkArrayDefault           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access the array default. 
<p>
The node <code>a</code> must have an array type <code>[domain -&gt; range]</code>. The type of the result is <code>[range]</code>. The result is a term whose value holds the default array value. That is, models should ensure that the default for <code>a</code> (ElseCase) evaluates to the same value as <code>MkArrayDefault(a)</code>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#011fb26d01e3b5e696f5148da6d53d91" title="Create an array type.">MkArraySort</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#f0606dc016c08c4086d43d43ed45794c" title="Array read.">MkArraySelect</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aed9edcce01c069fcb982262ae01e14d" title="Array update.">MkArrayStore</a> <p>
MkArrayconst </dd></dl>

</div>
</div><p>
<a class="anchor" name="3fcbf7757a9ffdb56c4bdd145c145246"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkArrayMap" ref="3fcbf7757a9ffdb56c4bdd145c145246" args="(FuncDeclPtr d, array&lt; TermPtr &gt;^args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkArrayMap           </td>
          <td>(</td>
          <td class="paramtype">FuncDeclPtr&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array map. 
<p>
The <code>n</code> nodes <code>args</code> must be of array sorts <code>[domain_i -&gt; range_i]</code>. The function declaration <code>f</code> must have type <code> range_1 .. range_n -&gt; range</code>. <code>v</code> must have sort range. The sort of the result is <code>[domain_i -&gt; range]</code>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#011fb26d01e3b5e696f5148da6d53d91" title="Create an array type.">MkArraySort</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#f0606dc016c08c4086d43d43ed45794c" title="Array read.">MkArraySelect</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aed9edcce01c069fcb982262ae01e14d" title="Array update.">MkArrayStore</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f0606dc016c08c4086d43d43ed45794c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkArraySelect" ref="f0606dc016c08c4086d43d43ed45794c" args="(TermPtr a, TermPtr i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkArraySelect           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array read. 
<p>
The node <code>a</code> must have an array type <code>[domain -&gt; range]</code>, and <code>i</code> must have the type <code>domain</code>. The type of the result is <code>range</code>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#011fb26d01e3b5e696f5148da6d53d91" title="Create an array type.">MkArraySort</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aed9edcce01c069fcb982262ae01e14d" title="Array update.">MkArrayStore</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="011fb26d01e3b5e696f5148da6d53d91"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkArraySort" ref="011fb26d01e3b5e696f5148da6d53d91" args="(SortPtr domain, SortPtr range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkArraySort           </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>range</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an array type. 
<p>
We usually represent the array type as: <code>[domain -&gt; range]</code>. Arrays are usually used to model the heap/memory in software verification.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#f0606dc016c08c4086d43d43ed45794c" title="Array read.">MkArraySelect</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#aed9edcce01c069fcb982262ae01e14d" title="Array update.">MkArrayStore</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#3fcbf7757a9ffdb56c4bdd145c145246" title="Array map.">MkArrayMap</a> <p>
MkConstArray </dd></dl>

</div>
</div><p>
<a class="anchor" name="aed9edcce01c069fcb982262ae01e14d"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkArrayStore" ref="aed9edcce01c069fcb982262ae01e14d" args="(TermPtr a, TermPtr i, TermPtr v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkArrayStore           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Array update. 
<p>
The node <code>a</code> must have an array type <code>[domain -&gt; range]</code>, <code>i</code> must have type <code>domain</code>, <code>v</code> must have type range. The type of the result is <code>[domain -&gt; range]</code>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#011fb26d01e3b5e696f5148da6d53d91" title="Create an array type.">MkArraySort</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#f0606dc016c08c4086d43d43ed45794c" title="Array read.">MkArraySelect</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5a24352b12189b45134064790859850a"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBoolSort" ref="5a24352b12189b45134064790859850a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkBoolSort           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create the boolean type. 
<p>
This type is used to create propositional variables and predicates. 
</div>
</div><p>
<a class="anchor" name="2e1ef04d234928c64248ce7eaf73502a"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBound" ref="2e1ef04d234928c64248ce7eaf73502a" args="(unsigned index, SortPtr ty)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBound           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>ty</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a bound variable. 
<p>
Bound variables are indexed by de-Bruijn indices. It is perhaps easiest to explain the meaning of de-Bruijn indices by indicating the compilation process from non-de-Bruijn formulas to de-Bruijn format.<p>
<div class="fragment"><pre class="fragment">
           abs(forall (x1) phi) = forall (x1) abs1(phi, x1, 0)
           abs(forall (x1, x2) phi) = abs(forall (x1) abs(forall (x2) phi))
           abs1(x, x, n) = b_n
           abs1(y, x, n) = y
           abs1(f(t1,...,tn), x, n) = f(abs1(t1,x,n), ..., abs1(tn,x,n))
           abs1(forall (x1) phi, x, n) = forall (x1) (abs1(phi, x, n+1))
           </pre></div><p>
The last line is significant: the index of a bound variable is different depending on the scope in which it appears. The deeper x appears, the higher is its index.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>de-Bruijn index </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ty</em>&nbsp;</td><td>type of the bound variable</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#d7d64f035d843f300b7fffcfb148e1fe" title="Create a forall formula.">MkForall</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#60c9cdf799990ce4ed2dd7f8caa914e9" title="Create an exists formula. Similar to MkForall.">MkExists</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="711b2b4ca79395d1d56820b7b3f9b3cc"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBv2Int" ref="711b2b4ca79395d1d56820b7b3f9b3cc" args="(TermPtr t1, bool is_signed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBv2Int           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_signed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert bit vector to integer. 
<p>
The node <code>t1</code> must have a bit-vector type. 
</div>
</div><p>
<a class="anchor" name="30237a1d6603428640b6db89d5d157fa"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvAdd" ref="30237a1d6603428640b6db89d5d157fa" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvAdd           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Standard two's complement addition. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="202fffba746c16499d216354e97ac74b"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvAddNoOverflow" ref="202fffba746c16499d216354e97ac74b" args="(TermPtr t1, TermPtr t2, bool is_signed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvAddNoOverflow           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_signed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check that addition does not overflow. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="421fc4943889a1c10d2dddbdaac5d09d"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvAddNoUnderflow" ref="421fc4943889a1c10d2dddbdaac5d09d" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvAddNoUnderflow           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check that addition does not underflow. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="add6a00031fb92a88ca6c177d4d75509"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvAnd" ref="add6a00031fb92a88ca6c177d4d75509" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvAnd           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bitwise and. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="4e8836887c24503234e99a94dd31a660"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvAshr" ref="4e8836887c24503234e99a94dd31a660" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvAshr           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Arithmetic shift right. 
<p>
It is like logical shift right except that the most significant bits of the result always copy the most significant bit of the second argument.<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="faba9154d1be03ec6d738951e94d37cb"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvConcat" ref="faba9154d1be03ec6d738951e94d37cb" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvConcat           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Concatenate the given bit-vectors. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have (possibly different) bit-vector types<p>
The result is a bit-vector of size <code>n1+n2</code>, where <code>n1</code> (<code>n2</code>) is the size of <code>t1</code> (<code>t2</code>). 
</div>
</div><p>
<a class="anchor" name="c2c8940627f740c9ec3b637ef2031887"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvExtract" ref="c2c8940627f740c9ec3b637ef2031887" args="(unsigned high, unsigned low, TermPtr t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvExtract           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extract the bits <code>high</code> down to <code>low</code> from a bitvector of size <code>m</code> to yield a new bitvector of size <code>n</code>, where <code>n = high - low + 1</code>. 
<p>
The node <code>t</code> must have a bit-vector type. 
</div>
</div><p>
<a class="anchor" name="2de5b050301845c2fa902a8a910db8ed"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvLshr" ref="2de5b050301845c2fa902a8a910db8ed" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvLshr           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Logical shift right. 
<p>
It is equivalent to unsigned division by <code>2^x</code> where <code>x</code> is the value of the third argument.<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="e5585802bf0ff4f5188bfbe1fd361470"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvMul" ref="e5585802bf0ff4f5188bfbe1fd361470" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvMul           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Standard two's complement multiplication. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="688f2a2cb04cb30f68dca62c6477f14b"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvMulNoOverflow" ref="688f2a2cb04cb30f68dca62c6477f14b" args="(TermPtr t1, TermPtr t2, bool is_signed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvMulNoOverflow           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_signed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check that multiplication does not overflow. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="036fccd286efdc90134941defd6a1df8"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvMulNoUnderflow" ref="036fccd286efdc90134941defd6a1df8" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvMulNoUnderflow           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check that multiplication does not underflow. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="5d58dfc570dde7e49faab8ed4dcfbfc7"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvNand" ref="5d58dfc570dde7e49faab8ed4dcfbfc7" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvNand           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bitwise nand. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="e21724e2d70e5aec94cfa59726565063"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvNeg" ref="e21724e2d70e5aec94cfa59726565063" args="(TermPtr t1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvNeg           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Standard two's complement unary minus. 
<p>
The node <code>t1</code> must have bit-vector type. 
</div>
</div><p>
<a class="anchor" name="7dcdbe9ddac5ccf9744174f4a20aac19"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvNegNoOverflow" ref="7dcdbe9ddac5ccf9744174f4a20aac19" args="(TermPtr t1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvNegNoOverflow           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check that negation does not overflow. 
<p>

</div>
</div><p>
<a class="anchor" name="a486a9f49b3fc395f37b56f0975a243b"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvNor" ref="a486a9f49b3fc395f37b56f0975a243b" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvNor           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bitwise nor. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="45b8b6397e45ac3fc6b38e873eed9d33"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvNot" ref="45b8b6397e45ac3fc6b38e873eed9d33" args="(TermPtr t1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvNot           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bitwise negation. 
<p>
The node <code>arg1</code> must have a bit-vector type. 
</div>
</div><p>
<a class="anchor" name="472170308fc0ce228ad1ee1b683811cd"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvOr" ref="472170308fc0ce228ad1ee1b683811cd" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvOr           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bitwise or. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="decfc831ae6c9135828e3095b27a4956"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvRotateLeft" ref="decfc831ae6c9135828e3095b27a4956" args="(unsigned i, TermPtr t1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvRotateLeft           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rotate bits of <code>t1</code> to the left <code>i</code> times. 
<p>
The node <code>t1</code> must have a bit-vector type. 
</div>
</div><p>
<a class="anchor" name="3df09da772a462d74c9f08546a44562b"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvRotateRight" ref="3df09da772a462d74c9f08546a44562b" args="(unsigned i, TermPtr t1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvRotateRight           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rotate bits of <code>t1</code> to the right <code>i</code> times. 
<p>
The node <code>t1</code> must have a bit-vector type. 
</div>
</div><p>
<a class="anchor" name="e96a3f936b75c53d7ab8eed094eb7b94"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSdiv" ref="e96a3f936b75c53d7ab8eed094eb7b94" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSdiv           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Two's complement signed division. 
<p>
It is defined in the following way:<p>
<ul>
<li>The <code>floor</code> of <code>t1/t2</code> if <code>t2</code> is different from zero, and <code>t1*t2 &gt;= 0</code>.</li></ul>
<p>
<ul>
<li>The <code>ceiling</code> of <code>t1/t2</code> if <code>t2</code> is different from zero, and <code>t1*t2 &lt; 0</code>.</li></ul>
<p>
If <code>t2</code> is zero, then the result is undefined.<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="c537f6c8529718162b4a16a926f145f8"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSDivNoOverflow" ref="c537f6c8529718162b4a16a926f145f8" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSDivNoOverflow           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check that division does not overflow. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="27a2d12f9e8d5639fa86b4d0997e2b17"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSge" ref="27a2d12f9e8d5639fa86b4d0997e2b17" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSge           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Two's complement signed greater than or equal to. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="013910a4fa70b37878520b4400b1c107"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSgt" ref="013910a4fa70b37878520b4400b1c107" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSgt           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Two's complement signed greater than. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="484c128e627a79c8af7fcbb531b0ba39"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvShl" ref="484c128e627a79c8af7fcbb531b0ba39" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvShl           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shift left. 
<p>
It is equivalent to multiplication by <code>2^x</code> where <code>x</code> is the value of the third argument.<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="f94e12dbe34a66f358baebe8ef6848fc"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSignExt" ref="f94e12dbe34a66f358baebe8ef6848fc" args="(unsigned i, TermPtr t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSignExt           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sign-extend of the given bit-vector to the (signed) equivalent bitvector of size <code>m+i</code>, where <code>m</code> is the size of the given bit-vector. 
<p>
The node <code>t</code> must have a bit-vector type. 
</div>
</div><p>
<a class="anchor" name="c37363c17a7308be4ca999068da16fbb"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSle" ref="c37363c17a7308be4ca999068da16fbb" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSle           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Two's complement signed less than or equal to. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="8352294e2808ce534fc83ec39bca8fbd"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSlt" ref="8352294e2808ce534fc83ec39bca8fbd" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSlt           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Two's complement signed less than. 
<p>
It abbreviates: <div class="fragment"><pre class="fragment">           (or (and (= (extract[|m-1|:|m-1|] s) bit1)
                    (= (extract[|m-1|:|m-1|] t) bit0))
               (and (= (extract[|m-1|:|m-1|] s) (extract[|m-1|:|m-1|] t))
                    (bvult s t)))
</pre></div><p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="094b16beaa982ef3500633b3482d2603"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSmod" ref="094b16beaa982ef3500633b3482d2603" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSmod           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Two's complement signed remainder (sign follows divisor). 
<p>
If <code>t2</code> is zero, then the result is undefined.<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#1db91c0489ac65927dc14613e0b2225b" title="Two&#39;s complement signed remainder (sign follows dividend).">MkBvSrem</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="df17186c4a5ece22ff7d95d1b6722e7d"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSort" ref="df17186c4a5ece22ff7d95d1b6722e7d" args="(unsigned sz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkBvSort           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>sz</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a bit-vector type of the given size. 
<p>
This type can also be seen as a machine integer.<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The size of the bitvector type must be greater than zero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1db91c0489ac65927dc14613e0b2225b"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSrem" ref="1db91c0489ac65927dc14613e0b2225b" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSrem           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Two's complement signed remainder (sign follows dividend). 
<p>
It is defined as <code>t1 - (t1 /s t2) * t2</code>, where <code>/s</code> represents signed division. The most significant bit (sign) of the result is equal to the most significant bit of <code>t1</code>.<p>
If <code>t2</code> is zero, then the result is undefined.<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#094b16beaa982ef3500633b3482d2603" title="Two&#39;s complement signed remainder (sign follows divisor).">MkBvSmod</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ea836bb8f5dcec3f401d77538e31e248"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSub" ref="ea836bb8f5dcec3f401d77538e31e248" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSub           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Standard two's complement subtraction. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="44065d4fa565d6efa0f351f266c61c58"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSubNoOverflow" ref="44065d4fa565d6efa0f351f266c61c58" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSubNoOverflow           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check that subtraction does not overflow. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="3386aa55309ead169a54aeeed1cef0d6"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvSubNoUnderflow" ref="3386aa55309ead169a54aeeed1cef0d6" args="(TermPtr t1, TermPtr t2, bool is_signed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvSubNoUnderflow           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_signed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check that subtraction does not underflow. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="98ee5b832fa8f1a44998a2541bf4114c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvUdiv" ref="98ee5b832fa8f1a44998a2541bf4114c" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvUdiv           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unsigned division. 
<p>
It is defined as the <code>floor</code> of <code>t1/t2</code> if <code>t2</code> is different from zero. If <code>t2</code> is zero, then the result is undefined.<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="cb5149b9f7b1d823cd93ed6f43db5a17"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvUge" ref="cb5149b9f7b1d823cd93ed6f43db5a17" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvUge           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unsigned greater than or equal to. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="fcb8b1208ec0cc2c1579c29158b3815e"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvUgt" ref="fcb8b1208ec0cc2c1579c29158b3815e" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvUgt           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unsigned greater than. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="a434742064f523ecf5a7e13a113df86b"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvUle" ref="a434742064f523ecf5a7e13a113df86b" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvUle           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unsigned less than or equal to. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="71e25df68e31503191875d9348c9f823"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvUlt" ref="71e25df68e31503191875d9348c9f823" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvUlt           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unsigned less than. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="30f13a71debd51968bc2129eaa26121d"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvUrem" ref="30f13a71debd51968bc2129eaa26121d" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvUrem           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unsigned remainder. 
<p>
It is defined as <code>t1 - (t1 /u t2) * t2</code>, where <code>/u</code> represents unsigned division.<p>
If <code>t2</code> is zero, then the result is undefined.<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="0112b7f61d18dcd15369566cdcf4b05f"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvXnor" ref="0112b7f61d18dcd15369566cdcf4b05f" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvXnor           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bitwise xnor. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="684ce5c64067b6d5d4cddfbfe32789b4"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvXor" ref="684ce5c64067b6d5d4cddfbfe32789b4" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvXor           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bitwise exclusive-or. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have the same bit-vector type. 
</div>
</div><p>
<a class="anchor" name="dd245de4256b820ef7d66ce58fd43385"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkBvZeroExt" ref="dd245de4256b820ef7d66ce58fd43385" args="(unsigned i, TermPtr t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkBvZeroExt           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Extend the given bit-vector with zeros to the (unsigned) equivalent bitvector of size <code>m+i</code>, where <code>m</code> is the size of the given bit-vector. 
<p>
The node <code>t1</code> must have a bit-vector type. 
</div>
</div><p>
<a class="anchor" name="4119e0d04b9b4b8e95969e261b06aab7"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkConst" ref="4119e0d04b9b4b8e95969e261b06aab7" args="(FuncDeclPtr d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AppPtr MkConst           </td>
          <td>(</td>
          <td class="paramtype">FuncDeclPtr&nbsp;</td>
          <td class="paramname"> <em>d</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Declare and create a constant. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8a8ba273adfaadc01562b901524fd50" title="Create a constant or function application.">MkApp</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="30d1032d60ebd18e9d99d5c4191ab7b8"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkConstructor" ref="30d1032d60ebd18e9d99d5c4191ab7b8" args="(String^name, String^tester, array&lt; String^&gt;^field_names, array&lt; SortPtr &gt;^field_sorts, array&lt; unsigned &gt;^field_refs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a> MkConstructor           </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>tester</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; String^&gt;^&nbsp;</td>
          <td class="paramname"> <em>field_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>field_sorts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; unsigned &gt;^&nbsp;</td>
          <td class="paramname"> <em>field_refs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create constructor object for datatype declarations. The object must be disposed with manually. 
<p>
Use the methods <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#d778d157f274c72a2e88b806b41df89c" title="retrieve constructor function declaration.">GetConstructor</a>, <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#97a7320cd3d9a7d77f52bf789f5c8839" title="retrieve test function for constructor.">GetTester</a>, and <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#b3ed56054afb442b0c26b073104c330e" title="retrieve accessors for datatype.">GetAccessors</a> to retrieve the function declarations for constructors, tester and accessors after the datatype has been declared.<p>
A field_ref is the index of the (mutually) recursive datatype. For example, if you declare a single recursive datatype, then a reference to the recursive datatype that is being declared is the number 0. If you declare two mutually recursive datatypes, then the reference to the second recursive datatype is 1.<p>
NB. The constructor object must be disposed with explicitly. 
</div>
</div><p>
<a class="anchor" name="db386d1976b2c6587844fe995444c46f"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkDataType" ref="db386d1976b2c6587844fe995444c46f" args="(String^name, array&lt; Constructor^&gt;^constructors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkDataType           </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>^&gt;^&nbsp;</td>
          <td class="paramname"> <em>constructors</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create datatype sort. 
<p>

</div>
</div><p>
<a class="anchor" name="a44dbeb0d3495a206820ffa9ce249a0a"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkDataTypes" ref="a44dbeb0d3495a206820ffa9ce249a0a" args="(array&lt; String^&gt;^names, array&lt; array&lt; Constructor^&gt;^&gt;^constructors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">array&lt;SortPtr&gt; MkDataTypes           </td>
          <td>(</td>
          <td class="paramtype">array&lt; String^&gt;^&nbsp;</td>
          <td class="paramname"> <em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_constructor.html">Constructor</a>^&gt;^&gt;^&nbsp;</td>
          <td class="paramname"> <em>constructors</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create datatype sorts. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>names</em>&nbsp;</td><td>array of names for the recursive datatypes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>constructors</em>&nbsp;</td><td>array of arrays of constructors. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="89bdd6aba66dab2a90592cea3263eb74"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkDistinct" ref="89bdd6aba66dab2a90592cea3263eb74" args="(array&lt; TermPtr &gt;^args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkDistinct           </td>
          <td>(</td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>args</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an AST node representing <code>distinct(args[0], ..., args[args.Length-1])</code>. 
<p>
The <code>distinct</code> construct is used for declaring the arguments pairwise distinct. That is, <code>Forall 0 &lt;= i &lt; j &lt; args.Length. not args[i] = args[j]</code>.<p>
All arguments must have the same type.<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The number of arguments of a distinct construct must be greater than one. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e7f8e2e8eb754c5a87fa3faa51ff8baf"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkDiv" ref="e7f8e2e8eb754c5a87fa3faa51ff8baf" args="(TermPtr arg1, TermPtr arg2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkDiv           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create integer or real division. 
<p>
The nodes <code>arg1</code> and <code>arg2</code> must have the same type, and must be int or real. 
</div>
</div><p>
<a class="anchor" name="e3a1a555a0fce2e8c1dfdfb863b56216"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkEmptySet" ref="e3a1a555a0fce2e8c1dfdfb863b56216" args="(SortPtr ty)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkEmptySet           </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>ty</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create the empty set. 
<p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01748">1748</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01748"></a>01748 { <span class="keywordflow">return</span> TermPtr(Z3_mk_empty_set(m_context, get_sort_ast(ty))); }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="72b2b9b3967c4638276bdccbdb0c9471"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkEnumerationSort" ref="72b2b9b3967c4638276bdccbdb0c9471" args="(String^name, array&lt; String^&gt;^enum_names, array&lt; FuncDeclPtr &gt;^enum_consts, array&lt; FuncDeclPtr &gt;^enum_testers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkEnumerationSort           </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; String^&gt;^&nbsp;</td>
          <td class="paramname"> <em>enum_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; FuncDeclPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>enum_consts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; FuncDeclPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>enum_testers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create an enumeration type. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>- name of enumeration sort. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enum_names</em>&nbsp;</td><td>- names of enumerated elements. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enum_consts</em>&nbsp;</td><td>- output function declarations for enumerated elements. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>enum_testers</em>&nbsp;</td><td>- output function declarations for enumeration testers. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b5b455baaffd7f2bf2a9508f801819de"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkEq" ref="b5b455baaffd7f2bf2a9508f801819de" args="(TermPtr l, TermPtr r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkEq           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>r</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an AST node representing <code>l = r</code>. 
<p>
The nodes <code>l</code> and <code>r</code> must have the same type. 
</div>
</div><p>
<a class="anchor" name="60c9cdf799990ce4ed2dd7f8caa914e9"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkExists" ref="60c9cdf799990ce4ed2dd7f8caa914e9" args="(unsigned weight, array&lt; PatternPtr &gt;^patterns, array&lt; SortPtr &gt;^types, array&lt; Symbol^&gt;^names, TermPtr body)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkExists           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; PatternPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&gt;^&nbsp;</td>
          <td class="paramname"> <em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>body</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an exists formula. Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#d7d64f035d843f300b7fffcfb148e1fe" title="Create a forall formula.">MkForall</a>. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#8a941e796cdc983459602aeb22178d8a" title="Create a pattern for quantifier instantiation.">MkPattern</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#2e1ef04d234928c64248ce7eaf73502a" title="Create a bound variable.">MkBound</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#d7d64f035d843f300b7fffcfb148e1fe" title="Create a forall formula.">MkForall</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4c138a08931900ebb7396484a6294cff"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkFalse" ref="4c138a08931900ebb7396484a6294cff" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkFalse           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an AST node representing <code>false</code>. 
<p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01134">1134</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01134"></a>01134 { <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#g5952ac17671117a02001fed6575c778d" title="Create an AST node representing false.">Z3_mk_false</a>(m_context)); }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="8c6471e0eb3e8a5a5a6c7c7e9e5bd8d7"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkForall" ref="8c6471e0eb3e8a5a5a6c7c7e9e5bd8d7" args="(unsigned weight, array&lt; AppPtr &gt;^bound, array&lt; PatternPtr &gt;^patterns, TermPtr body)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkForall           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; AppPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; PatternPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>body</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a forall formula. 
<p>
This function allows creating a forall without using de-Bruijn indices in the body or patterns. It is sometimes convenient to create the body of a quantifier without de-Bruijn indices, but instead use constants. These constants have to be replaced by de-Bruijn indices for the internal representation. This function allows the caller to hand over the task to Z3 of abstracting the constants into bound variables, so that each occurrence of the variables in the array <code>bound</code> gets replaced by a de-Bruijn index.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>weight</em>&nbsp;</td><td>quantifiers are associated with weights indicating the importance of using the quantifier during instantiation. By default, pass the weight 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bound</em>&nbsp;</td><td>array containing the constants to be abstracted as bound variables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patterns</em>&nbsp;</td><td>array containing the patterns created using <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#8a941e796cdc983459602aeb22178d8a" title="Create a pattern for quantifier instantiation.">MkPattern</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>body</em>&nbsp;</td><td>the body of the quantifier.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#8a941e796cdc983459602aeb22178d8a" title="Create a pattern for quantifier instantiation.">MkPattern</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#60c9cdf799990ce4ed2dd7f8caa914e9" title="Create an exists formula. Similar to MkForall.">MkExists</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="810d22421101b29aef8864c6e2aa3a3f"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkForall" ref="810d22421101b29aef8864c6e2aa3a3f" args="(unsigned weight, array&lt; PatternPtr &gt;^patterns, array&lt; SortPtr &gt;^types, array&lt; String^&gt;^names, TermPtr body)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkForall           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; PatternPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; String^&gt;^&nbsp;</td>
          <td class="paramname"> <em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>body</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a forall formula. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>weight</em>&nbsp;</td><td>quantifiers are associated with weights indicating the importance of using the quantifier during instantiation. By default, pass the weight 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patterns</em>&nbsp;</td><td>array containing the patterns created using <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#8a941e796cdc983459602aeb22178d8a" title="Create a pattern for quantifier instantiation.">MkPattern</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>types</em>&nbsp;</td><td>array containing the types of the bound variables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>names</em>&nbsp;</td><td>array containing the names as strings of the bound variables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>body</em>&nbsp;</td><td>the body of the quantifier.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#8a941e796cdc983459602aeb22178d8a" title="Create a pattern for quantifier instantiation.">MkPattern</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#2e1ef04d234928c64248ce7eaf73502a" title="Create a bound variable.">MkBound</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#60c9cdf799990ce4ed2dd7f8caa914e9" title="Create an exists formula. Similar to MkForall.">MkExists</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d7d64f035d843f300b7fffcfb148e1fe"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkForall" ref="d7d64f035d843f300b7fffcfb148e1fe" args="(unsigned weight, array&lt; PatternPtr &gt;^patterns, array&lt; SortPtr &gt;^types, array&lt; Symbol^&gt;^names, TermPtr body)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkForall           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; PatternPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&gt;^&nbsp;</td>
          <td class="paramname"> <em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>body</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a forall formula. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>weight</em>&nbsp;</td><td>quantifiers are associated with weights indicating the importance of using the quantifier during instantiation. By default, pass the weight 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>patterns</em>&nbsp;</td><td>array containing the patterns created using <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#8a941e796cdc983459602aeb22178d8a" title="Create a pattern for quantifier instantiation.">MkPattern</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>types</em>&nbsp;</td><td>array containing the types of the bound variables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>names</em>&nbsp;</td><td>array containing the names as symbols of the bound variables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>body</em>&nbsp;</td><td>the body of the quantifier.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#8a941e796cdc983459602aeb22178d8a" title="Create a pattern for quantifier instantiation.">MkPattern</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#2e1ef04d234928c64248ce7eaf73502a" title="Create a bound variable.">MkBound</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#60c9cdf799990ce4ed2dd7f8caa914e9" title="Create an exists formula. Similar to MkForall.">MkExists</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="abc8469e3803c5413a1a69c7cd001672"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkFreshConst" ref="abc8469e3803c5413a1a69c7cd001672" args="(String^prefix, SortPtr ty)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkFreshConst           </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>ty</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Declare and create a fresh constant. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8a8ba273adfaadc01562b901524fd50" title="Create a constant or function application.">MkApp</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="5251d6fc152aea96eac0e9e702dad707"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkFreshFuncDecl" ref="5251d6fc152aea96eac0e9e702dad707" args="(String^prefix, array&lt; SortPtr &gt;^domain, SortPtr range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FuncDeclPtr MkFreshFuncDecl           </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>range</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Declare a fresh constant or function. 
<p>
Z3 will generate an unique name for this function declaration.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#2bb4cecfa5619dbf2ed8f53d3b2f5749" title="Declare a constant or function.">MkFuncDecl</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="71d300776d9303680e79f784a2644e4c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkFullSet" ref="71d300776d9303680e79f784a2644e4c" args="(SortPtr ty)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkFullSet           </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>ty</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create the full set. 
<p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01753">1753</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01753"></a>01753 { <span class="keywordflow">return</span> TermPtr(Z3_mk_full_set(m_context, get_sort_ast(ty))); }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="2bb4cecfa5619dbf2ed8f53d3b2f5749"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkFuncDecl" ref="2bb4cecfa5619dbf2ed8f53d3b2f5749" args="(Symbol^s, array&lt; SortPtr &gt;^domain, SortPtr range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FuncDeclPtr MkFuncDecl           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>range</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Declare a constant or function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>name of the constant or function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>domain</em>&nbsp;</td><td>array containing the type of each argument. The array must contain domain_size elements. It is 0 whe declaring a constant. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>range</em>&nbsp;</td><td>type of the constant or the return type of the function.</td></tr>
  </table>
</dl>
After declaring a constant or function, the function <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8a8ba273adfaadc01562b901524fd50" title="Create a constant or function application.">MkApp</a> can be used to create a constant or function application.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#a8a8ba273adfaadc01562b901524fd50" title="Create a constant or function application.">MkApp</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7a08b71116843992a1078d9df3889f09"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkGe" ref="7a08b71116843992a1078d9df3889f09" args="(TermPtr arg1, TermPtr arg2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkGe           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create greater than or equal to. 
<p>
The nodes <code>arg1</code> and <code>arg2</code> must have the same type, and must be int or real. 
</div>
</div><p>
<a class="anchor" name="5935871bfbeda8fcd6bc467d8d49afc2"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkGt" ref="5935871bfbeda8fcd6bc467d8d49afc2" args="(TermPtr arg1, TermPtr arg2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkGt           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create greater than. 
<p>
The nodes <code>arg1</code> and <code>arg2</code> must have the same type, and must be int or real. 
</div>
</div><p>
<a class="anchor" name="f0019c9b938cbfc228d538500e25ab1f"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkIff" ref="f0019c9b938cbfc228d538500e25ab1f" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkIff           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an AST node representing <code>t1 iff t2</code>. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have Boolean type. 
</div>
</div><p>
<a class="anchor" name="fcbf82213943aa0a30efb51dbf81b7dd"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkImplies" ref="fcbf82213943aa0a30efb51dbf81b7dd" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkImplies           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an AST node representing <code>t1 implies t2</code>. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have Boolean type. 
</div>
</div><p>
<a class="anchor" name="1c4f013234b21f0c4599f3c44fb778fb"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkInjectiveFunction" ref="1c4f013234b21f0c4599f3c44fb778fb" args="(String^name, array&lt; SortPtr &gt;^domain, SortPtr range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FuncDeclPtr MkInjectiveFunction           </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>range</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create injective function. 
<p>

</div>
</div><p>
<a class="anchor" name="43be2bceee8a6d4a870733196a149612"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkInt2Bv" ref="43be2bceee8a6d4a870733196a149612" args="(unsigned size, TermPtr t1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkInt2Bv           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert integer to bit vector. 
<p>
The node <code>t1</code> must have a integer type. 
</div>
</div><p>
<a class="anchor" name="fb42590f21003d708f6dacbb95a7c995"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkInt2Real" ref="fb42590f21003d708f6dacbb95a7c995" args="(TermPtr arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkInt2Real           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Coerce integer term to real type. 
<p>
There is no converse operation exposed, but you can take the floor of a real by creating an auxiliary integer constant <code>k</code> and and asserting <code> MkInt2Real(k) &lt;= t1 &lt; MkInt2Real(k)+1</code>.<p>
The node <code>arg</code> must have type int. 
</div>
</div><p>
<a class="anchor" name="04bf543bb7b59788f7b7d40d4738648b"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkIntSort" ref="04bf543bb7b59788f7b7d40d4738648b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkIntSort           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an integer type. 
<p>
This type is not the int type found in programming languages. A machine integer can be represented using bit-vectors. The function MkBvType creates a bit-vector type.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>MkBvType </dd></dl>

</div>
</div><p>
<a class="anchor" name="4c1882945cd1a8462070e5d92e7a6b93"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkIte" ref="4c1882945cd1a8462070e5d92e7a6b93" args="(TermPtr t1, TermPtr t2, TermPtr t3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkIte           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t3</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an AST node representing an if-then-else: <code>ite(t1, t2, t3)</code>. 
<p>
The node <code>t1</code> must have Boolean type, <code>t2</code> and <code>t3</code> must have the same type. The type of the new node is equal to the type of <code>t2</code> and <code>t3</code>. 
</div>
</div><p>
<a class="anchor" name="ebcce24f39e8ce68930346c48ac5a57f"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkLabel" ref="ebcce24f39e8ce68930346c48ac5a57f" args="(Symbol^name, bool pos, TermPtr fml)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkLabel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>fml</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create labeled formula. 
<p>

</div>
</div><p>
<a class="anchor" name="a4993b3a46531ed7c4924d64185344d2"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkLe" ref="a4993b3a46531ed7c4924d64185344d2" args="(TermPtr arg1, TermPtr arg2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkLe           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create less than or equal to. 
<p>
The nodes <code>arg1</code> and <code>arg2</code> must have the same type, and must be int or real. 
</div>
</div><p>
<a class="anchor" name="0180bc7478b5c26f1d2c145187c31130"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkListSort" ref="0180bc7478b5c26f1d2c145187c31130" args="(String^name, SortPtr elem_sort,[Runtime::InteropServices::Out] FuncDeclPtr%nil_decl,[Runtime::InteropServices::Out] FuncDeclPtr%is_nil_decl,[Runtime::InteropServices::Out] FuncDeclPtr%cons_decl,[Runtime::InteropServices::Out] FuncDeclPtr%is_cons_decl,[Runtime::InteropServices::Out] FuncDeclPtr%head_decl,[Runtime::InteropServices::Out] FuncDeclPtr%tail_decl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkListSort           </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>elem_sort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::Out] FuncDeclPtr%&nbsp;</td>
          <td class="paramname"> <em>nil_decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::Out] FuncDeclPtr%&nbsp;</td>
          <td class="paramname"> <em>is_nil_decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::Out] FuncDeclPtr%&nbsp;</td>
          <td class="paramname"> <em>cons_decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::Out] FuncDeclPtr%&nbsp;</td>
          <td class="paramname"> <em>is_cons_decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::Out] FuncDeclPtr%&nbsp;</td>
          <td class="paramname"> <em>head_decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::Out] FuncDeclPtr%&nbsp;</td>
          <td class="paramname"> <em>tail_decl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
create list sort. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>of resulting list type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>elem_sort</em>&nbsp;</td><td>sort of elements. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nil_decl</em>&nbsp;</td><td>function declaration for nil. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>is_nil_decl</em>&nbsp;</td><td>function declaration for nil tester. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cons_decl</em>&nbsp;</td><td>function declaration for cons constructor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>is_cons_decl</em>&nbsp;</td><td>function declaration for cons tester. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>head_decl</em>&nbsp;</td><td>function declaration for head accessor. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tail_decl</em>&nbsp;</td><td>function declaration for tail accessor. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a817a455803ab79b220b0182b48e2ae5"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkLt" ref="a817a455803ab79b220b0182b48e2ae5" args="(TermPtr arg1, TermPtr arg2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkLt           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create less than. 
<p>
The nodes <code>arg1</code> and <code>arg2</code> must have the same type, and must be int or real. 
</div>
</div><p>
<a class="anchor" name="5a9f33467a473c739edac3721e0d56ea"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkMod" ref="5a9f33467a473c739edac3721e0d56ea" args="(TermPtr arg1, TermPtr arg2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkMod           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create integer modulus. 
<p>
The nodes <code>arg1</code> and <code>arg2</code> must have integer type. 
</div>
</div><p>
<a class="anchor" name="a20eacf8d7fa0e446c1081e5ff01de77"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkMul" ref="a20eacf8d7fa0e446c1081e5ff01de77" args="(array&lt; TermPtr &gt;^args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkMul           </td>
          <td>(</td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>args</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an AST node representing <code>args[0] * ... * args[args.Length-1]</code>. 
<p>
All arguments must have int or real type.<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Z3 has limited support for non-linear arithmetic. <p>
The number of arguments must be greater than zero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fc672bf3d4167000f8511454ef05a83d"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkNot" ref="fc672bf3d4167000f8511454ef05a83d" args="(TermPtr arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual TermPtr MkNot           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an AST node representing <code>not(a)</code>. 
<p>
The node <code>a</code> must have Boolean type. 
</div>
</div><p>
<a class="anchor" name="d04ee26dbb08422102bdc1189e293196"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkNumeral" ref="d04ee26dbb08422102bdc1189e293196" args="(String^numeral, SortPtr ty)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkNumeral           </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>numeral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>ty</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a numeral of a given type. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>numeral</em>&nbsp;</td><td>An integer, or a string representing the numeral value in decimal notation. If the given type is a real, then the numeral can be a rational, that is, a string of the form <code>[num]* / [num]*</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ty</em>&nbsp;</td><td>The type of the numeral. In the current implementation, the given type can be an int, real, or bit-vectors of arbitrary size. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="72a8f73bed309b8924dd49eba903bb24"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkOr" ref="72a8f73bed309b8924dd49eba903bb24" args="(array&lt; TermPtr &gt;^args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkOr           </td>
          <td>(</td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>args</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an AST node representing <code>args[0] or ... or args[args.Length-1]</code>. 
<p>
All arguments must have Boolean type.<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The number of arguments must be greater than zero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8a941e796cdc983459602aeb22178d8a"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkPattern" ref="8a941e796cdc983459602aeb22178d8a" args="(array&lt; TermPtr &gt;^terms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PatternPtr MkPattern           </td>
          <td>(</td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>terms</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a pattern for quantifier instantiation. 
<p>
Z3 uses pattern matching to instantiate quantifiers. If a pattern is not provided for a quantifier, then Z3 will automatically compute a set of patterns for it. However, for optimal performance, the user should provide the patterns.<p>
Patterns comprise an array of terms. The array of terms passed to MkPattern should be non-empty. If the array comprises of more than one term, it is a called a multi-pattern.<p>
In general, one can pass in an array of (multi-)patterns in the quantifier constructor.<p>
To summarize, each quantifier takes an array of alternative multi-patterns. The quantifier is instantiated for every multi-pattern that is matched. Each multi-pattern is an array of terms. All terms must match for the multi-pattern to trigger instantiation. Create a multi-pattern using <code>MkPattern</code>. Create an array of multi-patterns and pass it to the quantifier constructor. If you just want a multi-pattern with a single term, then pass in the singleton array<p>
For example, if you want to create the multi-pattern consisting of the two terms: <code>(store A I V)</code> and <code>(select A J)</code> where A, I, J, V are bound variables, create the pattern<p>
<pre>
           pattern1 = context.MkPattern(new TermPtr[]{ 
                             context.MkArrayStore(A,I,V),
                             context.MkArraySelect(A,J)
                                      })
           </pre> Then form the array <pre> 
                 new PatternPtr[]{ pattern1 }</pre><p>
<pre>           </pre> and pass it to the function <code>MkForall</code> or <code>MkExists</code>. Suppose you also want to have the quantifier be instantiated if the pattern <code>(select (store A I V) J)</code> is matched, then create the pattern: <pre>
           pattern2 = context.MkPattern(new TermPtr[] {
                                         context.MkArraySelect(context.MkArrayStore(A,I,V),J) })
           </pre> Then form the array: <pre>
                 new PatternPtr[] { pattern1, pattern2 }
           </pre><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#d7d64f035d843f300b7fffcfb148e1fe" title="Create a forall formula.">MkForall</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#60c9cdf799990ce4ed2dd7f8caa914e9" title="Create an exists formula. Similar to MkForall.">MkExists</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3f6fe0d5e63e2aec779538fef2669a3c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkQuantifier" ref="3f6fe0d5e63e2aec779538fef2669a3c" args="(bool is_forall, unsigned weight, array&lt; PatternPtr &gt;^patterns, array&lt; TermPtr &gt;^no_patterns, array&lt; SortPtr &gt;^types, array&lt; Symbol^&gt;^names, TermPtr body)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkQuantifier           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>is_forall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; PatternPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>no_patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&gt;^&nbsp;</td>
          <td class="paramname"> <em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>body</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a quantifier with no-pattern directives. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#8a941e796cdc983459602aeb22178d8a" title="Create a pattern for quantifier instantiation.">MkPattern</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#2e1ef04d234928c64248ce7eaf73502a" title="Create a bound variable.">MkBound</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#d7d64f035d843f300b7fffcfb148e1fe" title="Create a forall formula.">MkForall</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#60c9cdf799990ce4ed2dd7f8caa914e9" title="Create an exists formula. Similar to MkForall.">MkExists</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9fc32a94ce1e1064c04f7fe4e1678e81"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkRealSort" ref="9fc32a94ce1e1064c04f7fe4e1678e81" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkRealSort           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a real type. 
<p>
This type is not a floating point number. Z3 does not have support for floating point numbers yet. 
</div>
</div><p>
<a class="anchor" name="5e8abfb87c0e9eb2be93a85af185038e"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkRem" ref="5e8abfb87c0e9eb2be93a85af185038e" args="(TermPtr arg1, TermPtr arg2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkRem           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create integer remainder. 
<p>
The nodes <code>arg1</code> and <code>arg2</code> must have integer type. 
</div>
</div><p>
<a class="anchor" name="443543c80f0ace5c902df3589d3154c4"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetAdd" ref="443543c80f0ace5c902df3589d3154c4" args="(TermPtr set, TermPtr elem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkSetAdd           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>elem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add an element to a set. 
<p>
The first argument must be a set, the second an element. 
<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01760">1760</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01760"></a>01760                                                     {
<a name="l01761"></a>01761             <span class="keywordflow">return</span> TermPtr(Z3_mk_set_add(m_context, get_ast(<span class="keyword">set</span>), get_ast(elem)));
<a name="l01762"></a>01762         }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="e33216f5018efff4077640204c219dc2"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetComplement" ref="e33216f5018efff4077640204c219dc2" args="(TermPtr arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkSetComplement           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Take the complement of a set. 
<p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01796">1796</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01796"></a>01796                                              {
<a name="l01797"></a>01797             <span class="keywordflow">return</span> TermPtr(Z3_mk_set_complement(m_context, get_ast(arg)));
<a name="l01798"></a>01798         }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="99a686c0e68a6862f47f066eac39f84e"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetDel" ref="99a686c0e68a6862f47f066eac39f84e" args="(TermPtr set, TermPtr elem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkSetDel           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>elem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove an element to a set. 
<p>
The first argument must be a set, the second an element. 
<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01769">1769</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01769"></a>01769                                                     {
<a name="l01770"></a>01770             <span class="keywordflow">return</span> TermPtr(Z3_mk_set_del(m_context, get_ast(<span class="keyword">set</span>), get_ast(elem)));
<a name="l01771"></a>01771         }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="d51d6429450362ce9dc9f476b86d22e1"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetDifference" ref="d51d6429450362ce9dc9f476b86d22e1" args="(TermPtr arg1, TermPtr arg2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkSetDifference           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Take the set difference between two sets. 
<p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01790">1790</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01790"></a>01790                                                             {
<a name="l01791"></a>01791             <span class="keywordflow">return</span> TermPtr(Z3_mk_set_difference(m_context, get_ast(arg1), get_ast(arg2)));
<a name="l01792"></a>01792         }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="1bb3e567ae8090d8a659ad556c083e32"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetIntersect" ref="1bb3e567ae8090d8a659ad556c083e32" args="(array&lt; TermPtr &gt;^sets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkSetIntersect           </td>
          <td>(</td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>sets</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Take the intersection of a arrays of sets. 
<p>

</div>
</div><p>
<a class="anchor" name="8449281ead0996eccbe5867d3b6ca96c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetMember" ref="8449281ead0996eccbe5867d3b6ca96c" args="(TermPtr elem, TermPtr set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkSetMember           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>set</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check for set membership. 
<p>
The first argument should be an element type of the set. 
<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01805">1805</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01805"></a>01805                                                        {
<a name="l01806"></a>01806             <span class="keywordflow">return</span> TermPtr(Z3_mk_set_member(m_context, get_ast(elem), get_ast(<span class="keyword">set</span>)));
<a name="l01807"></a>01807         }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="4fd038edb773b86952a3f4890d6bb0f5"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetSort" ref="4fd038edb773b86952a3f4890d6bb0f5" args="(SortPtr ty)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkSetSort           </td>
          <td>(</td>
          <td class="paramtype">SortPtr&nbsp;</td>
          <td class="paramname"> <em>ty</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create Set type. 
<p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01743">1743</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01743"></a>01743 { <span class="keywordflow">return</span> SortPtr(Z3_mk_set_sort(m_context, get_sort_ast(ty))); }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="c05b3fbb60eecb46617782cd53e2b293"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetSubset" ref="c05b3fbb60eecb46617782cd53e2b293" args="(TermPtr arg1, TermPtr arg2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkSetSubset           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check for subsetness of sets. 
<p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01812">1812</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01812"></a>01812                                                         {
<a name="l01813"></a>01813             <span class="keywordflow">return</span> TermPtr(Z3_mk_set_subset(m_context, get_ast(arg1), get_ast(arg2)));
<a name="l01814"></a>01814         }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="72da2154689afc36a91ba955e9ccf081"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSetUnion" ref="72da2154689afc36a91ba955e9ccf081" args="(array&lt; TermPtr &gt;^sets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkSetUnion           </td>
          <td>(</td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>sets</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Take the union of a arrays of sets. 
<p>
The arguments must all be of the same type and all be of set types. 
</div>
</div><p>
<a class="anchor" name="5111a4b70cadfbdb76491c889b57a312"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSort" ref="5111a4b70cadfbdb76491c889b57a312" args="(Symbol^s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkSort           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a free (uninterpreted) type using the given name (symbol). 
<p>
Two free types are considered the same iff the have the same name. 
</div>
</div><p>
<a class="anchor" name="01178a7c619ac2bd6c2e4d4f3da743d2"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSub" ref="01178a7c619ac2bd6c2e4d4f3da743d2" args="(array&lt; TermPtr &gt;^args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkSub           </td>
          <td>(</td>
          <td class="paramtype">array&lt; TermPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>args</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an AST node representing <code>args[0] - ... - args[args.Length - 1]</code>. 
<p>
All arguments must have int or real type.<p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>The number of arguments must be greater than zero. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4e1f9e0325bac5897d7d4099eca72ed0"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkSymbol" ref="4e1f9e0325bac5897d7d4099eca72ed0" args="(int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a> MkSymbol           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a Z3 symbol using an intege or a string. 
<p>
Symbols are used to name several term and type constructors. 
</div>
</div><p>
<a class="anchor" name="b462a1d684499a2265ee02801dfcb4f4"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkTrue" ref="b462a1d684499a2265ee02801dfcb4f4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkTrue           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an AST node representing <code>true</code>. 
<p>

<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l01128">1128</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l01128"></a>01128 { <span class="keywordflow">return</span> TermPtr(<a class="code" href="group__capi.html#ge898e7380409bbc57b56cc5205ef1db7" title="Create an AST node representing true.">Z3_mk_true</a>(m_context)); }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="6af9bcdeb7cc9617f480af2b70a269c0"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkTupleSort" ref="6af9bcdeb7cc9617f480af2b70a269c0" args="(Symbol^mk_tuple_name, array&lt; Symbol^&gt;^field_names, array&lt; SortPtr &gt;^field_types,[Runtime::InteropServices::Out] FuncDeclPtr%mk_tuple_decl,[Runtime::InteropServices::In][Runtime::InteropServices::Out] array&lt; FuncDeclPtr &gt;^proj_decl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortPtr MkTupleSort           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&nbsp;</td>
          <td class="paramname"> <em>mk_tuple_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; <a class="el" href="class_microsoft_1_1_z3_1_1_symbol.html">Symbol</a>^&gt;^&nbsp;</td>
          <td class="paramname"> <em>field_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>field_types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::Out] FuncDeclPtr%&nbsp;</td>
          <td class="paramname"> <em>mk_tuple_decl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::Out] array&lt; FuncDeclPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>proj_decl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a tuple type. 
<p>
A tuple with <code>n</code> fields has a constructor and <code>n</code> projections. This function will also declare the constructor and projection functions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mk_tuple_name</em>&nbsp;</td><td>name of the constructor function associated with the tuple type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>field_names</em>&nbsp;</td><td>name of the projection functions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>field_types</em>&nbsp;</td><td>type of the tuple fields. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mk_tuple_decl</em>&nbsp;</td><td>output parameter that will contain the constructor declaration. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proj_decl</em>&nbsp;</td><td>output parameter that will contain the projection function declarations. This field must be a buffer of size <code>num_fields</code> allocated by the user. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4314bcfc4435b1f79028bc11b8774c28"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkUnaryMinus" ref="4314bcfc4435b1f79028bc11b8774c28" args="(TermPtr arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkUnaryMinus           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>arg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an AST node representing <code>- arg</code>. 
<p>
The argument must have int or real type. 
</div>
</div><p>
<a class="anchor" name="80631b59bd60e34b88cdc676274334b0"></a><!-- doxytag: member="Microsoft::Z3::RawContext::MkXor" ref="80631b59bd60e34b88cdc676274334b0" args="(TermPtr t1, TermPtr t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr MkXor           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create an AST node representing <code>t1 xor t2</code>. 
<p>
The nodes <code>t1</code> and <code>t2</code> must have Boolean type. 
</div>
</div><p>
<a class="anchor" name="96aec8fa83ecdac0ac136c0cf6c74fe8"></a><!-- doxytag: member="Microsoft::Z3::RawContext::OpenLog" ref="96aec8fa83ecdac0ac136c0cf6c74fe8" args="(String^filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OpenLog           </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>filename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Log assertions to a file. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#b100e8973788ce566b11cda8bb09fc32" title="Close file with logged assertions.">CloseLog</a></dd></dl>
Returns <code>true</code> if the open succeeds, otherwise <code>false</code>. 
</div>
</div><p>
<a class="anchor" name="253ab5e7464695d6242629d372b62e24"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ParseSimplifyFile" ref="253ab5e7464695d6242629d372b62e24" args="(String^filename, String^%parser_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr ParseSimplifyFile           </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String^%&nbsp;</td>
          <td class="paramname"> <em>parser_out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse a file containing formulas in the Simplify format. 
<p>
Return conjunction of Asserts occurring in the file. 
</div>
</div><p>
<a class="anchor" name="33c542e7816039e5f121bdbe280c8ef1"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ParseSimplifyString" ref="33c542e7816039e5f121bdbe280c8ef1" args="(String^s, String^%parser_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr ParseSimplifyString           </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String^%&nbsp;</td>
          <td class="paramname"> <em>parser_out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse a string in the simplify format. 
<p>
Return conjunction of Asserts occurring in the string. 
</div>
</div><p>
<a class="anchor" name="256a1746a11837c32de0458e34aedfd2"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ParseSmtlibFile" ref="256a1746a11837c32de0458e34aedfd2" args="(String^file,[Runtime::InteropServices::In] array&lt; SortPtr &gt;^types,[Runtime::InteropServices::In] array&lt; FuncDeclPtr &gt;^old_decls,[Runtime::InteropServices::Out] array&lt; TermPtr &gt;^%assumptions,[Runtime::InteropServices::Out] array&lt; TermPtr &gt;^%formulas,[Runtime::InteropServices::Out] array&lt; FuncDeclPtr &gt;^%new_decls)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParseSmtlibFile           </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::In] array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::In] array&lt; FuncDeclPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>old_decls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::Out] array&lt; TermPtr &gt;^%&nbsp;</td>
          <td class="paramname"> <em>assumptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::Out] array&lt; TermPtr &gt;^%&nbsp;</td>
          <td class="paramname"> <em>formulas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::Out] array&lt; FuncDeclPtr &gt;^%&nbsp;</td>
          <td class="paramname"> <em>new_decls</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#7f0e4f0c8890c7566103ce77c3cc5f92" title="Parse the given string using the SMT-LIB parser.">ParseSmtlibString</a>, but reads the benchmark from a file. 
<p>

</div>
</div><p>
<a class="anchor" name="7f0e4f0c8890c7566103ce77c3cc5f92"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ParseSmtlibString" ref="7f0e4f0c8890c7566103ce77c3cc5f92" args="(String^string,[Runtime::InteropServices::In] array&lt; SortPtr &gt;^types,[Runtime::InteropServices::In] array&lt; FuncDeclPtr &gt;^old_decls,[Runtime::InteropServices::Out] array&lt; TermPtr &gt;^%assumptions,[Runtime::InteropServices::Out] array&lt; TermPtr &gt;^%formulas,[Runtime::InteropServices::Out] array&lt; FuncDeclPtr &gt;^%new_decls)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ParseSmtlibString           </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::In] array&lt; SortPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::In] array&lt; FuncDeclPtr &gt;^&nbsp;</td>
          <td class="paramname"> <em>old_decls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::Out] array&lt; TermPtr &gt;^%&nbsp;</td>
          <td class="paramname"> <em>assumptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::Out] array&lt; TermPtr &gt;^%&nbsp;</td>
          <td class="paramname"> <em>formulas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::Out] array&lt; FuncDeclPtr &gt;^%&nbsp;</td>
          <td class="paramname"> <em>new_decls</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse the given string using the SMT-LIB parser. 
<p>
The symbol table of the parser can be initialized using the given types and declarations. The symbols in the arrays <code>type_names</code> and <code>decl_names</code> don't need to match the names of the types and declarations in the arrays <code>types</code> and <code>decls</code>. This is an useful feature since we can use arbitrary names to reference types and declarations defined using the C API.<p>
The formulas, assumptions and declarations defined in <code>str</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>The string contianing the SMT-LIB benchmark </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>types</em>&nbsp;</td><td>List of auxiliary types used in SMT-LIB benchmark. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>old_decls</em>&nbsp;</td><td>list of declarations to be used for parsing the SMT-LIB string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>assumptions</em>&nbsp;</td><td>returned set of assumptions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>formulas</em>&nbsp;</td><td>returned set of formulas. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_decls</em>&nbsp;</td><td>additional declarations from the SMT-LIB benchmark. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bb1e2e3a1d96aa625758845ed3b8d534"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ParseZ3File" ref="bb1e2e3a1d96aa625758845ed3b8d534" args="(String^filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr ParseZ3File           </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>filename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse a file containing formulas in the Simplify format. 
<p>
Return conjunction of Asserts occurring in the file. 
</div>
</div><p>
<a class="anchor" name="de46bed01c907e799528075996072637"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ParseZ3String" ref="de46bed01c907e799528075996072637" args="(String^s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr ParseZ3String           </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse a string in the native Z3 format. 
<p>
Return conjunction of Asserts occurring in the string. 
</div>
</div><p>
<a class="anchor" name="268029705dabf988d7655c85df1b548e"></a><!-- doxytag: member="Microsoft::Z3::RawContext::PersistTerm" ref="268029705dabf988d7655c85df1b548e" args="(TermPtr t, unsigned num_scopes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PersistTerm           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>num_scopes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Persist a term during num_scopes of pops. 
<p>
Normally, references to terms are no longer valid when popping scopes beyond the level where the terms are created. If you want to reference a term below the scope where it was created, use this method to specify how many pops the term should survive. The current scope level is given as the current total number of calls to push subtracted by the total number of calls to pop. If num_scopes is larger or equal to the current scope level, then the term pointer persists throughout the life-time of the context.<p>
Example usage:<p>
context.Push(); context.Push(); Term t = context.MkNumeral(1, context.MkIntSort()); context.PersistTerm(t, 1); context.Pop(); reference to t is valid. context.Pop(); reference to t is not valid. 
</div>
</div><p>
<a class="anchor" name="ac40326c3b51f26bf05a823061429cc1"></a><!-- doxytag: member="Microsoft::Z3::RawContext::Pop" ref="ac40326c3b51f26bf05a823061429cc1" args="(unsigned num_scopes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Pop           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>num_scopes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Backtrack. 
<p>
Restores the context from the top of the stack, and pops it off the stack. Any changes to the logical context (by <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#48d8c58bf4484b54bf612a3b81526648" title="Assert a constraing into the logical context.">AssertCnstr</a> or other functions) between the matching <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#447d9c1a5a8c1d7ea7ff8d1b8c9a834c" title="Create a backtracking point.">Push</a> and <code>Pop</code> operators are flushed, and the context is completely restored to what it was right before the <a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#447d9c1a5a8c1d7ea7ff8d1b8c9a834c" title="Create a backtracking point.">Push</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num_scopes</em>&nbsp;</td><td>number of scopes to pop. Default value is 1.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#447d9c1a5a8c1d7ea7ff8d1b8c9a834c" title="Create a backtracking point.">Push</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#268029705dabf988d7655c85df1b548e" title="Persist a term during num_scopes of pops.">PersistTerm</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="447d9c1a5a8c1d7ea7ff8d1b8c9a834c"></a><!-- doxytag: member="Microsoft::Z3::RawContext::Push" ref="447d9c1a5a8c1d7ea7ff8d1b8c9a834c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Push           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a backtracking point. 
<p>
The logical context can be viewed as a stack of contexts. The scope level is the number of elements on this stack. The stack of contexts is simulated using trail (undo) stacks.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#ac40326c3b51f26bf05a823061429cc1" title="Backtrack.">Pop</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#268029705dabf988d7655c85df1b548e" title="Persist a term during num_scopes of pops.">PersistTerm</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6bcc908b9ba41cd95dae64006321b34b"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ResetMemory" ref="6bcc908b9ba41cd95dae64006321b34b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ResetMemory           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free all resources allocated for Z3. 
<p>

</div>
</div><p>
<a class="anchor" name="22af33e79aad8e443bfe2c249c6255ef"></a><!-- doxytag: member="Microsoft::Z3::RawContext::SetErrorHandler" ref="22af33e79aad8e443bfe2c249c6255ef" args="(IErrorHandler^h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void SetErrorHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_microsoft_1_1_z3_1_1_i_error_handler.html">IErrorHandler</a>^&nbsp;</td>
          <td class="paramname"> <em>h</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a Z3 error handler. 
<p>
A call to a Z3 function throw <a class="el" href="class_microsoft_1_1_z3_1_1_z3_error.html" title="Z3 error exceptions contain an ErrorCode.">Z3Error</a> when it is not used correctly. An error handler can be registered and will be called in this case prior to throwing <a class="el" href="class_microsoft_1_1_z3_1_1_z3_error.html" title="Z3 error exceptions contain an ErrorCode.">Z3Error</a>. 
</div>
</div><p>
<a class="anchor" name="17471e6be035651820a92e6c4e31d673"></a><!-- doxytag: member="Microsoft::Z3::RawContext::SetPrintMode" ref="17471e6be035651820a92e6c4e31d673" args="(PrintMode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetPrintMode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mapi.html#g8fcc700aeeee633213b4e5f433e5e12e">PrintMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Select mode for the format used for pretty-printing AST nodes. 
<p>
The default mode for pretty printing AST nodes is to produce SMT-LIB style output where common subexpressions are printed at each occurrence. The mode is called PrintMode.SmtlibFull. To print shared common subexpressions only once, use the PrintMode.LowLevel mode. 
</div>
</div><p>
<a class="anchor" name="ea36484f844217cc37a206be0fe565f6"></a><!-- doxytag: member="Microsoft::Z3::RawContext::Simplify" ref="ea36484f844217cc37a206be0fe565f6" args="(TermPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TermPtr Simplify           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interface to simplifier. 
<p>
Provides an interface to the AST simplifier used by Z3. It allows clients to piggyback on top of the AST simplifier for their own term manipulation. 
</div>
</div><p>
<a class="anchor" name="0c7570d3474aec2457249e00de34c51a"></a><!-- doxytag: member="Microsoft::Z3::RawContext::StatisticsToString" ref="0c7570d3474aec2457249e00de34c51a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String StatisticsToString           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert the given logical context into a string. 
<p>
This function is mainly used for debugging purposes. It displays the internal structure of a logical context. 
<p>Definition at line <a class="el" href="_microsoft_8_z3_8h_source.html#l02554">2554</a> of file <a class="el" href="_microsoft_8_z3_8h_source.html">Microsoft.Z3.h</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l02554"></a>02554                                      {
<a name="l02555"></a>02555             <span class="keywordflow">return</span> <span class="keyword">gcnew</span> String(Z3_statistics_to_string(m_context));
<a name="l02556"></a>02556         }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="74d274e8e6fc3ccc4ac39a375c0cc536"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ToggleWarningMessages" ref="74d274e8e6fc3ccc4ac39a375c0cc536" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ToggleWarningMessages           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable or disable warning messages sent to the console out/error. 
<p>
Warnings are printed after passing <code>true</code>, warning messages are suppressed after calling this method with <code>false</code>. 
</div>
</div><p>
<a class="anchor" name="08d99b52685eab1e9d5ac4d9223cb2be"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ToString" ref="08d99b52685eab1e9d5ac4d9223cb2be" args="() override" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual String ToString           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [override, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert the given logical context into a string. 
<p>
This function is mainly used for debugging purposes. It displays the internal structure of a logical context. 
</div>
</div><p>
<a class="anchor" name="eacea454f727994d3088b0a329ce0994"></a><!-- doxytag: member="Microsoft::Z3::RawContext::ToString" ref="eacea454f727994d3088b0a329ce0994" args="(AstPtr a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String ToString           </td>
          <td>(</td>
          <td class="paramtype">AstPtr&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert the given AST node into a string. 
<p>

</div>
</div><p>
<a class="anchor" name="03ea692af0111fc416c43a565f17e938"></a><!-- doxytag: member="Microsoft::Z3::RawContext::TraceOff" ref="03ea692af0111fc416c43a565f17e938" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TraceOff           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disable trace messages. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#f622c78d9a22842b33472d6c1d27b1b4" title="Enable trace messages to a file.">TraceToFile</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#1eec1643da6c92de4e9a5398cb39bb19" title="Enable trace messages to a standard output.">TraceToStdOut</a> <p>
<a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#fa21ce7520ec673cb5c14141d0dd1b55" title="Enable trace messages to a standard error.">TraceToStdErr</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f622c78d9a22842b33472d6c1d27b1b4"></a><!-- doxytag: member="Microsoft::Z3::RawContext::TraceToFile" ref="f622c78d9a22842b33472d6c1d27b1b4" args="(String^trace_file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TraceToFile           </td>
          <td>(</td>
          <td class="paramtype">String^&nbsp;</td>
          <td class="paramname"> <em>trace_file</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable trace messages to a file. 
<p>
When trace messages are enabled, Z3 will record the operations performed on a context in the given file file.<p>
Return <code>true</code> if the file was opened successfully, and <code>false</code> otherwise.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#03ea692af0111fc416c43a565f17e938" title="Disable trace messages.">TraceOff</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="fa21ce7520ec673cb5c14141d0dd1b55"></a><!-- doxytag: member="Microsoft::Z3::RawContext::TraceToStdErr" ref="fa21ce7520ec673cb5c14141d0dd1b55" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TraceToStdErr           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable trace messages to a standard error. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#03ea692af0111fc416c43a565f17e938" title="Disable trace messages.">TraceOff</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1eec1643da6c92de4e9a5398cb39bb19"></a><!-- doxytag: member="Microsoft::Z3::RawContext::TraceToStdOut" ref="1eec1643da6c92de4e9a5398cb39bb19" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TraceToStdOut           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable trace messages to a standard output. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="class_microsoft_1_1_z3_1_1_raw_context.html#03ea692af0111fc416c43a565f17e938" title="Disable trace messages.">TraceOff</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="780dfcb5088965199c45d8a958a489c0"></a><!-- doxytag: member="Microsoft::Z3::RawContext::TryGetArrayValue" ref="780dfcb5088965199c45d8a958a489c0" args="(TermPtr a,[Runtime::InteropServices::Out] RawArrayValue^%av)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TryGetArrayValue           </td>
          <td>(</td>
          <td class="paramtype">TermPtr&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[Runtime::InteropServices::Out] <a class="el" href="class_microsoft_1_1_z3_1_1_raw_array_value.html">RawArrayValue</a>^%&nbsp;</td>
          <td class="paramname"> <em>av</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return decomposed sequence of stores as an array value. 
<p>

</div>
</div><p>
</div>
<div class="tabs"></div>
<address style="text-align: right;">
Last modified Thu Jun 18 11:31:27 2009
</BODY>
</HTML>
