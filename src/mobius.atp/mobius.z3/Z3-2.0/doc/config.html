 <HTML>
    <HEAD>
    <meta name="author" content="Leonardo de Moura" />
    <meta name="author" content="Nikolaj Bjorner" />
    <meta name="description" content="Z3: SMT solver" />
    <meta name="keywords" content="decision procedure, theorem prover, SMT-LIB, SMTLIB, SMT LIB, SMT Solver, SMTCOMP, SMT-COMP, SAT solver, formal methods, constraint solver, software verification, hardware verification" />
      <TITLE>Z3: SMT solver</TITLE>
      <LINK HREF="z3.css" REL="stylesheet" TYPE="text/css">
      <LINK href="tabs.css" rel="stylesheet" type="text/css">
    </HEAD>
<BODY BGCOLOR="#FFFFFF">
<table class="centered-small">
  <tr>
    <th><a href="index.html"><span>Home</span></a></th>
    <th> &bull; </th>
    <th><a href="documentation.html"><span>Docs</span></a></th>
    <th> &bull; </th>
    <th><a href="download.html"><span>Download</span></a></th>
    <th> &bull; </th>
    <th><a href="mail.html"><span>Mail</span></a></th>
    <th> &bull; </th>
    <th><a href="faq.html"><span>FAQ</span></a></th>
    <th> &bull; </th>
    <th><a href="awards.html"><span>Awards</span></a></th>
    <th> &bull; </th>
    <th><a href="status.html"><span>Status</span></a></th>
    <th> &bull; </th>
    <th><a href="http://research.microsoft.com"><span>MSR</span></a></th>
  </tr>
</table>
<p class="Z3Title"><img align="middle" src="z3.png" alt="Z3" /> An Efficient SMT Solver</p>
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1><a class="anchor" name="config">INI parameters </a></h1><ul>
<li><code>ARITH_ADAPTIVE:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>ARITH_ADAPTIVE_ASSERTION_THRESHOLD:</code> <em>double</em>, default: <code>0.2</code>, Delay arithmetic atoms if the num-arith-conflicts/total-conflicts &lt; threshold.</li></ul>
<p>
<ul>
<li><code>ARITH_ADAPTIVE_GCD:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>ARITH_ADAPTIVE_PROPAGATION_THRESHOLD:</code> <em>double</em>, default: <code>0.4</code>, Disable arithmetic theory propagation if the num-arith-conflicts/total-conflicts &lt; threshold.</li></ul>
<p>
<ul>
<li><code>ARITH_ADD_BINARY_BOUNDS:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>ARITH_BLANDS_RULE_THRESHOLD:</code> <em>unsigned</em> <em>integer</em>, default: <code>1000</code> </li></ul>
<p>
<ul>
<li><code>ARITH_BRANCH_CUT_RATIO:</code> <em>unsigned</em> <em>integer</em>, default: <code>2</code> </li></ul>
<p>
<ul>
<li><code>ARITH_DUMP_LEMMAS:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>ARITH_EAGER_EQ_AXIOMS:</code> <em>boolean</em>, default: <code>true</code> </li></ul>
<p>
<ul>
<li><code>ARITH_EAGER_GCD:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>ARITH_EQ_BOUNDS:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>ARITH_EXPAND_EQS:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>ARITH_FORCE_SIMPLEX:</code> <em>boolean</em>, default: <code>false</code>, force Z3 to use simplex solver..</li></ul>
<p>
<ul>
<li><code>ARITH_GCD_TEST:</code> <em>boolean</em>, default: <code>true</code> </li></ul>
<p>
<ul>
<li><code>ARITH_IGNORE_INT:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>ARITH_LAZY_ADAPTER:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>ARITH_LAZY_PIVOTING:</code> <em>unsigned</em> <em>integer</em>, default: <code>0</code> </li></ul>
<p>
<ul>
<li><code>ARITH_MAX_LEMMA_SIZE:</code> <em>unsigned</em> <em>integer</em>, default: <code>128</code> </li></ul>
<p>
<ul>
<li><code>ARITH_PROCESS_ALL_EQS:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>ARITH_PROPAGATE_EQS:</code> <em>boolean</em>, default: <code>true</code> </li></ul>
<p>
<ul>
<li><code>ARITH_PROPAGATION_MODE:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>2</code> </li></ul>
<p>
<ul>
<li><code>ARITH_PROPAGATION_THRESHOLD:</code> <em>unsigned</em> <em>integer</em>, default: <code>4294967295</code> </li></ul>
<p>
<ul>
<li><code>ARITH_PROP_STRATEGY:</code> <em>unsigned</em> <em>integer</em>, max: <code>1</code>, default: <code>1</code>, Propagation strategy: 0 - use agility measures based on ration of theory conflicts, 1 - propagate proportional to ratio of theory conflicts (default).</li></ul>
<p>
<ul>
<li><code>ARITH_RANDOM_INITIAL_VALUE:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>ARITH_RANDOM_LOWER:</code> <em>integer</em>, default: <code>-1000</code> </li></ul>
<p>
<ul>
<li><code>ARITH_RANDOM_SEED:</code> <em>unsigned</em> <em>integer</em>, default: <code>0</code> </li></ul>
<p>
<ul>
<li><code>ARITH_RANDOM_UPPER:</code> <em>integer</em>, default: <code>1000</code> </li></ul>
<p>
<ul>
<li><code>ARITH_REFLECT:</code> <em>boolean</em>, default: <code>true</code> </li></ul>
<p>
<ul>
<li><code>ARITH_SKIP_BIG_COEFFS:</code> <em>boolean</em>, default: <code>true</code> </li></ul>
<p>
<ul>
<li><code>ARITH_SMALL_LEMMA_SIZE:</code> <em>unsigned</em> <em>integer</em>, default: <code>16</code> </li></ul>
<p>
<ul>
<li><code>ARITH_SOLVER:</code> <em>integer</em>, min: <code>0</code>, max: <code>3</code>, default: <code>2</code>, select arithmetic solver: 0 - no solver, 1 - bellman-ford based solver (diff. logic only), 2 - simplex based solver, 3 - floyd-warshall based solver (diff. logic only) and no theory combination.</li></ul>
<p>
<ul>
<li><code>ARITH_STRONGER_LEMMAS:</code> <em>boolean</em>, default: <code>true</code> </li></ul>
<p>
<ul>
<li><code>ARRAY_ALWAYS_PROP_UPWARD:</code> <em>boolean</em>, default: <code>false</code>, Disable the built-in filter upwards propagation.</li></ul>
<p>
<ul>
<li><code>ARRAY_CG:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>ARRAY_DELAY_EXP_AXIOM:</code> <em>boolean</em>, default: <code>true</code> </li></ul>
<p>
<ul>
<li><code>ARRAY_EXTENSIONAL:</code> <em>boolean</em>, default: <code>true</code> </li></ul>
<p>
<ul>
<li><code>ARRAY_LAZINESS:</code> <em>unsigned</em> <em>integer</em>, default: <code>1</code> </li></ul>
<p>
<ul>
<li><code>ARRAY_LAZY_IEQ:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>ARRAY_LAZY_IEQ_DELAY:</code> <em>unsigned</em> <em>integer</em>, default: <code>10</code> </li></ul>
<p>
<ul>
<li><code>ARRAY_PROPERTY:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>ARRAY_SOLVER:</code> <em>integer</em>, min: <code>0</code>, max: <code>3</code>, default: <code>1</code>, 0 - no array, 1 - simple, 2 - model based, 3 - full.</li></ul>
<p>
<ul>
<li><code>ARRAY_WEAK:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>ASYNC_COMMANDS:</code> <em>boolean</em>, default: <code>true</code>, enable/disable support for asynchronous commands in the Simplify front-end..</li></ul>
<p>
<ul>
<li><code>AT_LABELS_CEX:</code> <em>boolean</em>, default: <code>false</code>, only use labels that contain '@' when building multiple counterexamples.</li></ul>
<p>
<ul>
<li><code>AUTO_CONFIG:</code> <em>boolean</em>, default: <code>true</code>, use heuristics to set Z3 configuration parameters, it is only available for the SMT-LIB input format.</li></ul>
<p>
<ul>
<li><code>BB_EAGER:</code> <em>boolean</em>, default: <code>false</code>, eager bit blasting.</li></ul>
<p>
<ul>
<li><code>BB_EXT_GATES:</code> <em>boolean</em>, default: <code>false</code>, use extended gates during bit-blasting.</li></ul>
<p>
<ul>
<li><code>BB_QUANTIFIERS:</code> <em>boolean</em>, default: <code>false</code>, convert bit-vectors to Booleans in quantifiers.</li></ul>
<p>
<ul>
<li><code>BIN_CLAUSES:</code> <em>boolean</em>, default: <code>true</code> </li></ul>
<p>
<ul>
<li><code>BIT2BOOL:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>BV_BLAST_MAX_SIZE:</code> <em>unsigned</em> <em>integer</em>, default: <code>2147483647</code>, Maximal size for bit-vectors to blast.</li></ul>
<p>
<ul>
<li><code>BV_CC:</code> <em>boolean</em>, default: <code>false</code>, enable congruence closure for BV operators.</li></ul>
<p>
<ul>
<li><code>BV_LAZY_LE:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>BV_MAX_SHARING:</code> <em>boolean</em>, default: <code>true</code> </li></ul>
<p>
<ul>
<li><code>BV_REFLECT:</code> <em>boolean</em>, default: <code>true</code> </li></ul>
<p>
<ul>
<li><code>BV_SOLVER:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>1</code>, 0 - no bv, 1 - simple.</li></ul>
<p>
<ul>
<li><code>BWD_S:</code> <em>boolean</em>, default: <code>false</code>, propositional backward subsumption.</li></ul>
<p>
<ul>
<li><code>BWD_SR:</code> <em>boolean</em>, default: <code>false</code>, propositional backward subsumption resolution.</li></ul>
<p>
<ul>
<li><code>CASE_SPLIT:</code> <em>integer</em>, min: <code>0</code>, max: <code>5</code>, default: <code>1</code>, 0 - case split based on variable activity, 1 - similar to 0, but delay case splits created during the search, 2 - similar to 0, but cache the relevancy, 3 - case split based on relevancy (structural splitting), 4 - case split on relevancy and activity, 5 - case split on relevancy and current goal.</li></ul>
<p>
<ul>
<li><code>CHECK_AT_LABELS:</code> <em>boolean</em>, default: <code>false</code>, check that labels containing '@' are used correctly to only produce unique counter examples.</li></ul>
<p>
<ul>
<li><code>CHECK_PROOF:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>CNF_FACTOR:</code> <em>unsigned</em> <em>integer</em>, default: <code>4</code>, the maximum number of clauses that can be created when converting a subformula.</li></ul>
<p>
<ul>
<li><code>CNF_MODE:</code> <em>integer</em>, min: <code>0</code>, max: <code>3</code>, default: <code>0</code>, CNF translation mode: 0 - disabled, 1 - quantifiers in CNF, 2 - 0 + opportunistic, 3 - full.</li></ul>
<p>
<ul>
<li><code>COMPLETE_INST:</code> <em>boolean</em>, default: <code>false</code>, complete quantifier instantiation.</li></ul>
<p>
<ul>
<li><code>CONTEXT_SIMPLIFIER:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>CR_STRATEGY:</code> <em>integer</em>, min: <code>0</code>, max: <code>1</code>, default: <code>0</code>, 0 - FUIP, 1 - All decided.</li></ul>
<p>
<ul>
<li><code>DACK:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>1</code>, 0 - disable dynamic ackermannization, 1 - expand Leibniz's axiom if a congruence is the root of a conflict, 2 - expand Leibniz's axiom if a congruence is used during conflict resolution..</li></ul>
<p>
<ul>
<li><code>DACK_FACTOR:</code> <em>double</em>, default: <code>0.1</code>, number of instance per conflict.</li></ul>
<p>
<ul>
<li><code>DACK_GC:</code> <em>unsigned</em> <em>integer</em>, default: <code>2000</code>, Dynamic ackermannization garbage collection frequency (per conflict)..</li></ul>
<p>
<ul>
<li><code>DACK_GC_INV_DECAY:</code> <em>double</em>, default: <code>0.8</code> </li></ul>
<p>
<ul>
<li><code>DACK_THRESHOLD:</code> <em>unsigned</em> <em>integer</em>, default: <code>10</code>, number of times the congruence rule must be used before Leibniz's axiom is expanded.</li></ul>
<p>
<ul>
<li><code>DEFAULT_QID:</code> <em>boolean</em>, default: <code>false</code>, create a default quantifier id based on its position, the id is used to report profiling information (see QI_PROFILE).</li></ul>
<p>
<ul>
<li><code>DELAY_UNITS:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>DELAY_UNITS_THRESHOLD:</code> <em>unsigned</em> <em>integer</em>, default: <code>32</code> </li></ul>
<p>
<ul>
<li><code>DER:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>DISPLAY_DIMACS_AT_END:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>DISPLAY_DOT_PROOF:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>DISPLAY_FEATURES:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>DISPLAY_PROOF:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>DISPLAY_UNSAT_CORE:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>DT_LAZY_SPLITS:</code> <em>unsigned</em> <em>integer</em>, default: <code>1</code>, How lazy datatype splits are performed: 0- eager, 1- lazy for infinite types, 2- lazy.</li></ul>
<p>
<ul>
<li><code>DUMP_GOAL_AS_SMT:</code> <em>boolean</em>, default: <code>false</code>, write goal back to output in SMT format.</li></ul>
<p>
<ul>
<li><code>ELIM_AND:</code> <em>boolean</em>, default: <code>true</code>, represent (and a b) as (not (or (not a) (not b))).</li></ul>
<p>
<ul>
<li><code>ELIM_BOUNDS:</code> <em>boolean</em>, default: <code>false</code>, cheap Fourier-Motzkin.</li></ul>
<p>
<ul>
<li><code>ELIM_TERM_ITE:</code> <em>boolean</em>, default: <code>false</code>, eliminate term if-then-else in the preprocessor.</li></ul>
<p>
<ul>
<li><code>EMATCHING:</code> <em>boolean</em>, default: <code>true</code>, E-Matching based quantifier instantiation.</li></ul>
<p>
<ul>
<li><code>EQ_PROPAGATION:</code> <em>boolean</em>, default: <code>true</code> </li></ul>
<p>
<ul>
<li><code>FM:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>FM_THRESHOLD:</code> <em>unsigned</em> <em>integer</em>, default: <code>1000</code> </li></ul>
<p>
<ul>
<li><code>FWD_SR:</code> <em>boolean</em>, default: <code>false</code>, propositional forward subsumption resolution.</li></ul>
<p>
<ul>
<li><code>FWD_SR_CHEAP:</code> <em>boolean</em>, default: <code>false</code>, propositional forward subsumption resolution using only binary clauses.</li></ul>
<p>
<ul>
<li><code>HI_DIV0:</code> <em>boolean</em>, default: <code>false</code>, if true, then Z3 uses the usual hardware interpretation for division (rem, mod) by zero. Otherwise, these operations are considered uninterpreted..</li></ul>
<p>
<ul>
<li><code>IGNORE_SETPARAMETER:</code> <em>boolean</em>, default: <code>false</code>, ignore (SETPARAMETER ...) commands in Simplify format input.</li></ul>
<p>
<ul>
<li><code>INSTRUCTION_MAX:</code> <em>double</em>, default: <code>0</code>, set the (approximate) maximal number of instructions per invocation of check.</li></ul>
<p>
<ul>
<li><code>INTERACTIVE:</code> <em>boolean</em>, default: <code>false</code>, enable interactive mode using Simplify input format.</li></ul>
<p>
<ul>
<li><code>INTERNALIZER_NNF:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>LEMMA_GC_FACTOR:</code> <em>double</em>, default: <code>1.1</code>, used by geometric strategy.</li></ul>
<p>
<ul>
<li><code>LEMMA_GC_HALF:</code> <em>boolean</em>, default: <code>false</code>, true for simple gc algorithm (delete approx. half of the clauses).</li></ul>
<p>
<ul>
<li><code>LEMMA_GC_INITIAL:</code> <em>unsigned</em> <em>integer</em>, default: <code>5000</code>, lemma initial gc frequency (in number of conflicts), used by fixed or geometric strategies.</li></ul>
<p>
<ul>
<li><code>LEMMA_GC_NEW_CLAUSE_ACTIVITY:</code> <em>unsigned</em> <em>integer</em>, default: <code>10</code> </li></ul>
<p>
<ul>
<li><code>LEMMA_GC_NEW_CLAUSE_RELEVANCY:</code> <em>unsigned</em> <em>integer</em>, default: <code>45</code> </li></ul>
<p>
<ul>
<li><code>LEMMA_GC_NEW_OLD_RATIO:</code> <em>unsigned</em> <em>integer</em>, default: <code>16</code> </li></ul>
<p>
<ul>
<li><code>LEMMA_GC_OLD_CLAUSE_ACTIVITY:</code> <em>unsigned</em> <em>integer</em>, default: <code>500</code> </li></ul>
<p>
<ul>
<li><code>LEMMA_GC_OLD_CLAUSE_RELEVANCY:</code> <em>unsigned</em> <em>integer</em>, default: <code>500</code> </li></ul>
<p>
<ul>
<li><code>LEMMA_GC_STRATEGY:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>0</code>, 0 - fixed, 1 - geometric, 2 - at every restart.</li></ul>
<p>
<ul>
<li><code>LIFT_ITE:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>0</code>, ite term lifting: 0 - no lifting, 1 - conservative, 2 - full.</li></ul>
<p>
<ul>
<li><code>LOOKAHEAD:</code> <em>boolean</em>, default: <code>false</code>, enable lookahead propagation heuristic.</li></ul>
<p>
<ul>
<li><code>LOOKAHEAD_DISEQ:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>MACRO_EXPANSION:</code> <em>boolean</em>, default: <code>false</code>, expand quantifiers that are macros.</li></ul>
<p>
<ul>
<li><code>MAX_CONFLICTS:</code> <em>unsigned</em> <em>integer</em>, default: <code>4294967295</code>, maximum number of conflicts.</li></ul>
<p>
<ul>
<li><code>MAX_COUNTEREXAMPLES:</code> <em>unsigned</em> <em>integer</em>, default: <code>1</code>, set the maximum number of counterexamples when using Simplify front end.</li></ul>
<p>
<ul>
<li><code>MEMORY_HIGH_WATERMARK:</code> <em>unsigned</em> <em>integer</em>, default: <code>0</code>, set high watermark for memory consumption (in megabytes).</li></ul>
<p>
<ul>
<li><code>MEMORY_MAX_SIZE:</code> <em>unsigned</em> <em>integer</em>, default: <code>0</code>, set hard upper limit for memory consumption (in megabytes).</li></ul>
<p>
<ul>
<li><code>MINIMIZE_LEMMAS:</code> <em>boolean</em>, default: <code>true</code>, enable/disable lemma minimization algorithm.</li></ul>
<p>
<ul>
<li><code>MINIMIZE_LEMMAS_STRUCT:</code> <em>boolean</em>, default: <code>false</code>, enable/disable structural lemma minimization algorithm.</li></ul>
<p>
<ul>
<li><code>MODEL:</code> <em>boolean</em>, default: <code>false</code>, enable/disable model construction.</li></ul>
<p>
<ul>
<li><code>MODEL_COMPACT:</code> <em>boolean</em>, default: <code>false</code>, try to compact function graph (i.e., function interpretations that are lookup tables.</li></ul>
<p>
<ul>
<li><code>MODEL_HIDE_UNUSED_PARTITIONS:</code> <em>boolean</em>, default: <code>true</code>, hide unused partitions, some partitions are associated with internal terms/formulas created by Z3.</li></ul>
<p>
<ul>
<li><code>MODEL_ON_FINAL_CHECK:</code> <em>boolean</em>, default: <code>false</code>, display candidate model (in the standard output) whenever Z3 hits a final check.</li></ul>
<p>
<ul>
<li><code>MODEL_ON_TIMEOUT:</code> <em>boolean</em>, default: <code>false</code>, after hitting soft-timeout or memory high watermark, generate a candidate model.</li></ul>
<p>
<ul>
<li><code>MODEL_PARTIAL:</code> <em>boolean</em>, default: <code>false</code>, enable/disable partial function interpretations.</li></ul>
<p>
<ul>
<li><code>MODEL_V1:</code> <em>boolean</em>, default: <code>false</code>, use Z3 version 1.x pretty printer.</li></ul>
<p>
<ul>
<li><code>MODEL_VALIDATE:</code> <em>boolean</em>, default: <code>false</code>, validate the model.</li></ul>
<p>
<ul>
<li><code>MODEL_VALUE_COMPLETION:</code> <em>boolean</em>, default: <code>true</code>, associate a value with each partition, in the (untyped) Simplify front-end, Z3 internally assumes that everything is an integer, so it may be convenient to use MODEL_VALUE_COMPLETION=false, this option must not be used from the C and Managed APIs.</li></ul>
<p>
<ul>
<li><code>NEW_CORE2TH_EQ:</code> <em>boolean</em>, default: <code>true</code> </li></ul>
<p>
<ul>
<li><code>NG_LIFT_ITE:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>0</code>, ite (non-ground) term lifting: 0 - no lifting, 1 - conservative, 2 - full.</li></ul>
<p>
<ul>
<li><code>NL_ARITH:</code> <em>boolean</em>, default: <code>true</code>, enable/disable non linear arithmetic support. This option is ignored when ARITH_SOLVER != 2..</li></ul>
<p>
<ul>
<li><code>NL_ARITH_BRANCHING:</code> <em>boolean</em>, default: <code>true</code>, enable/disable branching on integer variables in non linear clusters.</li></ul>
<p>
<ul>
<li><code>NL_ARITH_GB:</code> <em>boolean</em>, default: <code>true</code>, enable/disable Grobner Basis computation. This option is ignored when NL_ARITH=false.</li></ul>
<p>
<ul>
<li><code>NL_ARITH_GB_EQS:</code> <em>boolean</em>, default: <code>false</code>, enable/disable equations in the Grobner Basis to be copied to the Simplex tableau..</li></ul>
<p>
<ul>
<li><code>NL_ARITH_GB_PERTURBATE:</code> <em>boolean</em>, default: <code>true</code>, enable/disable perturbation of the variable order in GB when searching for new polynomials..</li></ul>
<p>
<ul>
<li><code>NL_ARITH_GB_THRESHOLD:</code> <em>unsigned</em> <em>integer</em>, default: <code>512</code>, Grobner basis computation can be very expensive. This is a threshold on the number of new equalities that can be generated..</li></ul>
<p>
<ul>
<li><code>NL_ARITH_MAX_DEGREE:</code> <em>unsigned</em> <em>integer</em>, default: <code>6</code>, max degree for internalizing new monomials..</li></ul>
<p>
<ul>
<li><code>NL_ARITH_ROUNDS:</code> <em>unsigned</em> <em>integer</em>, default: <code>1024</code>, threshold for number of (nested) final checks for non linear arithmetic..</li></ul>
<p>
<ul>
<li><code>NNF_FACTOR:</code> <em>unsigned</em> <em>integer</em>, default: <code>4</code>, the maximum growth factor during NNF translation (auxiliary definitions are introduced if the threshold is reached).</li></ul>
<p>
<ul>
<li><code>NNF_IGNORE_LABELS:</code> <em>boolean</em>, default: <code>false</code>, remove/ignore labels in the input formula, this option is ignored if proofs are enabled.</li></ul>
<p>
<ul>
<li><code>NNF_MODE:</code> <em>integer</em>, min: <code>0</code>, max: <code>3</code>, default: <code>0</code>, NNF translation mode: 0 - skolem normal form, 1 - 0 + quantifiers in NNF, 2 - 1 + opportunistic, 3 - full.</li></ul>
<p>
<ul>
<li><code>NNF_SK_HACK:</code> <em>boolean</em>, default: <code>false</code>, hack for VCC.</li></ul>
<p>
<ul>
<li><code>ORDER:</code> <em>integer</em>, min: <code>0</code>, max: <code>1</code>, default: <code>0</code>, Term ordering: 0 - KBO, 1 - LPO.</li></ul>
<p>
<ul>
<li><code>ORDER_VAR_WEIGHT:</code> <em>unsigned</em> <em>integer</em>, default: <code>1</code>, weight of variables in term orderings (e.g., KBO).</li></ul>
<p>
<ul>
<li><code>ORDER_WEIGHTS:</code> <em>list</em> <em>of</em> <em>pairs:</em> <em>symbols(strings)</em> <em>x</em> <em>unsigned</em>, describe a (partial) assignment of weights to function symbols for term orderings (e.g., KBO). The assigment is a list of pairs of the form f:n where f is a string and n is a natural. Example: WEIGHTS="(f:1, g:2, h:3)".</li></ul>
<p>
<ul>
<li><code>PHASE_SELECTION:</code> <em>integer</em>, min: <code>0</code>, max: <code>6</code>, default: <code>3</code>, phase selection heuristic: 0 - always false, 1 - always true, 2 - phase caching, 3 - phase caching conservative, 4 - phase caching conservative 2, 5 - random, 6 - number of occurrences.</li></ul>
<p>
<ul>
<li><code>PI_ARITH:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>1</code>, 0 - do not infer patterns with arithmetic terms, 1 - use patterns with arithmetic terms if there is no other pattern, 2 - always use patterns with arithmetic terms..</li></ul>
<p>
<ul>
<li><code>PI_ARITH_WEIGHT:</code> <em>unsigned</em> <em>integer</em>, default: <code>5</code>, default weight for quantifiers where the only available pattern has nested arithmetic terms..</li></ul>
<p>
<ul>
<li><code>PI_AVOID_EVIL_SELECT:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>PI_AVOID_SHALLOW_SELECT:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>PI_AVOID_SKOLEMS:</code> <em>boolean</em>, default: <code>true</code> </li></ul>
<p>
<ul>
<li><code>PI_BLOCK_LOOOP_PATTERNS:</code> <em>boolean</em>, default: <code>true</code>, block looping patterns during pattern inference.</li></ul>
<p>
<ul>
<li><code>PI_HACKED_SHALLOW_SELECT:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>PI_MAX_MULTI_PATTERNS:</code> <em>unsigned</em> <em>integer</em>, default: <code>0</code>, when patterns are not provided, the prover uses a heuristic to infer them. This option sets the threshold on the number of extra multi-patterns that can be created. By default, the prover creates at most one multi-pattern when there is no unary pattern.</li></ul>
<p>
<ul>
<li><code>PI_NON_NESTED_ARITH_WEIGHT:</code> <em>unsigned</em> <em>integer</em>, default: <code>10</code>, default weight for quantifiers where the only available pattern has non nested arithmetic terms..</li></ul>
<p>
<ul>
<li><code>PI_NON_SUBSUMER_SELECT:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>PI_NOPAT_WEIGHT:</code> <em>integer</em>, default: <code>-1</code>, set weight of quantifiers without patterns, if negative the weight is not changed..</li></ul>
<p>
<ul>
<li><code>PI_PULL_QUANTIFIERS:</code> <em>boolean</em>, default: <code>true</code>, pull nested quantifiers, if no pattern was found..</li></ul>
<p>
<ul>
<li><code>PI_USE_DATABASE:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>PP_BOUNDED:</code> <em>boolean</em>, default: <code>false</code>, ignore characters exceeding max widht.</li></ul>
<p>
<ul>
<li><code>PP_FIXED_INDENT:</code> <em>boolean</em>, default: <code>false</code>, use a fixed indentation for applications.</li></ul>
<p>
<ul>
<li><code>PP_MAX_INDENT:</code> <em>unsigned</em> <em>integer</em>, default: <code>4294967295</code>, max. indentation in pretty printer.</li></ul>
<p>
<ul>
<li><code>PP_MAX_NUM_LINES:</code> <em>unsigned</em> <em>integer</em>, default: <code>4294967295</code>, max. number of lines to be displayed in pretty printer.</li></ul>
<p>
<ul>
<li><code>PP_MAX_RIBBON:</code> <em>unsigned</em> <em>integer</em>, default: <code>80</code>, max. ribbon (width - indentation) in pretty printer.</li></ul>
<p>
<ul>
<li><code>PP_MAX_WIDTH:</code> <em>unsigned</em> <em>integer</em>, default: <code>80</code>, max. width in pretty printer.</li></ul>
<p>
<ul>
<li><code>PP_SINGLE_LINE:</code> <em>boolean</em>, default: <code>false</code>, ignore line breaks when true.</li></ul>
<p>
<ul>
<li><code>PRECEDENCE:</code> <em>list</em> <em>of</em> <em>symbols</em> <em></em>(strings), describe a (partial) precedence for the term ordering used in the Superposition Calculus module. The precedence is lists of function symbols. Example: PRECEDENCE="(f, g, h)".</li></ul>
<p>
<ul>
<li><code>PRECEDENCE_GEN:</code> <em>list</em> <em>of</em> <em>symbols</em> <em></em>(strings), describe how a total precedence order is generated. The generator is a sequence of simple (partial) orders with an optional '-' (indicating the next (partial) order should be inverted). The available simple (partial) orders are: user (the order specified by precedence); arity; interpreted (interpreted function symbols are considered smaller); definition (defined function symbols are considered bigger); frequency; arbitrary (total arbitrary order generated by Z3). Example: PRECEDENCE_GEN="user interpreted - arity arbitraty".</li></ul>
<p>
<ul>
<li><code>PRE_SIMPLIFIER:</code> <em>boolean</em>, default: <code>true</code> </li></ul>
<p>
<ul>
<li><code>PRE_SIMPLIFY_EXPR:</code> <em>boolean</em>, default: <code>true</code>, pre-simplify expressions when created over the API (example: -x -&gt; (* -1 x)).</li></ul>
<p>
<ul>
<li><code>PROFILE_RES_SUB:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>PROGRESS_SAMPLING_FREQ:</code> <em>unsigned</em> <em>integer</em>, default: <code>0</code>, frequency for progress output in miliseconds.</li></ul>
<p>
<ul>
<li><code>PROOF_MODE:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>0</code>, select proof generation mode: 0 - disabled, 1 - coarse grain, 2 - fine grain.</li></ul>
<p>
<ul>
<li><code>PROPAGATE_BOOLEANS:</code> <em>boolean</em>, default: <code>false</code>, propagate boolean values during preprocessing step.</li></ul>
<p>
<ul>
<li><code>PROPAGATE_VALUES:</code> <em>boolean</em>, default: <code>true</code>, propagate values during preprocessing step.</li></ul>
<p>
<ul>
<li><code>PULL_CHEAP_ITE_TREES:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>QI_CONSERVATIVE_FINAL_CHECK:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>QI_COST:</code> <em>string</em>, default: (* weight generation), The cost function for quantifier instantiation.</li></ul>
<p>
<ul>
<li><code>QI_EAGER_THRESHOLD:</code> <em>double</em>, default: <code>10</code>, Threshold for eager quantifier instantiation.</li></ul>
<p>
<ul>
<li><code>QI_INC_GEN:</code> <em>string</em>, default: weight, The function for calculating the generation increment.</li></ul>
<p>
<ul>
<li><code>QI_ITERATIVE_DEEPENING:</code> <em>boolean</em>, default: <code>false</code>, Use iterative deepening for eager quantifier instantiation.</li></ul>
<p>
<ul>
<li><code>QI_ITERATIVE_DEEPENING_DECR:</code> <em>double</em>, default: <code>0</code>, Decrement for iterative deepening (eager quantifier instantiation).</li></ul>
<p>
<ul>
<li><code>QI_ITERATIVE_DEEPENING_INCR:</code> <em>double</em>, default: <code>1</code>, Increment for iterative deepening (eager quantifier instantiation).</li></ul>
<p>
<ul>
<li><code>QI_LAZY_INSTANTIATION:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>QI_LAZY_MODEL_CHECKER:</code> <em>boolean</em>, default: <code>true</code> </li></ul>
<p>
<ul>
<li><code>QI_LAZY_THRESHOLD:</code> <em>double</em>, default: <code>100</code>, Threshold for lazy quantifier instantiation.</li></ul>
<p>
<ul>
<li><code>QI_MAX_EAGER_MULTI_PATTERNS:</code> <em>unsigned</em> <em>integer</em>, default: <code>0</code>, Specify the number of extra multi patterns that are processed eagerly. By default, the prover use at most one multi-pattern eagerly when there is no unary pattern. This value should be smaller than or equal to PI_MAX_MULTI_PATTERNS.</li></ul>
<p>
<ul>
<li><code>QI_MAX_INSTANCES:</code> <em>unsigned</em> <em>integer</em>, default: <code>4294967295</code> </li></ul>
<p>
<ul>
<li><code>QI_MAX_LAZY_MULTI_PATTERN_MATCHING:</code> <em>unsigned</em> <em>integer</em>, default: <code>2</code>, Maximum number of rounds of matching in a branch for delayed multipatterns. A multipattern is delayed based on the value of QI_MAX_EAGER_MULTI_PATTERNS.</li></ul>
<p>
<ul>
<li><code>QI_MODEL_CHECKER:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>0</code>, 0 - do not use model checker, 1 - instantiate instances unsatisfied by current model, 2 - 1 + instantiate instances not satisfied by current model.</li></ul>
<p>
<ul>
<li><code>QI_PROFILE:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>QI_PROFILE_FREQ:</code> <em>unsigned</em> <em>integer</em>, default: <code>4294967295</code> </li></ul>
<p>
<ul>
<li><code>QI_PROMOTE_UNSAT:</code> <em>boolean</em>, default: <code>true</code> </li></ul>
<p>
<ul>
<li><code>QI_TRACK_INSTANCES:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>QUANT_FM:</code> <em>boolean</em>, default: <code>false</code>, apply Fourier-Motzkin variable elimination (for quantifiers) during preprocessing step.</li></ul>
<p>
<ul>
<li><code>RANDOM_CASE_SPLIT_FREQ:</code> <em>percentage</em>, default: <code>0.01</code>, frequency of random case splits.</li></ul>
<p>
<ul>
<li><code>RANDOM_INITIAL_ACTIVITY:</code> <em>integer</em>, min: <code>0</code>, max: <code>2</code>, default: <code>1</code> </li></ul>
<p>
<ul>
<li><code>RANDOM_SEED:</code> <em>unsigned</em> <em>integer</em>, default: <code>0</code>, random seed for Z3.</li></ul>
<p>
<ul>
<li><code>RECENT_LEMMA_THRESHOLD:</code> <em>unsigned</em> <em>integer</em>, default: <code>100</code> </li></ul>
<p>
<ul>
<li><code>REFINE_INJ_AXIOM:</code> <em>boolean</em>, default: <code>true</code> </li></ul>
<p>
<ul>
<li><code>RELEVANCY:</code> <em>unsigned</em> <em>integer</em>, default: <code>2</code>, relevancy propagation heuristic: 0 - disabled, 1 - relevancy is tracked by only affects quantifier instantiation, 2 - relevancy is tracked, and an atom is only asserted if it is relevant.</li></ul>
<p>
<ul>
<li><code>RELEVANCY_LEMMA:</code> <em>boolean</em>, default: <code>false</code>, true if lemmas are used to propagate relevancy.</li></ul>
<p>
<ul>
<li><code>REL_CASE_SPLIT_ORDER:</code> <em>unsigned</em> <em>integer</em>, max: <code>2</code>, default: <code>0</code>, structural (relevancy) splitting order: 0 - left-to-right (default), 1 - random, 2 - right-to-left.</li></ul>
<p>
<ul>
<li><code>RESOLUTION:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>RESOLUTION_THRESHOLD:</code> <em>unsigned</em> <em>integer</em>, default: <code>1000</code> </li></ul>
<p>
<ul>
<li><code>RESTART_ADAPTIVE:</code> <em>boolean</em>, default: <code>true</code>, disable restarts based on the search 'agility'.</li></ul>
<p>
<ul>
<li><code>RESTART_AGILITY_THRESHOLD:</code> <em>percentage</em>, default: <code>0.18</code> </li></ul>
<p>
<ul>
<li><code>RESTART_FACTOR:</code> <em>double</em>, default: <code>1.1</code>, when using geometric (or inner-outer-geometric) progression of restarts, it specifies the constant used to multiply the currect restart threshold.</li></ul>
<p>
<ul>
<li><code>RESTART_INITIAL:</code> <em>unsigned</em> <em>integer</em>, default: <code>100</code>, inital restart frequency in number of conflicts, it is also the unit for the luby sequence.</li></ul>
<p>
<ul>
<li><code>RESTART_STRATEGY:</code> <em>integer</em>, min: <code>0</code>, max: <code>5</code>, default: <code>1</code>, 0 - geometric, 1 - inner-outer-geometric, 2 - luby, 3 - fixed, 4 - arithmetic, 5 - dynamic.</li></ul>
<p>
<ul>
<li><code>REVERSE_IMPLIES:</code> <em>boolean</em>, default: <code>false</code>, treat (implies a b) as (or b (not a)), not (or (not a) b) (for CASE_SPLIT=3,4).</li></ul>
<p>
<ul>
<li><code>SATURATE:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>SIMPLIFY_CLAUSES:</code> <em>boolean</em>, default: <code>true</code> </li></ul>
<p>
<ul>
<li><code>SMT:</code> <em>boolean</em>, default: <code>true</code>, true : SMT prover, false : SPC prover.</li></ul>
<p>
<ul>
<li><code>SMTLIB_CATEGORY:</code> <em>string</em>, default: , additional category info to add to SMTLIB benchmark.</li></ul>
<p>
<ul>
<li><code>SMTLIB_DUMP_ASSERTIONS:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>SMTLIB_DUMP_LEMMAS:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>SMTLIB_DUMP_UNSAT_CORE:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>SMTLIB_LOGIC:</code> <em>string</em>, default:</li></ul>
<p>
<ul>
<li><code>SMTLIB_SOURCE_INFO:</code> <em>string</em>, default: , additional source info to add to SMTLIB benchmark.</li></ul>
<p>
<ul>
<li><code>SMTLIB_TRACE_PATH:</code> <em>string</em>, default: , path for converting Z3 formulas to SMTLIB benchmarks.</li></ul>
<p>
<ul>
<li><code>SMT_LOGIC_NAME:</code> <em>string</em>, default: AUFLIA, logic name for SMT benchmark.</li></ul>
<p>
<ul>
<li><code>SOFT_TIMEOUT:</code> <em>unsigned</em> <em>integer</em>, default: <code>0</code>, set approximate timeout for each solver query (milliseconds), the value 0 represents no timeout.</li></ul>
<p>
<ul>
<li><code>SOLVER:</code> <em>boolean</em>, default: <code>false</code>, enable solver during preprocessing step.</li></ul>
<p>
<ul>
<li><code>SORT_AND_OR:</code> <em>boolean</em>, default: <code>true</code>, sort the arguments of 'and'/'or' connectives.</li></ul>
<p>
<ul>
<li><code>SPC:</code> <em>boolean</em>, default: <code>false</code>, DPLL(SP): DPLL + superposition calculus.</li></ul>
<p>
<ul>
<li><code>SPC_BS:</code> <em>boolean</em>, default: <code>true</code>, Enable/disable backward subsumption in the superposition engine.</li></ul>
<p>
<ul>
<li><code>SPC_ES:</code> <em>boolean</em>, default: <code>true</code>, Enable/disable equality resolution in the superposition engine.</li></ul>
<p>
<ul>
<li><code>SPC_FACTOR_SUBSUMPTION_INDEX_OPT:</code> <em>double</em>, default: <code>1.5</code>, after each optimization the threshold for optimization is increased by this factor. See INITIAL_SUBSUMPTION_INDEX_OPT..</li></ul>
<p>
<ul>
<li><code>SPC_INITIAL_SUBSUMPTION_INDEX_OPT:</code> <em>unsigned</em> <em>integer</em>, default: <code>1000</code>, after how many processed clauses the subsumption index is optimized..</li></ul>
<p>
<ul>
<li><code>SPC_MAX_SUBSUMPTION_INDEX_FEATURES:</code> <em>unsigned</em> <em>integer</em>, default: <code>32</code>, maximum number of features to be used for subsumption index..</li></ul>
<p>
<ul>
<li><code>SPC_MIN_FUNC_FREQ_SUBSUMPTION_INDEX:</code> <em>unsigned</em> <em>integer</em>, default: <code>100</code>, minimal number of occurrences (in clauses) for a function symbol to be considered for subsumption indexing..</li></ul>
<p>
<ul>
<li><code>SPC_NUM_ITERATIONS:</code> <em>unsigned</em> <em>integer</em>, default: <code>1000</code> </li></ul>
<p>
<ul>
<li><code>SPC_TRACE:</code> <em>boolean</em>, default: <code>false</code> </li></ul>
<p>
<ul>
<li><code>STATISTICS:</code> <em>boolean</em>, default: <code>false</code>, display statistics.</li></ul>
<p>
<ul>
<li><code>SUBSUMER_MAX_SIZE:</code> <em>unsigned</em> <em>integer</em>, default: <code>32</code>, maximal subsumer size for: backward subsumption and backward/forward subsumption resolution.</li></ul>
<p>
<ul>
<li><code>TICK:</code> <em>unsigned</em> <em>integer</em>, default: <code>1000</code> </li></ul>
<p>
<ul>
<li><code>TRACE:</code> <em>boolean</em>, default: <code>false</code>, enable tracing for the Axiom Profiler tool.</li></ul>
<p>
<ul>
<li><code>TRACE_FILE_NAME:</code> <em>string</em>, default: z3.log, tracing file name.</li></ul>
<p>
<ul>
<li><code>TYPE_CHECK:</code> <em>boolean</em>, default: <code>true</code>, enable/disable type checker.</li></ul>
<p>
<ul>
<li><code>VERBOSE:</code> <em>unsigned</em> <em>integer</em>, default: <code>0</code>, be verbose, where the value is the verbosity level.</li></ul>
<p>
<ul>
<li><code>WELL_SORTED_CHECK:</code> <em>boolean</em>, default: <code>true</code>, enable/disable type checker.</li></ul>
<p>
<ul>
<li><code>Z3_SOLVER_LL_PP:</code> <em>boolean</em>, default: <code>false</code>, pretty print asserted constraints using low-level printer (Z3 input format specific).</li></ul>
<p>
<ul>
<li><code>Z3_SOLVER_SMT_PP:</code> <em>boolean</em>, default: <code>false</code>, pretty print asserted constraints using SMT printer (Z3 input format specific). </li></ul>
</div>
<div class="tabs"></div>
<address style="text-align: right;">
Last modified Thu Jun 18 11:31:26 2009
</BODY>
</HTML>
