 <HTML>
    <HEAD>
    <meta name="author" content="Leonardo de Moura" />
    <meta name="author" content="Nikolaj Bjorner" />
    <meta name="description" content="Z3: SMT solver" />
    <meta name="keywords" content="decision procedure, theorem prover, SMT-LIB, SMTLIB, SMT LIB, SMT Solver, SMTCOMP, SMT-COMP, SAT solver, formal methods, constraint solver, software verification, hardware verification" />
      <TITLE>Z3: SMT solver</TITLE>
      <LINK HREF="z3.css" REL="stylesheet" TYPE="text/css">
      <LINK href="tabs.css" rel="stylesheet" type="text/css">
    </HEAD>
<BODY BGCOLOR="#FFFFFF">
<table class="centered-small">
  <tr>
    <th><a href="index.html"><span>Home</span></a></th>
    <th> &bull; </th>
    <th><a href="documentation.html"><span>Docs</span></a></th>
    <th> &bull; </th>
    <th><a href="download.html"><span>Download</span></a></th>
    <th> &bull; </th>
    <th><a href="mail.html"><span>Mail</span></a></th>
    <th> &bull; </th>
    <th><a href="faq.html"><span>FAQ</span></a></th>
    <th> &bull; </th>
    <th><a href="awards.html"><span>Awards</span></a></th>
    <th> &bull; </th>
    <th><a href="status.html"><span>Status</span></a></th>
    <th> &bull; </th>
    <th><a href="http://research.microsoft.com"><span>MSR</span></a></th>
  </tr>
</table>
<p class="Z3Title"><img align="middle" src="z3.png" alt="Z3" /> An Efficient SMT Solver</p>
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1><a class="anchor" name="models">Models </a></h1>Z3 has the ability to produce models as part of the output. Models assign values to the constants in the input and generate partial function graphs for predicates and function symbols. You can enable model generation by using the switch <code>/m</code>.<p>
For instance, if you use <code>z3 /m example1.smt</code>, where <code>example1.smt</code> is the following benchmark:<p>
<div class="fragment"><pre class="fragment">
(benchmark example1
:status sat
:logic QF_LIA
:extrafuns ((x1 Int) (x2 Int) (x3 Int) (x4 Int) (x5 Int))
:formula (and (&gt;= (- x1 x2) 1)
              (&lt;= (- x1 x2) 3)
              (= x1 (+ (* 2 x3) x5))
              (= x3 x5)
              (= x2 (* 6 x4)))
)
   </pre></div><p>
Z3 produces a model where <code>x1 = -3</code>, <code>x2 = -6</code>, and the other variables are set to -1.<p>
The model comprises of a set of <em>partitions</em>, each partition is printed as: <code>*k</code>, where <code>k</code> is a non-negative number. Each partition is associated with a set of constants from the input, enclosed in <code>{}</code>, and is associated with a concrete value. Concrete values may be one of the following kinds:<p>
<ul>
<li><em>boolean</em>, which is either <b>true</b> or <b>false</b>.</li></ul>
<p>
<ul>
<li><em>numeral:</em> an integer, bit-vector constant or rational number.</li></ul>
<p>
<ul>
<li><em>array:</em> represented as a finite map and an 'else' value.</li></ul>
<p>
<ul>
<li><em>tuple:</em> represented as a constructor and a sequence of values.</li></ul>
<p>
<ul>
<li><em>uninterpreted:</em> represented as <code>typename!k</code> where <code>k</code> is a non-negative integer.</li></ul>
<p>
Z3 also produces interpretations for free functions. Consider the following example:<p>
<div class="fragment"><pre class="fragment">
(benchmark example2
:logic QF_UF
:extrasorts (A B C D)
:extrafuns  ((x A) (y B) (w A) (z C) (u D))
:extrafuns  ((f A A B) (g A B B) (h1 B A B) (h2 B B B))
:formula (and (= (g x y) (h1 y x)) 
              (= (f x x) (h2 y y)) 
              (not (= (f x x) (f x w))))
)
   </pre></div><p>
Z3 produces the following model:<p>
<div class="fragment"><pre class="fragment">
partitions:
*2 {x} -&gt; A!0
*3 {y} -&gt; B!0
*4 -&gt; B!1
*5 -&gt; B!2
*6 {w} -&gt; A!1
*7 -&gt; B!3
function interpretations:
g -&gt; {
  else -&gt; *4
}
h1 -&gt; {
  else -&gt; *4
}
f -&gt; {
  *2 *6 -&gt; *7
  else -&gt; *5
}
h2 -&gt; {
  else -&gt; *5
}
sat
   </pre></div><p>
For example, in the model above, we can find the value of <code>f(x, w)</code> in the following way:<p>
<ul>
<li>The constants <code>x</code> and <code>w</code> are in the partitions <code>*2</code> and <code>*6</code> respectively</li></ul>
<p>
<ul>
<li>The interpretation of <code>f</code> contains and entry <code>*2 *6 -&gt; *7</code>.</li></ul>
<p>
<ul>
<li><code>B!3</code> is associated with partition <code>*7</code>.</li></ul>
<p>
Thus, the value of <code>f(x, w)</code> is <code>B!3</code>.<p>
Similarly, the value of <code>f(x, x)</code> is <code>B!2</code> because there is no entry <code>*2 *2</code> in the interpretation of <code>f</code>, thus the <code>else</code> entry is used: <code>else -&gt; *5</code>.<p>
By default Z3, produces a full (and compact) interpretation for free functions. The option <code>PARTIAL_MODELS=true</code> can be used to force Z3 to produce partial interpretations. When this option is used, Z3 will produce the following model for the previous example:<p>
<div class="fragment"><pre class="fragment">
partitions:
*2 {x} -&gt; A!0
*3 {y} -&gt; B!0
*4 -&gt; B!1
*5 -&gt; B!2
*6 {w} -&gt; A!1
*7 -&gt; B!3
function interpretations:
g -&gt; {
  *2 *3 -&gt; *4
  else -&gt; #unspecified
}
h1 -&gt; {
  *3 *2 -&gt; *4
  else -&gt; #unspecified
}
f -&gt; {
  *2 *2 -&gt; *5
  *2 *6 -&gt; *7
  else -&gt; #unspecified
}
h2 -&gt; {
  *3 *3 -&gt; *5
  else -&gt; #unspecified
}
</pre></div><p>
The option <code>PARTIAL_MODELS=true</code> is also useful for benchmarks that contain quantifiers. Z3 is not complete, and the produced model should be viewed as a <em>potential</em> <em>model</em>. Consider the following benchmark:<p>
<div class="fragment"><pre class="fragment">
(benchmark example3
:logic AUFLIA
:extrafuns  ((a Int))
:extrafuns  ((f Int Int))
:formula (and (forall (x Int) (&gt;= (f x) (+ x 1)))
              (= (f 10) 20)
              (= (f a) (+ a 4)))
)
</pre></div><p>
The command <code>z3 /m PARTIAL_MODELS=true example3.smt</code> will produce the following potential model: <div class="fragment"><pre class="fragment">
partitions:
*2 -&gt; 10:int
*3 -&gt; 20:int
*4 {a} -&gt; -4:int
*5 -&gt; 0:int
function interpretations:
f -&gt; {
  *2 -&gt; *3
  *4 -&gt; *5
  else -&gt; #unspecified
}
</pre></div><p>
Note that, the model specifies the value of <code>f</code> at <code>10</code> and <code>a</code>. This is a side effect of the heuristics used by Z3 to deal with quantifiers. If the command <code>z3 /m example3.smt</code>, then Z3 will produce the following potential (and <em>wrong</em>) model:<p>
<div class="fragment"><pre class="fragment">
partitions:
*3 -&gt; 20:int
*4 {a} -&gt; -4:int
*5 -&gt; 0:int
function interpretations:
f -&gt; {
  *4 -&gt; *5
  else -&gt; *3
}
</pre></div> </div>
<div class="tabs"></div>
<address style="text-align: right;">
Last modified Thu Jun 18 11:31:26 2009
</BODY>
</HTML>
