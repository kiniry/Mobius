package mobius.cct.classfile;

import java.io.DataInputStream;
import java.io.IOException;
import java.util.Iterator;

import mobius.cct.constantpool.ConstantPool;
import mobius.cct.constantpool.DefaultPool;
import mobius.cct.repositories.InvalidFormatException;
import mobius.cct.util.VisitorException;

/**
 * Method in a class file.
 * @author Tadeusz Sznuk (ts209501@gmail.com)
 */
public class Method {
  // ACCESS FLAGS
  /** 
   *  Declared public; may be accessed from outside its package.
   */
  public static final int ACC_PUBLIC = 0x0001; 
  /** 
   *  Declared private; accessible only within the defining class.
   */
  public static final int ACC_PRIVATE = 0x0002; 
  /** 
   *  Declared protected; may be accessed within subclasses.
   */
  public static final int ACC_PROTECTED = 0x0004; 
  /** 
   *  Declared static.
   */
  public static final int ACC_STATIC = 0x0008; 
  /** 
   *  Declared final; must not be overridden.
   */
  public static final int ACC_FINAL = 0x0010; 
  /** 
   *  Declared synchronized; invocation is wrapped in a monitor lock.
   */
  public static final int ACC_SYNCHRONIZED = 0x0020; 
  /** 
   *  A bridge method, generated by the compiler.
   */
  public static final int ACC_BRIDGE = 0x0040; 
  /** 
   *  Declared with variable number of arguments.
   */
  public static final int ACC_VARARGS = 0x0080; 
  /** 
   *  Declared native; implemented in a language other than Java.
   */
  public static final int ACC_NATIVE = 0x0100; 
  /** 
   *  Declared abstract; no implementation is provided.
   */
  public static final int ACC_ABSTRACT = 0x0400; 
  /** 
   *  Declared strictfp; floating-point mode is FP-strict.
   */
  public static final int ACC_STRICT = 0x0800; 
  /** 
   *  Declared synthetic; Not present in the source code.
   */
  public static final int ACC_SYNTHETIC = 0x1000; 
  
  /**
   * Method name and type.
   */
  private final MethodName fName;
  
  /**
   * Access flags.
   */
  private final int fAccessFlags;
  
  /**
   * Attributes.
   */
  private final AttributeMap fAttributes;
  
  /**
   * Constructor - read method from a stream.
   * @param ds Input stream.
   * @param cp Constant pool.
   * @throws IOException .
   */
  public Method(final DataInputStream ds, 
                final ConstantPool cp) throws IOException {
    fAccessFlags = ds.readUnsignedShort();
    final int nameIndex = ds.readUnsignedShort();
    final String name = DefaultPool.getString(cp, nameIndex);
    if (name == null) {
      throw new InvalidFormatException("Invalid method name.");
    }
    final int typeIndex = ds.readUnsignedShort();
    final String type = DefaultPool.getString(cp, typeIndex);
    if (type == null) {
      throw new InvalidFormatException("Invalid method type.");
    }
    fName = MethodName.get(name, type);
    fAttributes = new AttributeMap(ds, cp);
  }
  
  /**
   * Get method name.
   * @return Method name.
   */
  public MethodName getName() {
    return fName;
  }
  
  /**
   * Get method access flags.
   * @return Access flags.
   */
  public int getAccessFlags() {
    return fAccessFlags;
  }
  
  /**
   * Access method attributes.
   * @return Attribute map.
   */
  public AttributeMap getAttributes() {
    return fAttributes;
  }
  
  /**
   * Visit method.
   * @param v Visitor.
   * @throws VisitorException .
   */
  public void visit(final MethodVisitor v) throws VisitorException {
    v.begin(fName);
    final Iterator<Attribute> i = fAttributes.iterator();
    while (i.hasNext()) {
      v.visitAttribute(i.next());
    }
    v.end();
  }
  
}
