\section{The Bytecode Modeling Language}
\label{SecBML}


%\subsection{Syntax of BML}

Basically, BML has the same syntax as JML with two exceptions:
\begin{enumerate}
\item specifications are not written directly in the program code,
they are added as special attributes to the bytecode; and
\item the grammar for expressions only allows bytecode expressions.
\end{enumerate}

\begin{figure}[t]

\begin{tabular}{lll}
\multicolumn{2}{l}{\varHook{predicate} ::= \(\ldots\)}\smallskip\\
\multicolumn{2}{l}{\varHook{unary-expr-not-plus-minus} ::= \(\ldots\)}\\
\hspace*{1cm} & \(\mid\) \varHook{primary-expr} [\varHook{primary-suffix}]\(\ldots\)\\ 

\multicolumn{3}{l}{\varHook{primary-suffix} ::= \codeHook{.} \varHook{ident}
\(\mid\) \codeHook{(} [\varHook{expression-list}] \codeHook{)}
 \(\mid\) \codeHook{[} \varHook{expression} \codeHook{]}}\\

\multicolumn{2}{l}{\varHook{primary-expr} ::= 
\codeHook{\#}\varHook{natural}} & \% reference in the constant pool \\
&\(\mid\) \codeHook{lv[}\varHook{natural}\codeHook{]} &\% local variable \\
&\(\mid\) \varHook{bml-primary}\\
&
\multicolumn{2}{l}{\(\mid\) \varHook{constant} \(\mid\)
\codeHook{super}
\(\mid\) \codeHook{true} \(\mid\) \codeHook{false} \(\mid\)
\codeHook{this} \(\mid\) \codeHook{null} 
\(\mid\) \codeHook{(}\varHook{expression}\codeHook{)}
\(\mid\) \varHook{jml-primary}}\\

\multicolumn{2}{l}{\varHook{bml-primary} ::= \codeHook{cntr}} &\% counter of the operand stack\\
&\(\mid\) \codeHook{st(}\varHook{additive-expr}\codeHook{)} &\% stack
expressions\\
&\(\mid\) \codeHook{length(}\varHook{expression}\codeHook{)} &\% array
length 
%\\
%\multicolumn{2}{l}{\varHook{store-ref-expression} ::= \varHook{store-ref-name}
%[\varHook{store-ref-name-suffix}]}\\
%\multicolumn{2}{l}{\varHook{store-ref-name} ::= 
%\codeHook{\#}\varHook{natural}} &\% reference in the constant pool \\
%&\(\mid\)\codeHook{super} \(\mid\) \codeHook{this}\\
%\multicolumn{2}{l}{\varHook{store-ref-name-suffix} ::= 
%\codeHook{(}\varHook{store-ref-expression}\codeHook{)}}\\
%&\(\mid\) \codeHook{[}\varHook{spec-array-ref-expr}\codeHook{]}
\end{tabular}

\caption{Fragment of grammar for BML predicates and specification expressions}\vspace*{-1em}
\label{FigBMLGrammar}
\end{figure}

\paragraph{Syntax for BML predicates}
Figure~\ref{FigBMLGrammar} displays the most interesting part of the
grammar for BML predicates, defining the
syntax for primary expressions and primary suffixes\footnote{See
\texttt{http://www-sop.inria.fr/everest/BML} for the full grammar of BML.}.
Primary expressions, followed by zero or more primary suffixes, are
the most basic form of expressions, formed by identifiers, bracketed
expressions \emph{etc}.

Since only bytecode expressions can be used, all field names, class
names \emph{etc.}\ are replaced by references to the constant pool (a
number, preceded by the symbol \codeHook{\#}), while registers are
used to refer to local variables and parameters. The register
\codeHook{lv[0]} of a non-static method always contains the implicit
argument \codeHook{this}, the other registers contain the parameters
and the local variables declared inside a method body. Compilers often
reuse local variable registers throughout the execution of a single
method. Thus, when \emph{e.g.}\ type checking an annotation containing
a local variable, it has to be taken into account at which point in
the code the annotation is evaluated (but notice that this is not more
complicated than reusing the same local variable name in different
block statements).

We can use the stack counter (\codeHook{cntr}) and stack expressions
(\codeHook{st(\(e\))}, where \(e\) is some arithmetic expression) to
describe intermediate states of a computation.  These are not used in
method specifications. We also add a special expression
\codeHook{length(\(a\))}, denoting the length of array \(a\). Since
the source code expression
\codeHook{\(a\).length} is compiled into a special bytecode
instruction \codeHook{arraylength}, we also need a special
specification construct for this at bytecode level.

In Java source code, one can usually leave the receiver object
\texttt{this} implicit. But compilation into bytecode makes this
object explicit, \emph{i.e.}\ instructions such as \texttt{putfield}
\emph{always} require that the receiver object is loaded on the
operand stack. In analogy with this, BML specifications require that
the receiver object is written explicitly in expressions (see
Figure~\ref{FigBMLSpec} below). 

In JML, many special keywords are preceded by the symbol
\codeHook{\bsl}, to ensure that they will not clash with variable
names. For BML, we do not have to worry about this: all
variable names are replaced by references to the constant pool or
local variable registers. Therefore, the new keywords are written
without a special preceding symbol. However, for convenience, we keep
the symbol for keywords that are also JML keywords.

At the moment, the use of pure methods is not part of the BML grammar,
as there is still ongoing research on the exact semantics of method
calls used in specifications. However, we believe that if the
theoretical issues have been settled, eventually any tool supporting
BML should also support this\footnote{In fact, we think that both at
source code and at bytecode level, specifications will benefit
significantly from being allowed to use method calls in them.}.


\paragraph{Class and method specifications}
BML contains equivalent constructs for all specification constructs of
JML Level 0 (see~\cite[\S2.9]{JMLReferenceManual05}), which defines
the features that should be understood and checked by all JML
tools. It also contains several constructs from JML level 1,
that we find important to be able to write meaningful specifications
for the example applications studied in the \mobius project, namely
static invariants; object and static constraints; and loop variants.

We choose to keep the notion of loop specification in BML, even though
there is no high level loop construct in bytecode. But to be able to
prove termination, one needs to prove decrease of a loop variant,
which makes the treatment of loops different from the treatment of
other statements. Also, experiences with verification of realistic
case studies have shown that it is beneficial to know which variables
may be modified by the code block that corresponds to the loop. For
this, we use the special clause \codeHook{loop\unsc modifies}. This
allows to write concise specifications, and to efficiently generate
proof obligations using a weakest precondition calculus.  Moreover by
keeping the notion of loop specification explicit in BML, we keep the
correspondence with JML specifications more direct.


As mentioned above, specifications are stored as special attributes in
the class file. This means that every class contains a table with
invariant and constraint annotations, while each method has extra
attributes containing its specifications. Finally, the code for the
method body is annotated with local annotation tables for the assert
annotations and the loop specifications. Section~\ref{SecClassfile}
defines the precise format of these attributes.


Since the bytecode and BML specifications are two separate entities,
they should be parsed independently. Concretely this means that the
grammar of BML is similar to the grammar of type specifications,
method specifications and data groups of JML~\cite[\S A.5, A.6,
A.7]{JMLReferenceManual05}, restricted to the constructs in JML level
0, plus the constructs of JML level 1 mentioned, but with the changes
to the grammar for predicates and specification expressions, as
mentioned above. 


%Finally, statement annotations are described as a special attribute,
%mapping line numbers to annotations. To parse these annotations, we
%reuse the relevant parts of the grammar for statements and annotation
%statements~\cite[\S A.9]{JMLReferenceManual05}.

%Type checking of the specification can be done in the obvious way,
%using the type information stored in the constant pool.

\paragraph{An example BML specification}
\label{sec:bml:example}


\begin{figure}[t]
{\small
\begin{verbatim}
{| requires lv[1] > 0 
   ensures lv[0].#24 <= \old(lv[0].#24) + lv[1] * (lv[1] + 1) / 2 |}
 0 iconst_1
 1 istore_2
 2 goto 22 
 5 aload_0
 6 aload_0
 7 getfield #24 <Bill.sum>
10 aload_0
11 iload_2
12 invokevirtual #26 <Bill.round_cost>
15 iadd
16 putfield #24 <Bill.sum>
19 iinc 2 by 1
loop_invariant 0 <= lv[2] && 0 <= lv[0].#24 && lv[2] <= lv[1] + 1 && 
               lv[0].#24 <= \old(lv[0].#24) + (lv[2] - 1) * lv[2]/2
entry loop: 
22 iload_2
23 iload_1
24 if_icmple 5 
27 iconst_1
28 ireturn
29 astore_3
30 iconst_0
31 ireturn
\end{verbatim}
}
\vspace*{-1em}\caption{Bytecode + BML specification for method \codeHook{produce\unsc bill} in class \codeHook{Bill}}\label{FigBMLSpec}
\end{figure}

To show a typical BML specification, Figure~\ref{FigBMLSpec} presents
the BML version of the JML specification of method
\codeHook{produce\_bill} in Figure~\ref{FigJMLSpec}. Notice that the
field
\codeHook{sum} has been assigned the number 24 in the constant
pool, and that it is always explicitly qualified with \codeHook{lv[0]}
(denoting \codeHook{this}). Further, \codeHook{lv[1]} denotes the
parameter \codeHook{n}, while \codeHook{lv[2]} denotes the local variable
\codeHook{i}.
 
The class invariant gives rise to the following BML specification
(stored in the class file as a special user-specific attribute, as
explained below):

\begin{verbatim}
invariant:  #24 >= 0
\end{verbatim}

This expression is not qualified with \codeHook{lv[0]}, as it is
implicitly quantified over all objects that are an instance of a
subclass of class \texttt{Bill} (\emph{cf.}\ the JML
semantics~\cite[\S 8.2]{JMLReferenceManual05}).

%This class contains a
%private, but \codeHook{spec\unsc public} (i.e.~publicly visible
%in specifications) field
%\codeHook{list}, which is an array of objects. The class invariant says
%that \codeHook{list} is not null, and in addition, its elements are
%never null.  Further, the class contains a method \codeHook{replace},
%which checks if its first parameter \codeHook{obj1} occurs in
%\codeHook{list}, and if this is the case, replaces it (once) by its
%second parameter \codeHook{obj2}. 

%\begin{figure}[t!]
%{\small
%\begin{verbatim}
%public class ListArray {
%//*@ spec_public @*/ private Object[] list;
%//@ invariant list != null && \nonnullelements(list);
	
%/*@ requires obj2 != null;
%  @ assignable list[*];
%  @ ensures \result == (\exists int i; 0 <= i && i < list.length && 
%  @                                    \old(list[i]) == obj1 && list[i] == obj2);
%  @*/ 
%  public boolean replace(Object obj1,Object obj2)
%  {
%    int i = 0;
%    /*@ loop_modifies this[*];
%      @ loop_invariant 0 <= i && i <= list.length && 
%      @                (\forall int k; 0 <= k && k < i ==> list[k] != obj1);
%      @*/ 
%    for (i = 0; i < list.length; i++ ) {
%      if ( list[i] == obj1) { list[i] = obj2; return true; }}
%    return false; }
%}
%\end{verbatim}
%}
%\vspace*{-1em}\caption{JML specification for class \codeHook{ListArray}}\label{FigJMLSpec}
%\end{figure}



\paragraph{Structural and typing constraints for BML specifications}
BML specifications have to respect several structural and typing
constraints, similar to the structural and typing constraints that the
bytecode verifier imposes over the class file format.  Examples of
typing constraints that a BML specification must respect are the
following:
\begin{itemize}
\item field access expression
    $\fieldAccess{e}{\ident}$ is well-typed only if $e$ is
    of a subtype of the class where the field described by the constant
    pool element at index $\ident$ is declared; 

\item array access expression
$e_1[e_2]$ is well-typed only if $e_1$ is of array
type and $e_2$ is of integer type; and


%\item any  expression $ e_1 \oplus e_2$, where \(\oplus\) is an arithmetic 
%operator (\(+,-,*,/\) \emph{etc.}) is well-typed only if $e_1$ and $
%e_2$ are of a numeric type;
    
%\item predicate $e_1 \sim e_2$ where $\sim \in \{\leq,<,\geq,
%>\}$ is well-typed only if the expressions $e_1$ and $e_2$ are of a 
%numeric type;

\item predicate $e_1 \subtypeSpec e_2$ is well-typed only if the 
expressions $e_1$ and $e_ 2$ are of type \codeHook{java.lang.Class}
(which is the same as the JML type \TYPE).

%\item expression $\elemtype{e}$ is well-typed only if $e$ is of array type.

	  
\end{itemize}

Examples of structural constraints that a BML specification must
respect are the following: 
\begin{itemize}
\item all references to the constant pool must be to an entry of the
appropriate type; for example, for field access expression
$\fieldAccess{e}{\ident}$, $\ident$ must reference a
field in the constant pool; while for expression $\type{\ident}$,
\(\ident\) must be a reference to a constant class in the
constant pool;
    
\item every $\ident$ in a BML specification must be a correct
index in the constant pool; and
    
\item if the expression $\locVar{i}$ appears in a BML method 
specification, $i$ must be a valid index in the method's local
variables table.
\end{itemize}

These checks are best implemented as an extension of the bytecode
verifier.
 

%\subsection{Evaluation of BML expressions}

%When defining the evaluation of BML expressions, a subtle point that
%has to be taken into account is the fact that at bytecode level no
%explicit boolean values are used, they are encoded as integers (but
%variables can still be of type \codeHook{boolean} --- this information is
%used by the BCV). Thus, to make sure that expressions such as
%\codeHook{\bsl result == \bsl exists i. i >= 0} are correctly evaluated,
%the evaluation of the quantified expression is wrapped up by a
%conditional function, returning 1 if the condition is true, 0
%otherwise.

\paragraph{Semantics of BML expressions}

The semantics of BML specifications follows the semantics of JML
specifications~\cite{JMLReferenceManual05}. But, just as a JML
specification can be mapped into a more fundamental Hoare triple
specification, we can also define a semantics for BML in terms of a
basic logic for Java bytecode, namely the so-called
\mobius base logic. This logic will be the core of the PCC platform
developed within the project. This logic (see~\cite{BeringerH06} for
an earlier version, without exceptions) has been proven sound in Coq
\emph{w.r.t.}\ a formalisation of the virtual machine. On top of this,
a direct verification condition generator has been proven sound, also
in Coq. And, as a first step towards efficient tool development, a
translation of bytecode into guarded commands has been defined and
proven correct, \emph{w.r.t.}\ verification condition
generation~\cite{LehnerM07}.

Defining the mapping of BML specifications into this \mobius base
logic is defined in two steps. First the evaluation of predicates is
defined over the program state (\emph{i.e.}\ over the heap, store and
operand stack), and second the complete BML specifications are
translated into judgements of the \mobius base logic. Notice that this
embedding allows to use the verification condition generator for the
\mobius base logic also for BML specifications.

%As mentioned above, a BML specification can contain the following
%constructs: class specifications, method specifications, and statement
%annotations, in particular the \texttt{assert},
%\texttt{assume}, and  \texttt{set} annotations, that can occur at any 
%point in the program text, and loop invariants, loop frame 
%conditions, and loop variants, that are associated to loop blocks.
Judgements in the \mobius base logic are of the form
\(\JudgeF{\ppt}{A}{B}{I}\), where \(\LST\) is a proof context,
and \(\Anno\) the local annotation table, \emph{i.e.}~the table that
associates assert annotations with particular instructions. Further,
\(A\) is a (local) precondition, relating the state at label \ppt\
with the initial state, while \(B\) is a (local) postcondition,
relating the initial, current and final state, and \(I\) is a (local)
invariant, \emph{i.e}\ a predicate that is supposed to hold throughout
execution of the current method.

Mapping class specifications (invariants and constraints) and
method specifications into the \mobius base logic is straightforward.
Since the \mobius base logic only has one postcondition, the normal
and exceptional postconditions are combined into a single
postcondition, specifying with a case distinction which conditions
should hold if the state is normal or exceptional, respectively. Frame
conditions are also added to the postconditions, specifying
explicitly which variables are allowed to be changed. Since predicates
in the \mobius base logic specify properties over the whole heap, this
can be expressed directly: all locations that are not mentioned in the
frame condition of the method (evaluated in the pre-state of the
method) should be unchanged. Methods with multiple specifications are
translated only after desugaring them into a single method
specification \emph{cf.}~\cite{RaghavanL00}. 

Assert and set statements are inserted directly in the local
annotation table\footnote{In fact, at the moment, the \mobius base
logic does not support ghost variables; but these will be added in the
near future.}. However, for loop specifications some manipulations
are necessary to produce the appropriate assert annotations, due to
the unstructured nature of bytecode. The loop invariants can be added
directly to the local annotation table, but loop variants and loop
frame conditions first are transformed into a sequence of assert and
set annotations (after introducing appropriate ghost variables). This
transformation is done at the level of BML, after which we can add
the annotations to the local annotation table.

The transformation of the loop variant basically proceeds as follows.
Let \texttt{variant} be the expression declared in the decreases
clause.  We declare ghost variables \texttt{loop\unsc init} (initially
set to true) and \texttt{loop\unsc variant} (whose initialisation is
not essential). If \(l\) is the program point where we enter the loop,
then at that point we add an assertion
\begin{verbatim}
//@ assert !loop_init ==> (0 <= variant && variant < loop_variant);
\end{verbatim}
followed by:
\begin{verbatim}
//@ set loop_init = false; set loop_variant = variant;
\end{verbatim}
This ensures that every time the loop entry point \(l\) is reached
again, the decrease of the loop variant is checked. Only a path that
goes through the loop can set \texttt{loop\unsc init} to false.

For transforming loop frame conditions, we use again that in the
\mobius base logic we can express properties of the heap. 
We make a transformation into a sequence of assert and set
statements, declaring ghost variables to remember the old heap and
all locations mentioned in the loop frame condition, and a ghost
variable \texttt{loop\unsc init} as above. Then we assert at the entry
point of the heap that if \texttt{loop\unsc init} does not hold, any
location that is not mentioned in the loop frame condition should
remain unchanged. Notice that this assertion cannot be directly
expressed in BML, but it can be expressed in the \mobius base
logic. Finally, in the \mobius base logic we add appropriate ghost
variable updates to remember the old heap and the locations of the
loop frame condition when the loop was first entered.









