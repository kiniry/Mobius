\section{Encoding BML specifications in the Class File Format}
\label{SecClassfile}

To store BML specifications together with the bytecode it specifies,
we encode them in the class file format. Recall that a class file
contains all the information related to a single class or interface,
\emph{e.g.}\ its name, which interfaces it implements, its
super class and the methods and fields it declares. The Java Virtual
Machine Specification~\cite{JVMspec} prescribes the mandatory elements
of the class file: the constant pool, the field information and the
method information. The constant pool is used to construct the runtime
constant pool upon class or interface creation. This will serve for
loading, linking and resolution of references used in the class. The
JVM specification allows to add user-specific information to the class
file (\cite[\S4.7.1]{JVMspec}) as special user-specific attributes.
We store BML specifications in such user-specific attributes, in a
compiler-independent format\footnote{Another possibility would be to
use metadata to encode the specifications, but this is only supported
in Java 1.5, and it is (currently) not directly compatible with
JML.}. To ensure that the augmented class files are executable by any
implementation of the JVM, the user-specific attributes cannot be
inserted in the list with bytecode instructions. Instead BML
annotations are stored separately from the method body, and where
necessary the annotations contain the index of the instruction that
they specify. The use of special attributes ensures that the presence
of BML annotations does not have any impact on the application's
performance, \emph{i.e.}, the augmented class file should not slow
down loading or normal execution of the application. %Notice that this
requirement is important for mobile
%device applications, where one often has limited resources.


For each class, we add the following information to the class file:
\begin{itemize}
\item a second constant pool which contains constant references
      for the BML specification expressions;
\item an attribute with the ghost fields used in the specification;
\item an attribute with the model fields used in the specification;
\item an attribute with the class invariants (both static and object); and
\item an attribute with the constraints (both static and object).
\end{itemize}
Apart from the second constant pool, all extra class attributes
basically contain the name of the attribute, the number of elements it
contains, and a list with the actual elements.

If a model or a ghost field is dereferenced in the specification, then
a \textbf{constantFieldRef} is added to the second constant pool as
the Java compiler does for any dereferenced Java field in the original
constant pool of the class. Note that in this way, the BML encoding
will not affect the JVM performance. In particular, if we would use
the original constant pool for storing constants originating from
specifications, the search time in the original constant pool might
degrade significantly (especially for a large specification).

%\footnote{The
%JVM specification does not allow
%to create a separate constant pool for specification-only variables,
%since every constant that occurs in the class file
%\emph{must} occur in the standard constant pool.};


\begin{figure}[t]
\textbf{
\begin{longtable}{p{5.5cm}p{8cm}}
\begin{tabular}[t]{l}
Ghost\unsc Field\unsc attribute \{\\
\hspace*{1em}
\begin{tabular}{l}
u2  attribute\unsc name\unsc index; \\
u4  attribute\unsc length;\\
u2  fields\unsc count;\\
\{\begin{tabular}[t]{l} 
    u2 access\unsc flags; \\  
    u2 name\unsc index;\\
    u2 descriptor\unsc index;\\
  \end{tabular}\\
\} fields[fields\unsc count]; \} \\
\end{tabular}
\end{tabular}
&
\begin{tabular}[t]{l}
BMLMethod\unsc attribute \{ \\ 
\hspace*{1em}
\begin{tabular}[t]{l}
u2 attribute\unsc name\unsc index;\\ 
u4 attribute\unsc length;\\ 
formula requires\unsc formula;\\
u2 spec\unsc count;\\
\{\begin{tabular}[t]{l}
  formula spec\unsc requires\unsc formula; \\
  u2 assignable\unsc count;\\
  formula assignable[assignable\unsc count];\\
  formula ensures\unsc formula;\\
  u2 exsures\unsc count;\\
  \{\begin{tabular}[t]{l}
    u2 exception\unsc index; \\
    formula exsures\unsc formula;\\
    \end{tabular}\\
  \} exsures[exsures\unsc count];\\
  \end{tabular}\\
\} spec[spec\unsc count];   \} \\
\end{tabular}
\end{tabular}
\end{longtable}
}
\vspace*{-1em}\caption{Attributes for ghost field declarations and method specifications}
\label{FigAttributes}
\end{figure}

The left-hand column of Figure~\ref{FigAttributes} shows the format of
the ghost fields attribute. This should be understood as follows: the
name of the attribute is given as an index into the constant
pool. This constant pool entry will be representing a string
\texttt{"Ghost\unsc Field"}. Next we have the length of the attribute,
which should be 2 + 6*\textbf{fields\unsc count} (the number of fields
stored in the list). The \textbf{fields} table stores all ghost
fields. For each field we store its access flags (\emph{e.g.}\
\texttt{public} or
\texttt{private}), and the name index and descriptor index, both
referring to the constant pool. The first must be a string,
representing the (unqualified) name of the variable, the latter is a
field descriptor, containing \emph{e.g.}\ type information.  The tags
\textbf{u2} and \textbf{u4} specifies the size of the attribute, 2 and
4 bytes, respectively. The model field attribute is similar.

In a similar way, we define attributes for class invariants and
constraints, containing a list of invariants and constraints,
respectively. These contain the predicate, a tag whether the
invariant (constraint) is defined over instances or static, and
appropriate visibility modifiers.


%. The type of
%invariants and  constraints is specified by the 
%\textbf{type} entry: when it is \textbf{1} the invariant (or 
%constraint) is defined over objects, when it is \textbf{0} the
%invariant (or constraint) is static.

%\begin{longtable}{p{7cm}p{8cm}}
%\textbf{
%\begin{tabular}{l}
%JMLClassInvariant\unsc attribute \{ \\
%\hspace*{0.1em}\begin{tabular}{l}
%u2 attribute\unsc name\unsc index;\\ 
%u4 attribute\unsc length;\\ 
%u2  invariant\unsc count;\\
%\{\begin{tabular}[t]{l} 
%        u1 type;\\
%	formula invariant;\\ 
%\end{tabular}\\
%\} invariants[invariant\unsc count];  
%\end{tabular}\\
%\}  
%\end{tabular}
%}
%&
%\bigskip\\
%\textbf{
%\begin{tabular}{l}
%JMLConstraints\unsc attribute \{ \\ 
%\hspace*{1em}\begin{tabular}{l}
%u2 attribute\unsc name\unsc index;\\ 
%u4 attribute\unsc length;\\ 
%%formula attribute\unsc formula;\\ 
%u2  \unsc constr\unsc count;\\
%\{\begin{tabular}[t]{l} 
%        u1 type;\\
%	formula constraint;\\ 
%\end{tabular}\\
%\} \unsc constr[\unsc constr\unsc count];
%\end{tabular}\\
%\}
%\end{tabular}
%}
%\end{longtable}

The JVM specification prescribes that the attribute with method
information at least contains the code of each method. We add
attributes for the method specification, set statements,
assert statements, and loop specifications.  

The attribute for lightweight behaviour specifications is shown in the
right-hand column of Figure~\ref{FigAttributes} (heavyweight behaviour
specifications are handled similarly).  The global requires formula is
the disjunction of all preconditions in the different specification
cases of the method. For each specification case, we then have a
precondition (\textbf{spec\unsc requires\unsc formula}), a list of
assignable expressions, a postcondition (\textbf{ensures\unsc
formula}) and a list of exceptional postconditions (stored in the
\textbf{exsures} attribute). If a clause is not explicitly specified,
its default value will be stored here. 


%are very
%similar. For each statement we use \textbf{index} to denote the point
%in the bytecode to which the statement is associated. For the set
%statement, expression \textbf{e1} is a ghost variable, \textbf{e2}
%denotes the expression that will be assigned to \textbf{e1}. For the
%assert and assume statements, the formula \textbf{predicate} is the
%predicate that is supposed to hold at this point in the program
%execution. We only give the format for the assert statement table
%here, the assume statement table is similar.

%\begin{longtable}{p{6cm}p{8cm}}
%\textbf{  
%\begin{tabular}[t]{l}
%Set\unsc attribute \{\\
%\hspace*{1em}\begin{tabular}{l}
%u2 attribute\unsc name\unsc index;\\
%u4 attribute\unsc length;\\
%u2 set\unsc count;\\
%\{\begin{tabular}[t]{l}
%  u2 index; \\
%  expression e1; \\
%  expression e2; \\
%  \end{tabular}\\
%\} set[set\unsc count];\\
%\end{tabular}\\
%\}
%\end{tabular}
%}

%&
%\textbf{
%\begin{tabular}[t]{l}
%Assert\unsc attribute \{\\
%\begin{tabular}{l}
%u2 attribute\unsc name\unsc index;\\
%u4 attribute\unsc length;\\
%u2 assert\unsc count;\\
%\{\begin{tabular}[t]{l}
%  u2 index; \\
%  formula predicate; \\
%\end{tabular}\\
%\} assert[assert\unsc count];\\
%\end{tabular}\\
%\}
%\end{tabular}
%}
%\end{longtable}

The attributes for set and assert statements and loop specifications
have the same format as \emph{e.g.}\ the ghost variable attribute: a
length entry and a list of elements.  The elements storing set and
assert statements do not only keep the appropriate predicate or
expression, but also an index to the appropriate point in the
bytecode. Similarly, the elements for loop specifications contain the
loop specification (invariant, variant and frame conditions), plus an
index to the bytecode instruction that corresponds to the entry of the
loop. If the specification does not contain a loop variant, we
indicate this, using a special tag for the
\textbf{decreases} clause.


%and for loop
%specifications have the same
%format as for example the attribute for ghost fields, \emph{i.e.}\
%some general information, and a list of entries. For each statement
%annotation, we keep the appropriate predicate or expression, plus the
%index to the appropriate point in the bytecode.
%Finally, loop specification attributes consist of the following elements: an
%\textbf{index} to the bytecode instruction that corresponds to the
%entry of the loop, a list of variables that may be modified by the
%loop, a loop invariant, and a \textbf{decreases} clause, which is the
%loop variant, \emph{i.e.}\ the expression that allows to prove
%termination of the loop. 
 %This gives the following attribute format.

%\textbf{     
%\begin{longtable}{lp{8cm}}
%JMLLoop\unsc specification\unsc attribute \{\\
%\begin{tabular}{l}
%u2 attribute\unsc name\unsc index;\\
%u4 attribute\unsc length;\\
%u2 loop\unsc count;\\
%\{\begin{tabular}{l}
%  u2 index;\\
%  u2 modifies\unsc count;\\
%  formula modifies[modifies\unsc count];\\
%  formula invariant;\\
%  expression decreases;\\
%  \end{tabular}\\
%\} loop[loop\unsc count];\\
%\end{tabular}\\
%\}
%\end{longtable}
%}
