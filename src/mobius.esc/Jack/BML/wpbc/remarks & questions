/////////Remarks and Questions //////////////////////////////////////////////////////////////////////////////////////////////
Implementation remarks and questions  ***
1. if in the preconditions and postconditions of the  methods there are :
	1.1. cast expressions - should they be converted into formula ?
	1.2. method calls- should they be substituted by their specification clauses ?

2.on ne travaille pas de tout avec des strings ? car ils sont dans le cp, et quand on fait la conversion vers bc on doit les  traduire vers le N dans le cp
	
 3. est -ce que finalement c'est possible d'avoir une expression de la  forme : old (field_num_in_cp)  , a mon avis non car  on fait des old sur des expressions et une constant du constant pool  n'est
  pas une expression . En fait on  peut avoir des expressions du genre : 
  old (field_num_in_cp(local(1))) 
   ou aussi 
   ( \-/ ref. old(field_num_in_cp(ref)) 
 
 4. pour la substitution dans l'expression \old(expr ), je crois on doit faire comme ca ?  
par example : \old(expr ) [expr <- expr + 1] =  \old(expr ) 
 
 5. is there really a different encoding for jml and java variables or it is the same ? (as there is only one cp !). Or are they only declared in the class field_info attribute ? 
 
 6. types that are not in the constant pool, but that are in the specification need particular treatment ? (but what )
 
 7. est-ce que dans la specification de la boucle l'index c'est vraiment l'index de l'indtruction ou la boucle commence . En fait pour la meme ligne de source , il y a plusieurs lignes de bytecode que lui correspond  ***  
 
 
 Specification remarks : **
 1. didn't see in the specification the encoding for the JML expression a[i1.. i2]
 2. I don't understand the codes for the modifies expressions . I understand the modifies expressions as a list of expressions and nothing else. 
 So what I need in the specification is just the number of the modified expressions.  
 3. about quantified formulas : I think the encoding for this kind of formula is: ??? 
 4. about the method specification : how should I read the requires formula which is global for all tjhe specification cases?  
 I need some delimiter for it , or at least it should be always there, i nthe cas eby default : TRUE . If it is no always THERE there will be difficult to read the rest of the method specification
 5. isn't the decrease statement actually an expression for which the values before and after the execution of the loop should forma a well founded set ?
 
 Invariants :
 1. do we consider only class invariants or instance invariants (at least the specification injected for an invariant doesnot contain any access information - private, public , etc.)
 2. In the prestate and postate  of  a method (excluding constructors and destructors ) an invariant "ONLY OF THE OBJECT IT BELONGS TO" should be assumed , established ! 
 This is in a contradiction with the JML reference manual , which states that a method m should assume/establish all the invariants of every object o, such that  the precondition/postcondition 
 of m is a visible state of  o. (see in the JML ref manual the def for a visible state of an instance  and class )
 
 3. about the exceptional behaviour of a method. Sghiuld't it be quantified over the modfies expressions also ?  
 
 
 
 /////////////NOT Done ////////////////////// ***
 
 1. ? : - expressions not done still - don't know if to translate them directly into formula -TODO
 2. what to do with cast expressions ? 
 2. the  case instruction - TODO 
 
 ///////////////BCEL PROBLEMS /////////// ***
 1. if in the array of lcoal variables there is one that is coded with 2 indexes then the array of lcoal variables is cut by 1 element
 2. a throw instruction doesnot know the type of the objet that it throws 
 
 
 
 ///////////////////////////////////////////////////////// ///////////////////////////////////////////////////////// ///////////////////////////////////////////////////////// ///////////////////////////////////////////////////////// ///////////////////////////////////////////////////////// /////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////// ///////////////////////////////////////////////////////// 2 -eme parties  ///////////////////////////////////////////////////////// ///////////////////////////////////////////////////////// ///////////////////////////////////////////////////////// ///////////////////////////////////////////////////////// /////////////////////////////////////////////////////////
   ///////////////////////////////////////////////////////// ///////////////////////////////////////////////////////// ///////////////////////////////////////////////////////// ///////////////////////////////////////////////////////// ///////////////////////////////////////////////////////// /////////////////////////////////////////////////////////
   
 1.est-ce que pour les creations des objets, et arrays on doit quantifier sur les nouvelles references ? Pour le moment ce n'est pas quantifie univeresellement
 2. pour l'instruction athrow je ne vois pas de tout une sortie.Peut etre on peux dire qqch dans la specification jml inseree dans le class file
 3. il y  a des bugs qui concernent les block squi terminent en loopendInstr
 
 ////////////////////////////////
 // 30/07 ///////////////////////v kashti
 //////////////////////////////////
 pour les points d'entrees d'une componente f.c. avoir un class qui va les designer 
 (pour les entry points d'un programme et d'un exception handler). Taka shte mogat da
 se sabirat nakraia rezultatite ot izchislenieto
 
 //////////////////////////////////
 ///02/09///////////////////
 /////////////////////////////////////
 AttributeReader.readExpression 
 localvariable and fieldreference should of 2 bytes 
 
 
 //////////////////////////////////
 ///06/09///////////////////
 /////////////////////////////////////
 bc2jml  specification 
 1.in the modifies clause : the expression not read roperly see 
 	//@ requires true;
	//@ modifies b, a1; 
	//@ ensures \result == this;
	//@  exsures (ArrayIndexOutOfBoundsException e) arr.length < 2;
	public A testThisAccess(A a1, A a2) {.........}
	
	the modifies clause is translated wierdly.
	
	
	2. question - if the wp formula is of teh form P(a, old(a)) where is a java or jml expression, are they considered as equal ,as in the beginning the expression a has still the value old(a) ?
	
	
	////////////////////////////////////////////////////////////////////////////////
	///08/09///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////	
1. wp_exc - to make it work ok - first look exc handles, then look exsures, then 
2. dup instruction - to do
3 . Typeof - todo

	////////////////////////////////////////////////////////////////////////////////
	///10/09///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////	
	  1. modifies_dot - shouldn't it be :
	  modifiesdot constant modifies Expression
	  
	  2.  getType in class Expression must return Expression plus tot que JavaType
	  
	  ///////////////////////////////
	  //////////////13/09//////////
	  ///////////////////////
 	   1. [ expr1 expr2 - expr1 is the index to be accessed ? and expr2 the array reference ? 
 	   
 	   
 	   ////////////////////////////////////////////////////////
 	   /////////////////////24-september//////////////////////
 	   //////////////////////////////////////
 	   bugs - class file annotation
 	   1. the modifies expression
 	   this.b.arr[1..3] transalted into   15.this.255[3..1] - still 
 	   2. the jmlClassFileAnnotator doesnot understand  //@ modify ref.array[i1..i2].field;
 	   
 	   WHAT is done ? 
 	   ModifiesArray.getConditionForInterval is corrected.
 	   
 	   ////////////////////////////////////////
 	   ///////////////30-09/////////////
 	   ///////////////////////////////
 	   ////////////bcel - BUGS///////////////////////
 	   1. test BCMethod - didnot succeed - bug in the relation btw blocks
 	   2 . the functions that surcharge (FieldWITh, etc ) must be done in this way that , for ex: 
 	   if (a (5 <- loc(0)  r) .substitute(locl) 
 	   
 	   3. NB: if the specification mentions fields that are not dereferenced in the bytecode, this means taht
 	   there is not a number in the constant pool that mentions them and ==> one should add in the constant pool an
 	   index in the cp for this field 