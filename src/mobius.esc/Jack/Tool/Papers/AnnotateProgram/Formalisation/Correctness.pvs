CorrectnessAnnProgram[CP, Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    IMPORTING ValProp[Name]

    CP_is_enumerable : ASSUMPTION
      EXISTS (f : [CP -> nat]) : injective?(f)

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING VariableNames[CP, Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [mp : (wf_and_complete_MP) -> [CP -> (legal_names(mp))]]) : 
        FORALL(mp : (wf_and_complete_MP)) : 
          injective?(f(mp))

  ENDASSUMING


  IMPORTING MethodCallsPreserveRelatedState[CP, Name],
            AnnotateProgramPropertiesPreservation[CP, Name]

  mp : VAR ({mp : MonitoredProgram | wf_and_complete_MP(mp) AND 
                                     wf_set_stmts(mp)})


  % Base case
  initial_states_are_equivalent : LEMMA % :-)
    FORALL (root_object : (defined?)) :
      related_states(mp)(initial_MP_state(mp)(root_object),
                         initial_AP_state(ann_program(mp))(root_object))

  % Inductive case
  derive_preserves_related_states_for_unchanged_program : THEOREM % :-)
    FORALL (b : (wf_Body(program(mp))), v1, v2 : Val)
           (sMP1, sMP2 : MPState, sAP1, sAP2 : APState)
           (n1, n2 : nat) :
      well_behaved_MVA_for_annot_gen(mp) IMPLIES
      subset?(var_names(b), ext_declared_var_names(program(mp))) IMPLIES
      related_states(mp)(sMP1, sAP1) IMPLIES
      derive(mp)(b, sMP1, v1, sMP2)(n1) IMPLIES
      derive(ann_program(mp))(b, sAP1, v2, sAP2)(n2) IMPLIES
      legal_Program_AP(ann_program(mp)) IMPLIES
      legal_Body(ann_program(mp))(b) IMPLIES
        related_states(mp)(sMP2, sAP2) AND 
        (NOT cp(astate(sMP2)) = halted IMPLIES v1 = v2)

  % There is an equivalent statement for an MVA transition on the annotated 
  % program
  on_method_MVA_equivalent_statement : LEMMA
    FORALL (m : (wf_Method(program(mp))), et : EventType, v : ValOrExcpt)
           (sMP1, sMP2 : MPState, sAP1 : APState) :
      well_behaved_MVA_for_annot_gen(mp) IMPLIES
      related_states(mp)(sMP1, sAP1) IMPLIES
      methods(get_monitored_class(mp))(m) IMPLIES
      NOT cp(astate(sMP1)) = halted IMPLIES
      sMP2 = on_method_MVA(et)(mp, m)(v)(sMP1) IMPLIES
        EXISTS (sAP2 : APState, n : nat) :
          derive(ann_program(mp))
                (ann_event(mp)(filter_event(mva(mp))(et)(name(m)))(v),
                 sAP1, Unit, sAP2)(n)

  % Method call case of related_states_implies_derive_for_unchanged_program
  related_states_implies_derive_for_method_call : LEMMA
    FORALL (b : (wf_Body(program(mp))), v1 : Val)
           (sMP1, sMP2 : MPState, sAP1 : APState)
           (n1 : nat) :
      MethodCall?(b) IMPLIES
      well_behaved_MVA_for_annot_gen(mp) IMPLIES
      subset?(var_names(b), ext_declared_var_names(program(mp))) IMPLIES
      legal_Program_AP(ann_program(mp)) IMPLIES
      wf_set_stmts_AP(ann_program(mp)) IMPLIES
      legal_Body(ann_program(mp))(b) IMPLIES
      related_states(mp)(sMP1, sAP1) IMPLIES
      NOT cp(astate(sMP1)) = halted IMPLIES
      derive(mp)(b, sMP1, v1, sMP2)(n1) IMPLIES
      (FORALL (b: (wf_Body(program(mp))), v1: Val)
              (sMP1, sMP2: MPState, sAP1: APState)(m1 : below(n1)) :
        subset?(var_names(b), ext_declared_var_names(program(mp))) IMPLIES
        legal_Body(ann_program(mp))(b) IMPLIES
        related_states(mp)(sMP1, sAP1) IMPLIES
        NOT cp(astate(sMP1)) = halted IMPLIES
        derive(mp)(b, sMP1, v1, sMP2)(m1) IMPLIES
          (EXISTS (sAP2: APState, v2: Val, n2: nat):
           derive(ann_program(mp))(b, sAP1, v2, sAP2)(n2))) IMPLIES
        EXISTS (sAP2 : APState, v2 : Val, n2 : nat) : 
          derive(ann_program(mp))(b, sAP1, v2, sAP2)(n2)

  % The annotated program simulates the monitored program
  % Note that the converse does not hold because the new annotatations the
  % annotated program can terminate while the monitored program does not
  related_states_implies_derive_for_unchanged_program : THEOREM % :-)
    FORALL (b : (wf_Body(program(mp))), v1 : Val)
           (sMP1, sMP2 : MPState, sAP1 : APState)
           (n1 : nat) :
      well_behaved_MVA_for_annot_gen(mp) IMPLIES
      subset?(var_names(b), ext_declared_var_names(program(mp))) IMPLIES
      legal_Program_AP(ann_program(mp)) IMPLIES
      wf_set_stmts_AP(ann_program(mp)) IMPLIES
      legal_Body(ann_program(mp))(b) IMPLIES
      related_states(mp)(sMP1, sAP1) IMPLIES
      NOT cp(astate(sMP1)) = halted IMPLIES
      derive(mp)(b, sMP1, v1, sMP2)(n1) IMPLIES
        EXISTS (sAP2 : APState, v2 : Val, n2 : nat) : 
          derive(ann_program(mp))(b, sAP1, v2, sAP2)(n2)

  % Correctness of the annotate program function
  correctness_of_ann_program : THEOREM % :-)
    FORALL (main : Name, arg : int)(root_object : (defined?))
           (sMP : MPState) :
      well_behaved_MVA_for_annot_gen(mp) IMPLIES
      legal_Program_AP(ann_program(mp)) IMPLIES
      wf_set_stmts_AP(ann_program(mp)) IMPLIES
      run_monitored_program(mp)(main, arg)(root_object)(sMP) IMPLIES
      EXISTS(sAP : APState) :
      run_annotated_program(ann_program(mp))
                               (main, arg)(root_object)(sAP) AND
        related_states(mp)(sMP, sAP)


END CorrectnessAnnProgram
