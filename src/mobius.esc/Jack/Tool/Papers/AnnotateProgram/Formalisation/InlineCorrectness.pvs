CorrectnessInlineProgram[Name : TYPE+] : THEORY
BEGIN

  ASSUMING

    infinite_namespace : ASSUMPTION
      is_infinite({n : Name | TRUE})

    IMPORTING InlineVariableNames[Name]

    name_of_exists : ASSUMPTION
      EXISTS (f : [p : Program -> [Method -> (legal_names(p))]]) :
        FORALL(p : Program) :
          injective?(f(p))

  ENDASSUMING


  IMPORTING InlineRelatedStatesProperties[Name]
  IMPORTING WfSetStmtsAP[Name],
            ContainsNoMethodCall[Name]

  p : VAR ({p : Program | wf_set_stmts_AP(p) AND 
                          contains_no_method_call_in_sets_in_program(p)})


  % AXIOM:
  % derivation of a set annotation is the same if argument is replaced
  % by a new expression, that will always return the same value
  % i.e., argument is only evaluated for its value, and does not affect
  % the rest of set-annotation
  pre_post_set_arguments : AXIOM
    FORALL(p : Program, m : Method, s1, s2 : APState,
           val, v : Val, nm : Name, t : JType, n : nat,
           set : [Expr -> Stmt]) :
      methods(p)(m) IMPLIES
      (set = pre_set(m) OR set = post_set(m)) IMPLIES
      defined?(val) IMPLIES
      lvs(st(pstate(s1)))(nm) = val IMPLIES
      derive(inline_program(p))(set(Const(val)), s1, v, s2)(n) =
      derive(inline_program(p))(set(var_lookup(nm)(t)), s1, v, s2)(n) 

  pre_post_set_inline_related_states : LEMMA
    FORALL(p : Program, m : Method, sA1, sA2, sB1, sB2 : APState,
           val, v1, v2 : Val, nm : Name, t : JType, x1, x2 : nat,
           n1 : below(x1), n2 : below(x2),
           set : [Expr -> Stmt]) :
      methods(p)(m) IMPLIES
      (set = pre_set(m) OR set = post_set(m)) IMPLIES
      inline_related_states(p)(sA1, sB1) IMPLIES
      defined?(val) IMPLIES
      lvs(st(pstate(sB1)))(nm) = val IMPLIES
      derive(p)(set(Const(val)), sA1, v1, sA2)(n1) IMPLIES      
      derive(inline_program(p))
            (set(var_lookup(nm)(t)), sB1, v2, sB2)(n2) IMPLIES
      (FORALL (b_1: (wf_Body(p)), v1, v2: Val)
             (sAP1a, sAP1b, sAP2a, sAP2b: APState)
             (m1: below(x1), m2: below(x2)):
        subset?(var_names(b_1), ext_declared_var_names(p)) IMPLIES
         inline_related_states(p)(sAP1a, sAP2a) IMPLIES
          derive(p)(b_1, sAP1a, v1, sAP1b)(m1) IMPLIES
           derive(inline_program(p))(b_1, sAP2a, v2, sAP2b)(m2) IMPLIES
            inline_related_states(p)(sAP1b, sAP2b) AND v1 = v2) IMPLIES
        inline_related_states(p)(sA2, sB2) AND v1 = v2


  % post_set annotation does not change value stored in res(p)(m)
  % i.e., new program variables not affected by post_set
  result_expression_preservation : AXIOM
    FORALL(p : Program, m : Method, s1, s2, s3 : APState,
           v1, v2, w : Val, n1, n2 : nat) : 
      methods(p)(m) IMPLIES
      lvs(st(pstate(s1)))(res(p)(m)) = v1 IMPLIES
      derive(inline_program(p))
            (post_set(m)(var_lookup(res(p)(m))(res_type(m))), s1, w, s2)(n1) 
      IMPLIES
      derive(inline_program(p))
            (var_lookup(res(p)(m))(res_type(m)), s2, v2, s3)(n2) IMPLIES
      v1 = v2

  % for convenience, explicit lemma that inline_related_states preserved
  % by method calls
  derive_maintains_inline_related_states_for_method_call : LEMMA
    FORALL (b : (wf_Body(p)), v1, v2 : Val)
           (sAP1a, sAP1b, sAP2a, sAP2b : APState)
           (n1, n2 : nat) :
      MethodCall?(b) IMPLIES
      subset?(var_names(b), ext_declared_var_names(p)) IMPLIES
      inline_related_states(p)(sAP1a, sAP2a) IMPLIES
      derive(p)(b, sAP1a, v1, sAP1b)(n1) IMPLIES
      (FORALL(b : (wf_Body(p)), v1, v2 : Val)
             (sAP1a, sAP1b, sAP2a, sAP2b : APState)
             (m1 : below(n1), m2 : below(n2)) :
        subset?(var_names(b), ext_declared_var_names(p)) IMPLIES
        inline_related_states(p)(sAP1a, sAP2a) IMPLIES
        derive(p)(b, sAP1a, v1, sAP1b)(m1) IMPLIES
        derive(inline_program(p))(b, sAP2a, v2, sAP2b)(m2) IMPLIES
          inline_related_states(p)(sAP1b, sAP2b) AND v1 = v2) IMPLIES
      derive(inline_program(p))(b, sAP2a, v2, sAP2b)(n2) IMPLIES
        inline_related_states(p)(sAP1b, sAP2b) AND v1 = v2

  % Base case
  initial_states_are_equivalent : LEMMA % :-)
    FORALL (root_object : (defined?)) :
      inline_related_states(p)
        (initial_AP_state(p)(root_object),
         initial_AP_state(inline_program(p))(root_object))

  % Inductive case: preservation of inline_related_states by derive
  derive_maintains_inline_related_states_for_unchanged_program : THEOREM
    FORALL (b : (wf_Body(p)), v1, v2 : Val)
           (sAP1a, sAP1b, sAP2a, sAP2b : APState)
           (n1, n2 : nat) :
      subset?(var_names(b), ext_declared_var_names(p)) IMPLIES
      inline_related_states(p)(sAP1a, sAP2a) IMPLIES
      derive(p)(b, sAP1a, v1, sAP1b)(n1) IMPLIES
      derive(inline_program(p))(b, sAP2a, v2, sAP2b)(n2) IMPLIES
        inline_related_states(p)(sAP1b, sAP2b) AND v1 = v2

  % auxiliary lemma: two derivations starting in related states
  % then pstates change in similar ways
  derive_pstate_changes_inlined_program_for_unchanged_program : LEMMA % :-)
    FORALL (b : (wf_Body(p)), v1, v2 : Val)
           (sAP1a, sAP1b, sAP2a, sAP2b : APState)
           (n1, n2 : nat) :
      subset?(var_names(b), ext_declared_var_names(p)) IMPLIES
      inline_related_states(p)(sAP1a, sAP2a) IMPLIES
      derive(p)(b, sAP1a, v1, sAP1b)(n1) IMPLIES
      derive(inline_program(p))(b, sAP2a, v2, sAP2b)(n2) IMPLIES
      (FORALL (n : Name) :
        IF lvs(st(pstate(sAP1a)))(n) = lvs(st(pstate(sAP1b)))(n) 
        THEN lvs(st(pstate(sAP2a)))(n) = lvs(st(pstate(sAP2b)))(n)
        ELSE NOT (lvs(st(pstate(sAP2a)))(n) = lvs(st(pstate(sAP2b)))(n))
        ENDIF)

  % auxiliary lemma, direct consequence of 
  % derive_pstate_changes_inlined_program_for_unchanged_program
  derive_maintains_lvs_pstate_inlined_program_for_unchanged_program : LEMMA % :-)
    FORALL (b : (wf_Body(p)), v1, v2 : Val)
           (sAP1a, sAP1b, sAP2a, sAP2b : APState)
           (n1, n2 : nat) :
      subset?(var_names(b), ext_declared_var_names(p)) IMPLIES
      inline_related_states(p)(sAP1a, sAP2a) IMPLIES
      derive(p)(b, sAP1a, v1, sAP1b)(n1) IMPLIES
      derive(inline_program(p))(b, sAP2a, v2, sAP2b)(n2) IMPLIES
      lvs(st(pstate(sAP1a))) = lvs(st(pstate(sAP1b))) IMPLIES
        lvs(st(pstate(sAP2a))) = lvs(st(pstate(sAP2b))) 


  % for convenience, explicit lemma that inline_related_states implies
  % derive for method calls
  inline_related_states_implies_derive_for_method_call : LEMMA
    FORALL (b : (wf_Body(p)), v : Val)
           (sAP1a, sAP1b, sAP2a : APState)
           (n1 : nat) :
      MethodCall?(b) IMPLIES
      subset?(var_names(b), ext_declared_var_names(p)) IMPLIES
      inline_related_states(p)(sAP1a, sAP2a) IMPLIES
      derive(p)(b, sAP1a, v, sAP1b)(n1) IMPLIES
      (FORALL(b : (wf_Body(p)), v : Val)
             (sAP1a, sAP1b, sAP2a : APState)
             (m1 : below(n1)) :
        subset?(var_names(b), ext_declared_var_names(p)) IMPLIES
        inline_related_states(p)(sAP1a, sAP2a) IMPLIES
        derive(p)(b, sAP1a, v, sAP1b)(m1) IMPLIES
        EXISTS(sAP2b : APState, n2 : nat) :
          derive(inline_program(p))(b, sAP2a, v, sAP2b)(n2)) IMPLIES
          EXISTS(sAP2b : APState, n2 : nat) :
            derive(inline_program(p))(b, sAP2a, v, sAP2b)(n2)

  % derivation in original program, implies existence of derivation in
  % inlined program
  inline_related_states_implies_derive_for_unchanged_program : THEOREM
    FORALL (b : (wf_Body(p)), v : Val)
           (sAP1a, sAP1b, sAP2a : APState)
           (n1 : nat) :
      subset?(var_names(b), ext_declared_var_names(p)) IMPLIES
      inline_related_states(p)(sAP1a, sAP2a) IMPLIES
      derive(p)(b, sAP1a, v, sAP1b)(n1) IMPLIES
        EXISTS(sAP2b : APState, n2 : nat) :
          derive(inline_program(p))(b, sAP2a, v, sAP2b)(n2)

  % The main result: inline_related_states is a simulation relation
  correctness_of_inline_program : THEOREM % :-)
    FORALL (main : Name, arg : int)(root_object : (defined?))
           (sAP1 : APState) :
      run_annotated_program(p)(main, arg)(root_object)(sAP1) IMPLIES
      EXISTS(sAP2 : APState) :
      run_annotated_program(inline_program(p))
                               (main, arg)(root_object)(sAP2) AND
        inline_related_states(p)(sAP1, sAP2)


END CorrectnessInlineProgram
