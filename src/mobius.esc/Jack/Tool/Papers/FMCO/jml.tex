\section{A Quick Overview of JML}\label{SecJML}



This section gives a short overview of JML, by means of an
example. Throughout the rest of this paper, we assume the reader is
familiar with JML, its syntax and semantics. For a detailed overview
of JML we refer to the reference manual~\cite{LeavensPCCRCK05}; a
detailed overview of the tools that support JML can be found
in~\cite{BurdyCCEKLLP03}.  Notice that JML is designed to be a general
specification language that does not impose any particular design
method or application domain~\cite{LeavensBR06}.



To illustrate the different features of JML, Figure~\ref{FigJMLSpec}
shows a fragment of a specification of class
\texttt{QuickSort}. It contains a public method
\texttt{sort}, that sorts the array stored in the private field
\texttt{tab}. Sorting is implemented via  a method \texttt{swap},
swapping two elements in the array, and a private method
\texttt{sort}, that actually implements the quicksort algorithm.

\begin{figure}[t!]
{\small
\begin{verbatim}
public class QuickSort {
  private int [] tab;

  public QuickSort(int[] tab) {this.tab = tab;}

  /*@ requires (tab != null) ;
    @ assignable tab[0 .. (tab.length -1)];
    @ ensures (\forall int i, j; 0 <= i && i <= (tab.length - 1) ==> 
    @                            0 <= j && j <= (tab.length - 1) ==>
    @                            i < j ==> tab[i] <= tab[j]) &&
    @         (\forall int i; 0 <= i && i <= (tab.length - 1) ==> 
    @             (\exists int j; 0 <= j && j <= (tab.length - 1) && 
    @                             \old(tab[j]) == tab[i])); @*/
  public void sort() {if(tab.length > 0) sort(0, tab.length -1);}

  /*@ requires (tab != null) && (0 <= i) && (i < tab.length) && 
    @          (0 <= j) && (j < tab.length);
    @ assignable tab[i], tab[j];
    @ ensures tab[i] == \old(tab[j]) && (tab[j] == \old(tab[i])); @*/
  public void swap(int i, int j) { ... }

  private void sort(int lo, int hi) { ... }
}
\end{verbatim}
}
\vspace*{-1em}\caption{Fragment of class \texttt{QuickSort} with JML annotations} 
\label{FigJMLSpec}
\end{figure}



In order not to interfere with the Java compiler, JML
specifications are written as special comments (tagged with
\texttt{@}). Method specifications contain preconditions (keyword
\jmlKey{requires}), postconditions (\jmlKey{ensures}) and frame
conditions (\jmlKey{assignable}). The latter specifies which variables
\emph{may} be modified by a method. In a method body, one can
annotate all statements with an \jmlKey{assert} predicate and loops
also with invariants (\jmlKey{loop\unsc invariant}), and variants
(\jmlKey{decreases}). One can also specify class invariants,
\emph{i.e.}, properties that should hold in all visible states of the
execution, and constraints, describing a relation that 
holds between any two pairs of consecutive visible states (where
visible states are the states in which a method is called or returned
from).

The predicates in the different conditions are side-effect free Java
boolean expressions, extended with specification-specific keywords,
such as \jmlKey{\bsl result}, denoting the return value of a non-void
method, \jmlKey{\bsl old}, indicating that an expression should be
evaluated in the pre-state of the method, and the logical quantifiers
\texttt{\bsl forall} and \texttt{\bsl exists}. Re-using the Java syntax
makes the JML specifications easily accessible to Java developers.

JML allows further to declare special specification-only variables:
logical variables (with keyword \jmlKey{model}) and so-called
\jmlKey{ghost} variables, that can be assigned to in special
\jmlKey{set} annotations.

Figure~\ref{FigJMLSpec} specifies that method \texttt{sort} sorts the
array \texttt{tab} from low to high, and all elements that occurred in
the array initially also occur in its afterwards\footnote{Note that
this specification does not require that the final value of
\texttt{tab} is a sorted permutation of its initial value. However, this
could be expressed in JML as well.}, and that method
\texttt{swap} swaps the contents of the array at positions \texttt{i}
and \texttt{j}. 

