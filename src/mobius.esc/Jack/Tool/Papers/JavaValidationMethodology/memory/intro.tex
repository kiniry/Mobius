% Introduction 

Another application is a framework to perform a precise analysis of resource consumption for
Java bytecode programs (for the clarity of the explanations all
examples in the introduction deal with source code).  In order
to illustrate the principles of our approach, let us consider the
following program:
\begin{verbatim}
public void m (A a) {
  if (a == null) 
    { a = new A();  }  
  a.b = new B(); }
\end{verbatim}
In order to model the memory consumption of this program, we introduce
a {\em ghost} (or, {\em model}) variable \verb!Mem! that accounts for
memory consumption; more precisely, the value of \verb!Mem! at any
given program point is meant to provide an upper bound to the amount
of memory consumed so far. To keep track of the memory consumption, we
perform immediately after every bytecode that allocates memory an
increment of \verb!Mem!\ by the amount of memory consumed by the
allocation. Thus, if the programmer specifies that \verb!ka! and
\verb!kb! is the memory consumed by the allocation of an instance of
class \verb!A! and \verb!B! respectively, the program must be
annotated as:
\begin{verbatim} 
public void m (A a) {
 if (a == null) 
   {a = new A(); //set Mem = Mem + ka;}  
 a.b = new B(); //set Mem = Mem + kb; }
\end{verbatim}
Such annotations allow to compute at run-time the memory consumed by
the program. However, we are interested in static prediction of memory
consumption, and resort to pre- and postconditions to this end.  

Even for a simple example as above, one can express the specification
at different levels of granularity. For example, fixing the amount of
memory that the program may use, \verb!Max!, one can specify that the
method will use at most \verb!ka! $+$ \verb!kb! memory units and will not
overpass the authorized limit \verb!Max!, with the following
specification:
$$
\begin{array}{ll}
//@ \ \requires & \Mem + \srcCode{ka} + \srcCode{kb} \leq \Max \\
//@ \ \ensures &  \Mem \leq \oldp(\Mem) + \srcCode{ka} + \srcCode{kb}     
\end{array}
$$
\begin{verbatim}
    public void m (A a) { ... }
\end{verbatim}
Or try to be more precise and relate memory consumption to inputs with
the following specification:
%\begin{verbatim}
$$
\begin{array}{l}
//@ \ \requires \ \srcCode{a==null} \Rightarrow \Mem + \srcCode{ka} + \srcCode{kb} \leq \Max \\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \land \ \srcCode{!(a==null)} \Rightarrow \Mem + \srcCode{kb} \leq \Max \\
//@ \ \ensures \\
\ \ \ \ \ \ \   \old\srcCode{(a)==null} \Rightarrow \Mem \leq \oldp(\Mem) + \srcCode{ka} + \srcCode{kb} \\ 
\ \ \ \ \ \ \land \ !(\old\srcCode{(a)==null}) \Rightarrow \Mem \leq \oldp(\Mem) + \srcCode{kb}    
\end{array}
$$
\begin{verbatim}
  public void m (A a) { ... }
\end{verbatim}
More complex specifications are also possible: one can
take into account whether the program will throw an exception or not by
using (possibly several) exceptional postconditions stating that
$\texttt{k}_{\texttt{E}}$ memory units are allocated in case the
method exits on exception \texttt{E}.

The main characteristics of our approach are:
\begin{itemize}
\item \emph{Precision:} our analysis allows to specify and enforce
precise memory consumption policies, including those that take
into account the results of branching statements or the values of
parameters in method calls. Being based on program logics, which are
very versatile, the precision of our analysis can be further improved
by using it in combination with other analysis, such as control flow
analysis and exception analysis;


\item \emph{Correctness:} our analysis exploits existing program logics
which are (usually) already known to be sound. In fact, it is immediate
to derive the soundness of our analysis from the soundness of the program
logic, provided ghost annotations that update memory consumption variables
are consistent with an instrumented semantics that  extends the language
operational semantics with a suitable cost model that reflects resource
usage;

\item \emph{Language coverage:} our analysis relies on the existence
of a verification condition generator for the programming language at
hand, and is therefore scalable to complex programming features.  In
the course of the document, we shall illustrate applications of our
approach to programs featuring recursive methods, method
overriding and exceptions;


\item \emph{Usability:} our approach can be put to practice
immediately using existing verification tools for program logics. We
have applied it to annotated Java bytecode programs using a
verification environment developed in \cite{BP06:sac}. It is also
possible to use our approach on JML annotated Java source
code~\cite{BRL-JACK}, and more generally on programs that are written
in a language for which appropriate support for contract-based
reasoning exists;




\item \emph{Annotation and proof generation:} in contrast to other
techniques discussed above, our approach requires user interaction,
both for specifying the program and for proving that it meets its
specification.  In order to reduce the burden of the user, we have
developed heuristics that infer automatically part of the annotations,
and use automatic procedures to help discharge many proof obligations
automatically.
\end{itemize}
Furthermore, our analysis may be used to guarantee that no memory
allocation is performed in undesirable states of the application,
namely after initialization or during a transaction in a Java Card.

More information can be found in a companion document~\cite{gmg05:sefm}.
