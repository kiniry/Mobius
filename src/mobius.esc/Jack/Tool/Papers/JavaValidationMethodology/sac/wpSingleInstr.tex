%\subsubsection{Weakest Precondition Function for bytecode \\instructions}\label{wpInstr}
%We define a weakest precondition (\wpi) predicate transformer function which takes into account normal and exceptional termination. 
%\wpi \ takes three arguments: an instruction, a predicate that is the instruction's normal postcondition $\psi$, and a function
%from exception types to predicates $\excPost$ (it returns the specified postcondition in the \jmlKey{exsures} clause for a given exception; see section~\ref{grammar}).
%The \wpi \ function returns the weakest predicate such that if it holds in the state when the instruction starts its execution the following conditions are met: 
%\begin{enumerate}
        % \item if the instruction terminates its execution normally the predicate $\psi$ holds in the poststate 
        % \item if it terminates with an exception \texttt{E} then the predicate $\excPost(\tt{E})$ holds in the poststate.
%\end{enumerate}


 
 %The instruction $\instr{Type\_load} \ i$ loads on the top of the stack the value of the method local variable at index \textit{i}
 %in the \textbf{Local\_Variable\_Table} (see section~\ref{bcSpecLg}).

%As we said in the beginning of the section, \wpi \ ``understands'' the bytecode specification language, i.e. the keywords have their 
%corresponding semantics. For example, the keyword \result \ is evaluated only by \instr{Type\_return} 
%instructions and if appearing in the postcondition, \result \ is substituted by the element on the top of 
%the stack \stack{\counter}. 

%The rules also take into account the possible abnormal execution of the instruction. For example, in Fig. \ref{instrWP}, the rule for the instruction \instr{putField}
%has two conjuncts - one in the case when the dereferenced object is not null and the instruction execution terminates normally; the other one stands for the case when this is not true. Note, in case the exception thrown is not handled, we substitute the special specification variable \jmlKey{EXC} with the thrown exception object.


%\begin{itemize}
%\item 
\subparagraph*{Manipulating object fields}
%\subsubsection{Manipulating object fields}
Instance fields are treated as functions, where the domain of a field \texttt{f} 
declared in the class \texttt{Cl} is the set of objects of class \texttt{Cl} and its subclasses.
We are using function updates when assigning a value to a field reference as, for instance in~\cite{B00ppp}.
In Fig.\ref{instrWP}, we give the \wpi \ rule for the
instruction \instr{putfield} \texttt{Cl.f}, which updates the field \texttt{Cl.f}\footnote{ \texttt{Cl.f} stands for the field \texttt{f} declared in class 
\texttt{Cl}} of the object referenced by the reference stored in the stack below the stack top \stack{\counter-1} with the value on the stack top \stack{\counter}.
Note that the rule takes in account the possible exceptional termination of the instruction execution.


% \item \textbf{Method calls}

%Method calls are handled by using their specification. A method specification is a contract between callers and callees --- the precondition of the called method
%must be established by the caller at the program point where the method is invoked and its postcondition is assumed to hold after the invocation. The rule for
%invocation of a non-void instance method is given in Fig.~\ref{wpInv}. In the precondition of the called method, the formal parameters and the object on which the method is called are substituted with the first \texttt{nArg(m)+1} elements from the stack top. 
%Because the method returns a value, if it terminates normally, any occurrence of the JML keyword \result \ in $\psi^{post}(m)$ is substituted with the fresh variable \texttt{fresh\_var}.  
%Because the return value in the normal case execution is put on the stack top, the \texttt{fresh\_var} is substituted for the stack top in $\psi$. The resulting predicate is quantified over the locations that may be modified by the called method. We also assume that if the invoked method terminates abnormally, by throwing an exception of type $\texttt{Exc}$, on returning the control to the invoker its exceptional postcondition $\excPost_{\tt{m} }( \tt{Exc} )$ holds. 
%%The rule for static methods is rather the same except for the number of stack elements taken from the stack.  

%\begin{figure}[htp]
%$$
%\begin{array}{l}
%\wpi(\instr{invoke \  m}, \ \psi ,\ \excPost) =\\ 
%\begin{array}{l}
%\Myspace \psi^{pre}(m) \ \wedge \\
%\Myspace  \forall_{j = 1..s} e_{j}.\biggl( 
%\Myspace \psi^{post}( \texttt{m}) 
%                     \begin{array}{l}
%                     \substitution{\register{i}}{\stack{\counter+i-nArg(\texttt{m}) }}_{i=0}^{\tt{nArg(m)}}  \\
%                      \substitution{\tt{\backslash result} }{ fresh\_var } \\
%                     \end{array} \\
%  \Myspace\Myspace\Myspace\Myspace\Myspace                    \Rightarrow  \\
%\Myspace\Myspace\Myspace\Myspace\Myspace   \psi  \begin{array}{l}
%                             \substitution{\counter }{\counter - \tt{nArg}( \texttt{m} )} \\
%                             \substitution{\stack{\counter } }{ \tt{fresh\_var}}  \   
%                         \end{array}\biggr) \\
%\wedge_{i = 1}^k\\
%\Myspace \forall_{j = 1..s} e_i \biggl( 
%\Myspace \excPost_{\tt{m} } ( \tt{Exc_i} ) % \\

%\Rightarrow %\\

%\excPost(\tt{Exc_i} )
%                                 \begin{array}{l}
%                                       \substitution{ \counter}{  0} \\
%                                        \substitution{\stack{0}}{ \stack{\counter}}   
%                       \end{array}   \biggr)   \\
%\end{array} \\[15 mm]
%\end{array}$$
%$\psi^{pre}(\texttt{m})$ -  the specified  precondition of  method \texttt{m} \\
%$\psi^{post}(\texttt{m})$ - the   specified   postcondition   of   method  \texttt{m}  \\
%$\excPost_{\texttt{m}}$ - the   exceptional   function   for   method  \texttt{m}  \\
%\texttt{nArg}( \texttt{m} ) -  the    number   of   arguments   of   \texttt{m} \\  
%$e_{j} , j = 1 .. s$ - the   locations   modified   by   method   \texttt{m} \\
%$\tt{Exc_i}, i = 1..k$ -  the   exceptions   that  \texttt{m} may  throw \\
%\caption{\sc \wpi \ rule for a call to an instance non void method}
%\label{wpInv}
%\end{figure}



\subparagraph*{Loops}
%\subsubsection{Loops}
Identifying loops on bytecode and source programs is different because of their different nature --- 
the first one lacks while the second has structure. While on source level loops correspond to loop statements,  
on bytecode level we have to analyze the control flow graph in order to find them.
 The analysis consists in looking for the backedges in the control flow graph using standard compiler techniques. 
  
 We assume that a method's bytecode is provided with sufficient specification and in particular loop invariants.
 Under this assumption, we build an abstract control flow graph where the backedges are replaced by
 the corresponding invariant. We apply the \wpi \ function over the abstract version of the control flow graph which generates verification conditions for the 
preservation and initialization of every invariant in the abstraction graph. 


     

\subparagraph*{Exceptions and Subroutines}
Exception handlers are treated by identifying the instruction at which the handler compilation starts. The JVM specification mandates 
that a Java compiler must supply for every method an \textbf{Exception\_Table} attribute that contains data structures describing the compilation of every implicit (in the presence of subroutines) or explicit exception handler: the instruction at which the compiled exception handler starts,
 the protected region (its start and end instruction indexes), and the exception type the exception handler protects from. Thus, 
for every instruction \instr{ins} in method \method~ which may terminate exceptionally on exception \texttt{Exc} the exceptional function
 $\excPost$  returns the \wpi \ predicate of the exceptional handler protecting \instr{ins} from \texttt{Exc} if such a handler exists.
Otherwise, $\excPost$ returns the specified exceptional postcondition for exception \texttt{Exc} as specified in the specification of
method \method.

Subroutines are treated by abstract inlining\footnote{NB: we do not transform the bytecode. It is rather the \wpi \
 function that treats subroutines as if the subroutines were inlined}. First, the instructions of every subroutine
 are identified. %To this end, we suppose that the bytecode has
% been certified by a bytecode verifier which guarantees
%that there are no recursive subroutines.
To this end, we assume that the code has passed the bytecode verification and that every subroutine terminates with a \instr{ret} 
instruction(usually, the compilation of subroutines ends with a \instr{ret} instruction but it is not always the case). Thus, by abstract inlining, we mean that
 whenever the \wpi~function is applied to an instruction \instr{jsr}  \texttt{ind}, a postcondition $\psi$ and an exceptional postcondition function $\excPost$, its precondition  $\wpi^{\instr{jsr} \ \tt{ind}}$ is calculated as follows: the \wpi \ is applied to the bytecode instructions that represent the subroutine which starts at instruction \texttt{ind},
 the postcondition $\psi$ and the exceptional postcondition function  $\excPost$.
% This actually results in the weakest predicate 
%$\wpi^{\instr{jsr} \ \tt{ind}}$ of the subroutine starting at index \texttt{ind} and which guarantees that after its execution 
%$\psi$ will hold in the normal case, otherwise if the subroutine terminates on exception \texttt{Exc} then $\excPost(\texttt{Exc})$ will hold.
  








