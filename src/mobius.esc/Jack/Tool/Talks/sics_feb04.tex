\documentclass[final,nocolorBG,a4,marieke,nototal,pdf, accumulate,slideColor]{prosper}

\addtolength{\textheight}{-1cm}

\usepackage{pstricks,pst-node,pst-text,pst-3d}
\usepackage{amsmath}
\usepackage{alltt}
\usepackage{epsfig}

\usepackage{colordvi}
\usepackage{proof}
\usepackage{epsf}
\usepackage{amssymb}

\input{prooftree}
\newcommand{\textttbf}[1]{\texttt{\textbf{#1}}}
 \def \bsl       {\symbol{92}}
 \def \unsc      {\symbol{95}}

\title{Enforcing high-level security properties using JML}
\subtitle{}
\author{Marieke Huisman}
\institution{INRIA Sophia Antipolis
\medskip\\
\Blue{joint work with Mariela Pavlova, Gilles Barthe, Lilian Burdy \\Jean-Louis Lanet \& Igor Siveroni}}
\email{Marieke.Huisman@inria.fr}

\slideCaption{Security properties and JML}
\Logo{}
\begin{document} 

\maketitle

\begin{slide}{Enforcing security properties today}
\begin{itemize}
\item \Blue{Security expert}: from global notions of security to set
of rules
\item \Blue{Developers}: try to obey rules
\item \Blue{Security audit}: manual code inspection whether rules
obeyed
\item Need for tools to help security audit
\end{itemize}
\end{slide}

\begin{slide}{First steps}
\begin{itemize}
\item Several projects around formal methods for smart cards
(Verificard, SecSafe, \ldots)
\item Emergence of standard specification language: \Blue{JML}
\item Smart card industry starts to use formal specifications
\item But still: 
\begin{itemize}
\item Limitations on what can be expressed
\item Limitations on what can be checked \Blue{(automatically)}
\end{itemize}
\end{itemize}
\end{slide}


\begin{slide}{Contents}
\begin{itemize}
\item JML: what is there already
\item Security properties
\item A method for annotation generation
\item Towards security automata
\end{itemize}
\end{slide}

\begin{slide}{Java Modeling Language}
\begin{itemize}
\item Behavioural interface specification language
\item Developed by Gary Leavens \emph{et al.} at Iowa State University
\item Annotations written as comments in source code
\item The web-page: \Blue{\textttbf{\textbf{http://www.jmlspecs.org}}}
\item Mailing list: \textttbf{jmlspecs-interest@lists.sourceforge.net}.
\end{itemize}
\end{slide}

\begin{slide}{Design goals JML}
\begin{itemize}
\item Readable specifications
\item Provide unambiguous documentation
\item Usable for any Java application
\item Rigorous, formal semantics~-~amenable to tool support 
\end{itemize}
\end{slide}

\begin{slide}{Method Specifications}
\begin{itemize}
\item Precondition  (\Blue{requires})
\item Postcondition (\Blue{ensures})
\item Exceptional postcondition (\Blue{exsures}, \Blue{signals})
\item Modifiable clause (\Blue{assignable}, \Blue{modifies}, \Blue{modifiable})
\end{itemize}
All conditions: \Blue{side-effect free Java expressions} with boolean
result type
\end{slide}

\begin{slide}{Special keywords}
\begin{itemize}
\item Result of method call \Blue{\bsl result}
\item Value in pre-state of method \Blue{\bsl old(\(E\))}
\item Ensure object is newly allocated \Blue{\bsl fresh(\(E\))}
\item All reachable objects \Blue{\bsl reach(\(E\))}
\item And many others
\end{itemize}
\end{slide}

\begin{slide}{Example}
\vspace*{-1em}
{\small{\begin{alltt}
\textbf{\Blue{/*@ 
  @ modifies decimal;
  @  ensures decimal == v * PRECISION;
  @  signals (DecimalException e)
  @          v < 0 && decimal == \bsl{}old(decimal);
  @*/}
public Decimal setValue(short v) 
               throws DecimalException \{
  if(v < 0) DecimalException.throwIt(
                   DecimalException.OVERFLOW);
  intPart = v; decPart = (short) 0;
  return this; \}}
\end{alltt}}}
\end{slide}

\begin{slide}{Class specifications}
\begin{description}
\item[\Blue{Model}:] specification-only variables, models set of
concrete variables
\item[\Blue{Ghost}:] abstract variable, with special assignment \Blue{\textttbf{set}}
\item[\Blue{Invariant}:] property of all publicly reachable states
of object 
\item[\Blue{Constraint}:] relates pre and post states of methods

\end{description}
\end{slide}

\begin{slide}{Example}
{\small \begin{alltt}
\textbf{
public static final short MAX_DECIMAL_NUMBER = 
                          (short) 32767;
public static final short PRECISION = 
                          (short) 1000;

\Blue{/*@ spec_public*/} private short intPart = 
                          (short) 0;
\Blue{/*@ spec_public*/} private short decPart = 
                          (short) 0;
}
\end{alltt}}
\end{slide}

\begin{slide}{Example - continued}
{\small \begin{alltt}
\textbf{\Blue{/*@ invariant 0 <= intPart && 
  @           intPart <= MAX_DECIMAL_NUMBER &&
  @           0 <= decPart && 
  @           decPart < PRECISION; 
  @
  @ model int decimal;
  @ represents decimal <- 
  @            intPart * PRECISION + decPart;
  @ depends decimal <- intPart, decPart; 
  @*/}
}
\end{alltt}}
\end{slide}



\begin{slide}{Tools for JML}
\begin{itemize}
\item Various tools use JML as specification language
\item Vary in precision and efficiency
\item Range of tools: \Blue{run-time verification} (JMLC/Jass) - \Blue{static
checking} (ESC/Java(2))- 
\Blue{verification} (Jack/Krakatoa/LOOP/Bogar)
\item Experiments show: balanced use of these tools increases
productivity of application developers   
\item Other approach: \\
 \Blue{Daikon} - detection of class invariants
\end{itemize}
\end{slide}



%\overlays{2}{
%\begin{slide}{Jack: a tool for engineers}
%\begin{itemize}
%\item Design goals:
%  \begin{itemize}
%     \item High correctness assurance
%     \item Accessible user interface 
%     \item Prover independence
%     \item High degree of automation
%  \end{itemize}
%\FromSlide{2}
%\item Consequences:
%  \begin{itemize}
%     \item Developed as plug-in IDE Eclipse
%     \item Connections with automatic provers (B prover, Simplify, HarVey, 
%           \ldots) 
%  \end{itemize}
%\end{itemize}
%\end{slide}
%}

\overlays{2}{
\begin{slide}{Limitations of JML}
\begin{itemize}
  \item Specifications restricted to a \Blue{single class}
  \item Specifications restricted to \Blue{functional behaviour}
  \item Not much support for refinement 
\end{itemize}
\FromSlide{2} In order to verify security properties, one needs to
overcome these limitations
\end{slide}
}

%\overlays{3}{
%\begin{slide}{Questions to be addressed}
%\begin{itemize}
%\item Relation between security notions and rules
%\onlySlide{1}{\item Guaranteeing rules are obeyed}\vspace*{-1.5em} 
%\FromSlide{2}\item \Red{Guaranteeing rules are obeyed}
%\FromSlide{3}\item Extension towards security automata: \emph{bridging} the gap
%between security notions and rules
%\end{itemize}
%\end{slide}
%}

\overlays{5}{
\begin{slide}{High-level security rules}
\begin{itemize}
  \item Atomicity
  \onlySlide{1}{
  \item Applet life cycle
  \item Exception handling
  \item Access control}
  \onlySlide{2}{\vspace*{-4.5em}\begin{itemize}
                     \item No nested transactions
                     \item No uncaught exception in transactions
                     \item Bounded retries authentication
                  \end{itemize}
  \item Applet life cycle
  \item Exception handling
  \item Access control}
  \fromSlide{3}{\vspace*{-8.5em}\item Applet life cycle}
  \onlySlide{3}{\begin{itemize}
                         \item Authenticated initialisation
                         \item Authenticated unblocking
                         \item Single personalisation
                \end{itemize}
  \item Exception handling
  \item Access control}
  \fromSlide{4}{\vspace*{-7em}\item Exception handling}
  \onlySlide{4}{\begin{itemize} 
                   \item Only ISOExceptions at top-level
                \end{itemize}
  \item Access control}
  \fromSlide{5}{\vspace*{-3em}
  \item Access control
          \begin{itemize}
             \item Only selectable applications shareable
          \end{itemize}
  }
\end{itemize}
\end{slide}
}

\begin{slide}{Architecture}
 \psfig{file=../Papers/isaac/architecture.eps,width=\textwidth}
\end{slide}

\begin{slide}{Assertion generation}
Two phases:
\begin{itemize}
\item \Blue{synthesising} core-annotations
\item \Blue{weaving} annotations throughout the application
\end{itemize}
\ \smallskip\\
\Blue{Synthesising}: for each property annotations have to be defined
\bigskip\\
\Blue{Weaving}: algorithm for pre- and postcondition generation
\end{slide}

\begin{slide}{Example core-annotations}
\Red{No nested transactions}
\begin{alltt}
\Blue{\textbf{/*@ static ghost int TRANSACT == 0; @*/}}
\end{alltt}
\ \smallskip\\
Method \textttbf{beginTransaction}
\begin{alltt}
\Blue{\textbf{/*@ requires TRANSACT == 0;
  @ modifies TRANSACT;
  @ ensures TRANSACT == 1; @*/}}
\textbf{public static native 
   void beginTransaction() 
        throws TransactionException;}
\end{alltt}
\ \smallskip\\
Similar annotations for \textttbf{commitTransaction},
\textttbf{abortTransaction} 
\end{slide}


\begin{slide}{Preconditions for methods}
\begin{alltt}
\textbf{public void m() \{
   ...
   \Blue{// will require TRANSACT == 0}
   JCSystem.beginTransaction();
   \Blue{// TRANSACT modified, 
   // ensures TRANSACT == 1}
   ...
   \Blue{// will require TRANSACT == 1}
   JSSystem.commitTransaction();
   \Blue{// TRANSACT modified, 
   // ensures TRANSACT == 0}
   ...
   \}}
\end{alltt}
\end{slide}


\begin{slide}{Preconditions for methods}
\vspace*{-1em}
\begin{alltt}
\textbf{\Red{/*@ requires \texttt{TRANSACT == 0} */}}
\textbf{public void m() \{
   ...
   \Blue{// will require TRANSACT == 0}
   JCSystem.beginTransaction();
   \Blue{// TRANSACT modified, 
   // ensures TRANSACT == 1}
   ...
   \Blue{// will require TRANSACT == 1}
   JSSystem.commitTransaction();
   \Blue{// TRANSACT modified, 
   // ensures TRANSACT == 0}
   ...
   \}}
\end{alltt}
\end{slide}

\begin{slide}{Some assumptions we make}
\begin{itemize}
  \item Only static and ghost variables of primitive type allowed in
annotations  
  \item Appropriate modelling of programs
  \item Existence of function {\large\textsf{\Red{mod}}}: set of static ghost
variables modified by statement 
\end{itemize}
\end{slide}

\begin{slide}{Algorithm for precondition generation}
\begin{itemize}
   \item \Blue{Method declaration}
\[\mathsf{\OliveGreen{pre}}(m)  =  \mathsf{\OliveGreen{pre}}(\mathsf{body}(m), \emptyset)\]
   \item \Blue{Composition}
\[\mathsf{\OliveGreen{pre}}(s_1 \mathtt{;} s_2, V)  =  \mathsf{\OliveGreen{pre}}(s_1, V) \cup 
                                          \mathsf{\OliveGreen{pre}}(s_2, V \cup
\mathsf{\Red{mod}}(s1))\]
   \item \Blue{Method call}
\[\mathsf{\OliveGreen{pre}}(\mathsf{\Blue{call}}(n),V)  =  
                \{ p \mid p \in \mathsf{\OliveGreen{pre}}(n) \wedge 
                          \mathsf{fv}(p) \cap V = \emptyset\}\]
\end{itemize}
\end{slide}

\begin{slide}{Algorithm for precondition generation - branching statements}
\begin{itemize}
   \item \Blue{Conditional}
\[
\mathsf{\OliveGreen{pre}}(\mathtt{if\:(} c \mathtt{)\:} s_1 \mathtt{\:else\:} s_2,
V)  = 
\begin{array}[t]{l}
   \mathsf{\OliveGreen{pre}}(c, V) \:\cup \\
   \mathsf{\OliveGreen{pre}}(s_1, V \cup \mathsf{\Red{mod}}(c)) \:\cup\\
   \mathsf{\OliveGreen{pre}}(s_2, V \cup \mathsf{\Red{mod}}(c))
\end{array}\]
\item \Blue{Try catch}
\[\mathsf{\OliveGreen{pre}}(\mathtt{try\:} s_1 \mathtt{\:catch\:(} E \mathtt{)\:} s_2, V)  =  \begin{array}[t]{l}
   \mathsf{\OliveGreen{pre}}(s_1, V) \:\cup \\
   \mathsf{\OliveGreen{pre}}(s_2, V \cup \mathsf{\Red{mod}}(s1))
  \end{array}\]
\end{itemize}
\end{slide}




\begin{slide}{Experiments: checking atomicity properties}

\Red{No uncaught exceptions in transactions}\smallskip\\

\begin{alltt}
\textbf{\Blue{/*@ exsures (Exception) TRANSACT == 0; @*/}
public static native void 
   commitTransaction() 
         throws TransactionException;}
\end{alltt}
%\ \medskip\\
%Annotation propagated to each statement block, ending with commit.
\end{slide}

\begin{slide}{Experiments: checking atomicity properties}
\Red{No pin-verification within transaction}\smallskip\\

\begin{alltt}
\textbf{\Blue{/*@ requires TRANSACT == 0; @*/}
public boolean check(byte[] pin, 
                     short offset, 
                     byte length);}
\end{alltt}
\end{slide}

\begin{slide}{Results}
\begin{itemize}
\item Tested on several realistic smart card applications
\item One core-annotation can give rise to many annotations in
different classes (26 annotations, spread over 5 different classes)
\item Several violations found: uncaught exceptions possible within
transactions 
\end{itemize}
\end{slide}

\begin{slide}{Uncaught exception within transaction}
\begin{alltt}
\Blue{/*@ exsures (Exception) TRANSACT == 0; @*/} 
\textbf{void appExchangeCurrency(...) \{
   ...
   JCSystem.beginTransaction();	
   try \{balance.setValue(decimal2);
            ...
   \} catch (DecimalException e) \{
       ISOException.throwIt(
            PurseApplet.OVERFLOW);
   \}
   JCSystem.commitTransaction();
   \}
   ...
\}}
\end{alltt}
\end{slide}


\begin{slide}{Towards more generality:\\ Security automata}
\begin{itemize}
\item \Blue{Security automaton}: monitors program behaviour,
blocking/error upon unwanted behaviour 
\item Use security automata to express security properties
\item Automatic generation of core-annotations
\item Propagation of annotations
\item Use any JML tool to check whether program respects the property
\end{itemize}
\end{slide}

\overlays{2}{
\begin{slide}{Correctness}
\begin{center}
\Blue{If program statically satisfies annotations \\
      then it respects the security property}
\end{center}
\ \smallskip\\
\FromSlide{2}
\begin{itemize}
\item First soundness proof for simple while-language on the way
\item In some cases also completeness?
\end{itemize}
\end{slide}
}

\overlays{3}{
\begin{slide}{If program satisfies annotations \\
      then it respects the security property}
Approach:
\begin{itemize}
\item If fully annotated program verified, run-time monitoring  (with
\texttt{jmlc}) will not block  \\
\OliveGreen{\(P \models_{ST} \mathsf{prop}(P, \mathsf{core}(\mathcal{T})) \Rightarrow
P \models_{RV} \mathsf{prop}(P, \mathsf{core}(\mathcal{T}))\)}
\FromSlide{2}\item If fully annotated program run-time okay,
core-annotated program run-time okay\\
\OliveGreen{\(P \models_{RV} \mathsf{prop}(P, \mathsf{core}(\mathcal{T})) \Rightarrow
P \models_{RV} \mathsf{core}(\mathcal{T})\)}
\FromSlide{3}\item If core-annotated program run-time okay,security
automaton  will not block\\
\OliveGreen{\(P \models_{RV} \mathsf{core}(\mathcal{T}) \Rightarrow \mathcal{OK}(P \times
\mathcal{T})\)}
\end{itemize}
\end{slide}
}

\begin{slide}{Completeness?}
\begin{itemize}
\item 
\OliveGreen{\(P \models_{ST} \mathsf{prop}(P, \mathsf{core}(\mathcal{T})) \Red{\Leftrightarrow}
P \models_{RV} \mathsf{prop}(P, \mathsf{core}(\mathcal{T}))\)}
\item
\OliveGreen{\(P \models_{RV} \mathsf{core}(\mathcal{T}) \Red{\Leftrightarrow} \mathcal{OK}(P \times
\mathcal{T})\)}
\item But what about propagation:
\Red{\(P \models_{RV} \mathsf{prop}(P, \mathsf{core}(\mathcal{T})) \Leftarrow
P \models_{RV} \mathsf{core}(\mathcal{T})\)} ??
\end{itemize}
\end{slide}

\begin{slide}{Example: propagation does not preserve run-time verification}

\begin{alltt}
\textbf{\phantom{\Red{/*@ requires TRANSACT == 0; */}}
void m() \{
  if (false) \{ \Blue{// requires TRANSACT == 0;}
               beginTransaction();\}
\}

void n() \{
  beginTransaction();
  \Blue{// ensures TRANSACT == 1;}
  m();
\}}
\end{alltt}
\ \smallskip\\
Run-time verification okay
\end{slide}

\begin{slide}{Example: propagation does not preserve run-time verification}

\begin{alltt}
\textbf{\Red{/*@ requires TRANSACT == 0; */}
void m() \{
  if (false) \{ \Blue{// requires TRANSACT == 0;}
               beginTransaction();\}
\}

void n() \{
  beginTransaction();
  \Blue{// ensures TRANSACT == 1;}
  m();
\}}
\end{alltt}
\ \smallskip\\
Run-time verification signals error
\end{slide}

\begin{slide}{Conditional completeness?}
Run-time verification preserved by propagation, if:
\begin{itemize}
\item Program does not contain branching statements
\item Branching statements do not propagate any annotations
\item Each branch of statement propagates same annotations ??
\end{itemize}
\end{slide}

\begin{slide}{Future issues}
\begin{itemize}
\item Other formalisms to express security properties (with
translation into JML)?
\item Translations into other formalisms
\item Do we need liveness?
\end{itemize}
\end{slide}

\begin{slide}{Theoretical foundations: abstract weakest precondition}
Abstract wp-calculus \OliveGreen{\(\mathsf{wp}^\#\)}: considers only static 
ghost variables\\
Example rules:
\[
\begin{array}{l}
\mathsf{\OliveGreen{wp}}^{\OliveGreen{\#}}(\mathtt{if
(}c\mathtt{)}s_1\mathtt{\:else\:}s_2,Q) =\\
\qquad
\mathsf{\OliveGreen{wp}}^{\OliveGreen{\#}}(c, \mathsf{\OliveGreen{wp}}^{\OliveGreen{\#}}(s_1, Q)) \wedge
\mathsf{\OliveGreen{wp}}^{\OliveGreen{\#}}(c,
\mathsf{\OliveGreen{wp}}^{\OliveGreen{\#}}(s_2, Q))
\end{array}
\]

\[
\mathsf{\OliveGreen{wp}}^{\OliveGreen{\#}}(\mathsf{\Blue{call}}(m), Q) =
  \mathsf{\Blue{requires}}(m) \wedge 
  \forall \mathsf{\Red{mod}}(m). (\mathsf{\Blue{ensures}}(m) \Rightarrow Q)
\]
\end{slide}

\begin{slide}{Results}
\begin{itemize}
\item Any proof in abstract wp-calculus, is proof in standard
wp-calculus
\[
\forall P, Q\colon\mathsf{Pred}, s\colon\mathsf{Stmt}. 
(P \Rightarrow \mathsf{\OliveGreen{wp}}^{\OliveGreen{\#}}(s, Q)) \Rightarrow
               (P \Rightarrow \mathsf{\OliveGreen{wp}}(s, Q))
\]
\item Precondition generation computes the \emph{free} part of the
abstract weakest precondition
\[
\exists F\colon\mathsf{Pred}.  
             \mathsf{\OliveGreen{wp}}^{\OliveGreen{\#}}(s, \lambda x. \mathsf{true}) = 
             (\mathsf{\OliveGreen{pre}}(s, \emptyset) \wedge \forall
              \mathsf{\Red{mod}}(s). F) 
\]
\end{itemize}
\end{slide}

\end{document}