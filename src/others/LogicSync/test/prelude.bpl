// This Boogie prelude is taken from the Boogie benchmark

type real;
type elements;
type struct;
type exposeVersionType;
var $Heap<x> : [ref, <x>name]x where IsHeap($Heap); // x in [int, bool, ref]
function IsHeap(h<x> : [ref, <x>name]x) returns ($$unnamed~a : bool);
const $allocated : <bool>name;
const $elements : <elements>name;
const $inv : <name>name;
const $localinv : <name>name;
const $exposeVersion : <exposeVersionType>name;
axiom (DeclType($exposeVersion) == System.Object);
const $sharingMode : name;
const $SharingMode_Unshared : name;
const $SharingMode_LockProtected : name;
const $ownerRef : <ref>name;
const $ownerFrame : <name>name;
const $PeerGroupPlaceholder : name;
function ClassRepr(class : name) returns ($$unnamed~b : ref);
axiom (forall c0 : name, c1 : name :: {ClassRepr(c0), ClassRepr(c1)} ((c0 != c1) ==> (ClassRepr(c0) != ClassRepr(c1))));
axiom (forall T : name :: !($typeof(ClassRepr(T)) <: System.Object));
axiom (forall T : name :: (ClassRepr(T) != null));
axiom (forall T : name, h<x> : [ref, <x>name]x :: {h[ClassRepr(T), $ownerFrame]} (IsHeap(h) ==> (h<`name>[ClassRepr(T), $ownerFrame] == $PeerGroupPlaceholder)));
function IsDirectlyModifiableField(f : name) returns ($$unnamed~c : bool);
axiom !IsDirectlyModifiableField($allocated);
axiom IsDirectlyModifiableField($elements);
axiom !IsDirectlyModifiableField($inv);
axiom !IsDirectlyModifiableField($localinv);
axiom !IsDirectlyModifiableField($ownerRef);
axiom !IsDirectlyModifiableField($ownerFrame);
axiom !IsDirectlyModifiableField($exposeVersion);
function IsStaticField(f : name) returns ($$unnamed~d : bool);
axiom !IsStaticField($allocated);
axiom !IsStaticField($elements);
axiom !IsStaticField($inv);
axiom !IsStaticField($localinv);
axiom !IsStaticField($exposeVersion);
function ValueArrayGet($$unnamed~f : elements, $$unnamed~e : int) returns ($$unnamed~g : any);
function ValueArraySet($$unnamed~j : elements, $$unnamed~i : int, $$unnamed~h : any) returns ($$unnamed~k : elements);
function RefArrayGet($$unnamed~m : elements, $$unnamed~l : int) returns ($$unnamed~n : ref);
function RefArraySet($$unnamed~q : elements, $$unnamed~p : int, $$unnamed~o : ref) returns ($$unnamed~r : elements);
axiom (forall A : elements, i : int, x : any :: (ValueArrayGet(ValueArraySet(A, i, x), i) == x));
axiom (forall A : elements, i : int, j : int, x : any :: ((i != j) ==> (ValueArrayGet(ValueArraySet(A, i, x), j) == ValueArrayGet(A, j))));
axiom (forall A : elements, i : int, x : ref :: (RefArrayGet(RefArraySet(A, i, x), i) == x));
axiom (forall A : elements, i : int, j : int, x : ref :: ((i != j) ==> (RefArrayGet(RefArraySet(A, i, x), j) == RefArrayGet(A, j))));
function ArrayIndex(arr : ref, dim : int, indexAtDim : int, remainingIndexContribution : int) returns ($$unnamed~s : int);
axiom (forall a : ref, d : int, x : int, y : int, x' : int, y' : int :: {ArrayIndex(a, d, x, y), ArrayIndex(a, d, x', y')} ((ArrayIndex(a, d, x, y) == ArrayIndex(a, d, x', y')) ==> ((x == x') && (y == y'))));
axiom (forall a : ref, T : name, i : int, r : int, heap<x> : [ref, <x>name]x :: {($typeof(a) <: RefArray(T, r)), RefArrayGet(heap[a, $elements], i)} ((IsHeap(heap) && ($typeof(a) <: RefArray(T, r))) ==> $Is(RefArrayGet(heap<`elements>[a, $elements], i), T)));
axiom (forall a : ref, T : name, i : int, r : int, heap<x> : [ref, <x>name]x :: {($typeof(a) <: NonNullRefArray(T, r)), RefArrayGet(heap[a, $elements], i)} ((IsHeap(heap) && ($typeof(a) <: NonNullRefArray(T, r))) ==> $IsNotNull(RefArrayGet(heap<`elements>[a, $elements], i), T)));
function $Rank($$unnamed~t : ref) returns ($$unnamed~u : int);
axiom (forall a : ref :: (1 <= $Rank(a)));
axiom (forall a : ref, T : name, r : int :: {($typeof(a) <: RefArray(T, r))} (((a != null) && ($typeof(a) <: RefArray(T, r))) ==> ($Rank(a) == r)));
axiom (forall a : ref, T : name, r : int :: {($typeof(a) <: NonNullRefArray(T, r))} (((a != null) && ($typeof(a) <: NonNullRefArray(T, r))) ==> ($Rank(a) == r)));
axiom (forall a : ref, T : name, r : int :: {($typeof(a) <: ValueArray(T, r))} (((a != null) && ($typeof(a) <: ValueArray(T, r))) ==> ($Rank(a) == r)));
function $Length($$unnamed~v : ref) returns ($$unnamed~w : int);
axiom (forall a : ref :: {$Length(a)} (0 <= $Length(a)));
function $DimLength($$unnamed~y : ref, $$unnamed~x : int) returns ($$unnamed~z : int);
axiom (forall a : ref, i : int :: (0 <= $DimLength(a, i)));
axiom (forall a : ref :: {$DimLength(a, 0)} (($Rank(a) == 1) ==> ($DimLength(a, 0) == $Length(a))));
function $LBound($$unnamed~ab : ref, $$unnamed~aa : int) returns ($$unnamed~ac : int);
function $UBound($$unnamed~ae : ref, $$unnamed~ad : int) returns ($$unnamed~af : int);
axiom (forall a : ref, i : int :: {$LBound(a, i)} ($LBound(a, i) == 0));
axiom (forall a : ref, i : int :: {$UBound(a, i)} ($UBound(a, i) == ($DimLength(a, i) - 1)));
const $ArrayCategoryValue : name;
const $ArrayCategoryRef : name;
const $ArrayCategoryNonNullRef : name;
function $ArrayCategory(arrayType : name) returns (arrayCategory : name);
axiom (forall T : name, ET : name, r : int :: {(T <: ValueArray(ET, r))} ((T <: ValueArray(ET, r)) ==> ($ArrayCategory(T) == $ArrayCategoryValue)));
axiom (forall T : name, ET : name, r : int :: {(T <: RefArray(ET, r))} ((T <: RefArray(ET, r)) ==> ($ArrayCategory(T) == $ArrayCategoryRef)));
axiom (forall T : name, ET : name, r : int :: {(T <: NonNullRefArray(ET, r))} ((T <: NonNullRefArray(ET, r)) ==> ($ArrayCategory(T) == $ArrayCategoryNonNullRef)));
const System.Array : name;
axiom (System.Array <: System.Object);
function $ElementType($$unnamed~ag : name) returns ($$unnamed~ah : name);
function ValueArray(elementType : name, rank : int) returns ($$unnamed~ai : name);
axiom (forall T : name, r : int :: {ValueArray(T, r)} (ValueArray(T, r) <: System.Array));
function RefArray(elementType : name, rank : int) returns ($$unnamed~aj : name);
axiom (forall T : name, r : int :: {RefArray(T, r)} (RefArray(T, r) <: System.Array));
function NonNullRefArray(elementType : name, rank : int) returns ($$unnamed~ak : name);
axiom (forall T : name, r : int :: {NonNullRefArray(T, r)} (NonNullRefArray(T, r) <: System.Array));
axiom (forall T : name, U : name, r : int :: ((U <: T) ==> (RefArray(U, r) <: RefArray(T, r))));
axiom (forall T : name, U : name, r : int :: ((U <: T) ==> (NonNullRefArray(U, r) <: NonNullRefArray(T, r))));
axiom (forall A : name, r : int :: ($ElementType(ValueArray(A, r)) == A));
axiom (forall A : name, r : int :: ($ElementType(RefArray(A, r)) == A));
axiom (forall A : name, r : int :: ($ElementType(NonNullRefArray(A, r)) == A));
axiom (forall A : name, r : int, T : name :: {(T <: RefArray(A, r))} ((T <: RefArray(A, r)) ==> ((T == RefArray($ElementType(T), r)) && ($ElementType(T) <: A))));
axiom (forall A : name, r : int, T : name :: {(T <: NonNullRefArray(A, r))} ((T <: NonNullRefArray(A, r)) ==> ((T == NonNullRefArray($ElementType(T), r)) && ($ElementType(T) <: A))));
axiom (forall A : name, r : int, T : name :: {(T <: ValueArray(A, r))} ((T <: ValueArray(A, r)) ==> (T == ValueArray(A, r))));
axiom (forall A : name, r : int, T : name :: ((RefArray(A, r) <: T) ==> ((System.Array <: T) || ((T == RefArray($ElementType(T), r)) && (A <: $ElementType(T))))));
axiom (forall A : name, r : int, T : name :: ((NonNullRefArray(A, r) <: T) ==> ((System.Array <: T) || ((T == NonNullRefArray($ElementType(T), r)) && (A <: $ElementType(T))))));
axiom (forall A : name, r : int, T : name :: ((ValueArray(A, r) <: T) ==> ((System.Array <: T) || (T == ValueArray(A, r)))));
function $ArrayPtr(elementType : name) returns ($$unnamed~al : name);
function $StructGet($$unnamed~an : struct, $$unnamed~am : name) returns ($$unnamed~ao : any);
function $StructSet($$unnamed~ar : struct, $$unnamed~aq : name, $$unnamed~ap : any) returns ($$unnamed~as : struct);
axiom (forall s : struct, f : name, x : any :: ($StructGet($StructSet(s, f, x), f) == x));
axiom (forall s : struct, f : name, f' : name, x : any :: ((f != f') ==> ($StructGet($StructSet(s, f, x), f') == $StructGet(s, f'))));
function ZeroInit(s : struct, typ : name) returns ($$unnamed~at : bool);
function $typeof($$unnamed~au : ref) returns ($$unnamed~av : name);
function $BaseClass(sub : name) returns (base : name);
function AsDirectSubClass(sub : name, base : name) returns (sub' : name);
function OneClassDown(sub : name, base : name) returns (directSub : name);
axiom (forall A : name, B : name, C : name :: {(C <: AsDirectSubClass(B, A))} ((C <: AsDirectSubClass(B, A)) ==> (OneClassDown(C, A) == B)));
function $IsValueType($$unnamed~aw : name) returns ($$unnamed~ax : bool);
axiom (forall T : name :: ($IsValueType(T) ==> ((forall U : name :: ((T <: U) ==> (T == U))) && (forall U : name :: ((U <: T) ==> (T == U))))));
const System.Object : name;
function $IsTokenForType($$unnamed~az : struct, $$unnamed~ay : name) returns ($$unnamed~ba : bool);
function TypeObject($$unnamed~bb : name) returns ($$unnamed~bc : ref);
const System.Type : name;
axiom (System.Type <: System.Object);
axiom (forall T : name :: {TypeObject(T)} $IsNotNull(TypeObject(T), System.Type));
function TypeName($$unnamed~bd : ref) returns ($$unnamed~be : name);
axiom (forall T : name :: {TypeObject(T)} (TypeName(TypeObject(T)) == T));
function $Is($$unnamed~bg : ref, $$unnamed~bf : name) returns ($$unnamed~bh : bool);
axiom (forall o : ref, T : name :: {$Is(o, T)} ($Is(o, T) <==> ((o == null) || ($typeof(o) <: T))));
function $IsNotNull($$unnamed~bj : ref, $$unnamed~bi : name) returns ($$unnamed~bk : bool);
axiom (forall o : ref, T : name :: {$IsNotNull(o, T)} ($IsNotNull(o, T) <==> ((o != null) && $Is(o, T))));
function $As($$unnamed~bm : ref, $$unnamed~bl : name) returns ($$unnamed~bn : ref);
axiom (forall o : ref, T : name :: ($Is(o, T) ==> ($As(o, T) == o)));
axiom (forall o : ref, T : name :: (!$Is(o, T) ==> ($As(o, T) == null)));
axiom (forall h<x> : [ref, <x>name]x, o : ref :: {($typeof(o) <: System.Array), h[o, $inv]} (((IsHeap(h) && (o != null)) && ($typeof(o) <: System.Array)) ==> ((h<`name>[o, $inv] == $typeof(o)) && (h<`name>[o, $localinv] == $typeof(o)))));
function IsAllocated(h<x> : [ref, <x>name]x, o : any) returns ($$unnamed~bo : bool);
axiom<$$tv~a> (forall h<x> : [ref, <x>name]x, o : ref, f : name :: {IsAllocated(h, h[o, f])} ((IsHeap(h) && h<`bool>[o, $allocated]) ==> IsAllocated(h, h<`$$tv~a>[o, f])));
axiom (forall h<x> : [ref, <x>name]x, o : ref, f : <ref>name :: {h[h[o, f], $allocated]} ((IsHeap(h) && h<`bool>[o, $allocated]) ==> h<`bool>[h<`ref>[o, f], $allocated]));
axiom (forall h<x> : [ref, <x>name]x, s : struct, f : name :: {IsAllocated(h, $StructGet(s, f))} (IsAllocated(h, s) ==> IsAllocated(h, $StructGet(s, f))));
axiom (forall h<x> : [ref, <x>name]x, e : elements, i : int :: {IsAllocated(h, RefArrayGet(e, i))} (IsAllocated(h, e) ==> IsAllocated(h, RefArrayGet(e, i))));
axiom (forall h<x> : [ref, <x>name]x, e : elements, i : int :: {IsAllocated(h, ValueArrayGet(e, i))} (IsAllocated(h, e) ==> IsAllocated(h, ValueArrayGet(e, i))));
axiom (forall h<x> : [ref, <x>name]x, o : ref :: {h[o, $allocated]} (IsAllocated(h, o) ==> h<`bool>[o, $allocated]));
axiom (forall h<x> : [ref, <x>name]x, c : name :: {h[ClassRepr(c), $allocated]} (IsHeap(h) ==> h<`bool>[ClassRepr(c), $allocated]));
const $BeingConstructed : ref;
const $NonNullFieldsAreInitialized : <bool>name;
function DeclType(field : name) returns (class : name);
function AsNonNullRefField(field : <ref>name, T : name) returns (f : <ref>name);
function AsRefField(field : <ref>name, T : name) returns (f : <ref>name);
function AsRangeField(field : <int>name, T : name) returns (f : <int>name);
axiom (forall f : <ref>name, T : name :: {AsNonNullRefField(f, T)} ((AsNonNullRefField(f, T) == f) ==> (AsRefField(f, T) == f)));
axiom (forall h<x> : [ref, <x>name]x, o : ref, f : <ref>name, T : name :: {h[o, AsRefField(f, T)]} (IsHeap(h) ==> $Is(h<`ref>[o, AsRefField(f, T)], T)));
axiom (forall h<x> : [ref, <x>name]x, o : ref, f : <ref>name, T : name :: {h[o, AsNonNullRefField(f, T)]} (((IsHeap(h) && (o != null)) && ((o != $BeingConstructed) || (h<`bool>[$BeingConstructed, $NonNullFieldsAreInitialized] == true))) ==> (h<`ref>[o, AsNonNullRefField(f, T)] != null)));
axiom (forall h<x> : [ref, <x>name]x, o : ref, f : <int>name, T : name :: {h[o, AsRangeField(f, T)]} (IsHeap(h) ==> InRange(h<`int>[o, AsRangeField(f, T)], T)));
function $IsMemberlessType($$unnamed~bp : name) returns ($$unnamed~bq : bool);
axiom (forall o : ref :: {$IsMemberlessType($typeof(o))} !$IsMemberlessType($typeof(o)));
function $IsImmutable(T : name) returns ($$unnamed~br : bool);
axiom !$IsImmutable(System.Object);
function $AsImmutable(T : name) returns (theType : name);
function $AsMutable(T : name) returns (theType : name);
axiom (forall T : name, U : name :: {(U <: $AsImmutable(T))} ((U <: $AsImmutable(T)) ==> ($IsImmutable(U) && ($AsImmutable(U) == U))));
axiom (forall T : name, U : name :: {(U <: $AsMutable(T))} ((U <: $AsMutable(T)) ==> (!$IsImmutable(U) && ($AsMutable(U) == U))));
function AsOwner(string : ref, owner : ref) returns (theString : ref);
axiom (forall o : ref, T : name :: {($typeof(o) <: $AsImmutable(T))} ((((o != null) && (o != $BeingConstructed)) && ($typeof(o) <: $AsImmutable(T))) ==> (forall h<x> : [ref, <x>name]x :: {IsHeap(h)} (IsHeap(h) ==> (((((h<`name>[o, $inv] == $typeof(o)) && (h<`name>[o, $localinv] == $typeof(o))) && (h<`name>[o, $ownerFrame] == $PeerGroupPlaceholder)) && (AsOwner(o, h<`ref>[o, $ownerRef]) == o)) && (forall t : ref :: {AsOwner(o, h[t, $ownerRef])} ((AsOwner(o, h<`ref>[t, $ownerRef]) == o) ==> ((t == o) || (h<`name>[t, $ownerFrame] != $PeerGroupPlaceholder)))))))));
const System.String : name;
function $StringLength($$unnamed~bs : ref) returns ($$unnamed~bt : int);
axiom (forall s : ref :: {$StringLength(s)} (0 <= $StringLength(s)));
function AsRepField(f : <ref>name, declaringType : name) returns (theField : <ref>name);
axiom (forall h<x> : [ref, <x>name]x, o : ref, f : <ref>name, T : name :: {h[o, AsRepField(f, T)]} ((IsHeap(h) && (h<`ref>[o, AsRepField(f, T)] != null)) ==> ((h<`ref>[h<`ref>[o, AsRepField(f, T)], $ownerRef] == o) && (h<`name>[h<`ref>[o, AsRepField(f, T)], $ownerFrame] == T))));
function AsPeerField(f : <ref>name) returns (theField : <ref>name);
axiom (forall h<x> : [ref, <x>name]x, o : ref, f : <ref>name :: {h[o, AsPeerField(f)]} ((IsHeap(h) && (h<`ref>[o, AsPeerField(f)] != null)) ==> ((h<`ref>[h<`ref>[o, AsPeerField(f)], $ownerRef] == h<`ref>[o, $ownerRef]) && (h<`name>[h<`ref>[o, AsPeerField(f)], $ownerFrame] == h<`name>[o, $ownerFrame]))));
axiom (forall h<x> : [ref, <x>name]x, o : ref :: {(h[h[o, $ownerRef], $inv] <: h[o, $ownerFrame])} ((((IsHeap(h) && (h<`name>[o, $ownerFrame] != $PeerGroupPlaceholder)) && (h<`name>[h<`ref>[o, $ownerRef], $inv] <: h<`name>[o, $ownerFrame])) && (h<`name>[h<`ref>[o, $ownerRef], $localinv] != $BaseClass(h<`name>[o, $ownerFrame]))) ==> ((h<`name>[o, $inv] == $typeof(o)) && (h<`name>[o, $localinv] == $typeof(o)))));
procedure $SetOwner(o : ref, ow : ref, fr : name);
  modifies $Heap;
  ensures <$$tv~d>(forall p : ref, F : name :: {$Heap[p, F]} (((((F != $ownerRef) && (F != $ownerFrame)) || old(($Heap<`ref>[p, $ownerRef] != $Heap<`ref>[o, $ownerRef]))) || old(($Heap<`name>[p, $ownerFrame] != $Heap<`name>[o, $ownerFrame]))) ==> (old($Heap<`$$tv~d>[p, F]) == $Heap<`$$tv~d>[p, F])));
  ensures (forall p : ref :: {$Heap[p, $ownerRef]} {$Heap[p, $ownerFrame]} ((old(($Heap<`ref>[p, $ownerRef] == $Heap<`ref>[o, $ownerRef])) && old(($Heap<`name>[p, $ownerFrame] == $Heap<`name>[o, $ownerFrame]))) ==> (($Heap<`ref>[p, $ownerRef] == ow) && ($Heap<`name>[p, $ownerFrame] == fr))));
  

procedure $UpdateOwnersForRep(o : ref, T : name, e : ref);
  modifies $Heap;
  ensures <$$tv~g>(forall p : ref, F : name :: {$Heap[p, F]} (((((F != $ownerRef) && (F != $ownerFrame)) || old(($Heap<`ref>[p, $ownerRef] != $Heap<`ref>[e, $ownerRef]))) || old(($Heap<`name>[p, $ownerFrame] != $Heap<`name>[e, $ownerFrame]))) ==> (old($Heap<`$$tv~g>[p, F]) == $Heap<`$$tv~g>[p, F])));
  ensures ((e == null) ==> ($Heap == old($Heap)));
  ensures ((e != null) ==> (forall p : ref :: {$Heap[p, $ownerRef]} {$Heap[p, $ownerFrame]} ((old(($Heap<`ref>[p, $ownerRef] == $Heap<`ref>[e, $ownerRef])) && old(($Heap<`name>[p, $ownerFrame] == $Heap<`name>[e, $ownerFrame]))) ==> (($Heap<`ref>[p, $ownerRef] == o) && ($Heap<`name>[p, $ownerFrame] == T)))));
  

procedure $UpdateOwnersForPeer(c : ref, d : ref);
  modifies $Heap;
  ensures <$$tv~h>(forall p : ref, F : name :: {$Heap[p, F]} ((((F != $ownerRef) && (F != $ownerFrame)) || old(((($Heap<`ref>[p, $ownerRef] != $Heap<`ref>[c, $ownerRef]) || ($Heap<`name>[p, $ownerFrame] != $Heap<`name>[c, $ownerFrame])) && (($Heap<`ref>[p, $ownerRef] != $Heap<`ref>[d, $ownerRef]) || ($Heap<`name>[p, $ownerFrame] != $Heap<`name>[d, $ownerFrame]))))) ==> (old($Heap<`$$tv~h>[p, F]) == $Heap<`$$tv~h>[p, F])));
  ensures ((d == null) ==> ($Heap == old($Heap)));
  ensures ((d != null) ==> (forall p : ref :: {$Heap[p, $ownerRef]} {$Heap[p, $ownerFrame]} (((old(($Heap<`ref>[p, $ownerRef] == $Heap<`ref>[c, $ownerRef])) && old(($Heap<`name>[p, $ownerFrame] == $Heap<`name>[c, $ownerFrame]))) || (old(($Heap<`ref>[p, $ownerRef] == $Heap<`ref>[d, $ownerRef])) && old(($Heap<`name>[p, $ownerFrame] == $Heap<`name>[d, $ownerFrame])))) ==> ((((old($Heap<`name>)[d, $ownerFrame] == $PeerGroupPlaceholder) && ($Heap<`ref>[p, $ownerRef] == old($Heap<`ref>)[c, $ownerRef])) && ($Heap<`name>[p, $ownerFrame] == old($Heap<`name>)[c, $ownerFrame])) || (((old($Heap<`name>)[d, $ownerFrame] != $PeerGroupPlaceholder) && ($Heap<`ref>[p, $ownerRef] == old($Heap<`ref>)[d, $ownerRef])) && ($Heap<`name>[p, $ownerFrame] == old($Heap<`name>)[d, $ownerFrame]))))));
  

const $FirstConsistentOwner : <ref>name;
function $AsPureObject($$unnamed~bu : ref) returns ($$unnamed~bv : ref);
function ##FieldDependsOnFCO(o : ref, f : name, ev : exposeVersionType) returns (value : any);
axiom (forall o : ref, f : name, h<x> : [ref, <x>name]x :: {h[$AsPureObject(o), f]} ((((((IsHeap(h) && (o != null)) && (h<`bool>[o, $allocated] == true)) && (h<`name>[o, $ownerFrame] != $PeerGroupPlaceholder)) && (h<`name>[h<`ref>[o, $ownerRef], $inv] <: h<`name>[o, $ownerFrame])) && (h<`name>[h<`ref>[o, $ownerRef], $localinv] != $BaseClass(h<`name>[o, $ownerFrame]))) ==> (h<`any>[o, f] == ##FieldDependsOnFCO(o, f, h<`exposeVersionType>[h<`ref>[o, $FirstConsistentOwner], $exposeVersion]))));
axiom (forall o : ref, h<x> : [ref, <x>name]x :: {h[o, $FirstConsistentOwner]} ((((((IsHeap(h) && (o != null)) && (h<`bool>[o, $allocated] == true)) && (h<`name>[o, $ownerFrame] != $PeerGroupPlaceholder)) && (h<`name>[h<`ref>[o, $ownerRef], $inv] <: h<`name>[o, $ownerFrame])) && (h<`name>[h<`ref>[o, $ownerRef], $localinv] != $BaseClass(h<`name>[o, $ownerFrame]))) ==> (((h<`ref>[o, $FirstConsistentOwner] != null) && (h<`bool>[h<`ref>[o, $FirstConsistentOwner], $allocated] == true)) && (((h<`name>[h<`ref>[o, $FirstConsistentOwner], $ownerFrame] == $PeerGroupPlaceholder) || !(h<`name>[h<`ref>[h<`ref>[o, $FirstConsistentOwner], $ownerRef], $inv] <: h<`name>[h<`ref>[o, $FirstConsistentOwner], $ownerFrame])) || (h<`name>[h<`ref>[h<`ref>[o, $FirstConsistentOwner], $ownerRef], $localinv] == $BaseClass(h<`name>[h<`ref>[o, $FirstConsistentOwner], $ownerFrame]))))));
function Box($$unnamed~bx : any, $$unnamed~bw : ref) returns ($$unnamed~by : ref);
function Unbox($$unnamed~bz : ref) returns ($$unnamed~ca : any);
axiom (forall x : any, p : ref :: {Unbox(Box(x, p))} (Unbox(Box(x, p)) == x));
function UnboxedType($$unnamed~cb : ref) returns ($$unnamed~cc : name);
axiom (forall p : ref :: {$IsValueType(UnboxedType(p))} ($IsValueType(UnboxedType(p)) ==> (forall heap<x> : [ref, <x>name]x, x : any :: {heap[Box(x, p), $inv]} (IsHeap(heap) ==> ((heap<`name>[Box(x, p), $inv] == $typeof(Box(x, p))) && (heap<`name>[Box(x, p), $localinv] == $typeof(Box(x, p))))))));
axiom (forall x : any, p : ref :: {(UnboxedType(Box(x, p)) <: System.Object)} (((UnboxedType(Box(x, p)) <: System.Object) && (Box(x, p) == p)) ==> (x == p)));
function BoxTester(p : ref, typ : name) returns ($$unnamed~cd : ref);
axiom (forall p : ref, typ : name :: {BoxTester(p, typ)} ((UnboxedType(p) == typ) <==> (BoxTester(p, typ) != null)));
const System.SByte : name;
axiom $IsValueType(System.SByte);
const System.Byte : name;
axiom $IsValueType(System.Byte);
const System.Int16 : name;
axiom $IsValueType(System.Int16);
const System.UInt16 : name;
axiom $IsValueType(System.UInt16);
const System.Int32 : name;
axiom $IsValueType(System.Int32);
const System.UInt32 : name;
axiom $IsValueType(System.UInt32);
const System.Int64 : name;
axiom $IsValueType(System.Int64);
const System.UInt64 : name;
axiom $IsValueType(System.UInt64);
const System.Char : name;
axiom $IsValueType(System.Char);
const int#m2147483648 : int;
const int#2147483647 : int;
const int#4294967295 : int;
const int#m9223372036854775808 : int;
const int#9223372036854775807 : int;
const int#18446744073709551615 : int;
axiom (int#m9223372036854775808 < int#m2147483648);
axiom (int#m2147483648 < (0 - 100000));
axiom (100000 < int#2147483647);
axiom (int#2147483647 < int#4294967295);
axiom (int#4294967295 < int#9223372036854775807);
axiom (int#9223372036854775807 < int#18446744073709551615);
function InRange(i : int, T : name) returns ($$unnamed~ce : bool);
axiom (forall i : int :: (InRange(i, System.SByte) <==> (((0 - 128) <= i) && (i < 128))));
axiom (forall i : int :: (InRange(i, System.Byte) <==> ((0 <= i) && (i < 256))));
axiom (forall i : int :: (InRange(i, System.Int16) <==> (((0 - 32768) <= i) && (i < 32768))));
axiom (forall i : int :: (InRange(i, System.UInt16) <==> ((0 <= i) && (i < 65536))));
axiom (forall i : int :: (InRange(i, System.Int32) <==> ((int#m2147483648 <= i) && (i <= int#2147483647))));
axiom (forall i : int :: (InRange(i, System.UInt32) <==> ((0 <= i) && (i <= int#4294967295))));
axiom (forall i : int :: (InRange(i, System.Int64) <==> ((int#m9223372036854775808 <= i) && (i <= int#9223372036854775807))));
axiom (forall i : int :: (InRange(i, System.UInt64) <==> ((0 <= i) && (i <= int#18446744073709551615))));
axiom (forall i : int :: (InRange(i, System.Char) <==> ((0 <= i) && (i < 65536))));
function $IntToInt(val : int, fromType : name, toType : name) returns ($$unnamed~cf : int);
function $IntToReal($$unnamed~cg : int, fromType : name, toType : name) returns ($$unnamed~ch : real);
function $RealToInt($$unnamed~ci : real, fromType : name, toType : name) returns ($$unnamed~cj : int);
function $RealToReal(val : real, fromType : name, toType : name) returns ($$unnamed~ck : real);
function $SizeIs($$unnamed~cm : name, $$unnamed~cl : int) returns ($$unnamed~cn : bool);
function $IfThenElse($$unnamed~cq : bool, $$unnamed~cp : any, $$unnamed~co : any) returns ($$unnamed~cr : any);
axiom (forall b : bool, x : any, y : any :: {$IfThenElse(b, x, y)} (b ==> ($IfThenElse(b, x, y) == x)));
axiom (forall b : bool, x : any, y : any :: {$IfThenElse(b, x, y)} (!b ==> ($IfThenElse(b, x, y) == y)));
function #neg($$unnamed~cs : int) returns ($$unnamed~ct : int);
function #and($$unnamed~cv : int, $$unnamed~cu : int) returns ($$unnamed~cw : int);
function #or($$unnamed~cy : int, $$unnamed~cx : int) returns ($$unnamed~cz : int);
function #xor($$unnamed~db : int, $$unnamed~da : int) returns ($$unnamed~dc : int);
function #shl($$unnamed~de : int, $$unnamed~dd : int) returns ($$unnamed~df : int);
function #shr($$unnamed~dh : int, $$unnamed~dg : int) returns ($$unnamed~di : int);
function #rneg($$unnamed~dj : real) returns ($$unnamed~dk : real);
function #radd($$unnamed~dm : real, $$unnamed~dl : real) returns ($$unnamed~dn : real);
function #rsub($$unnamed~dp : real, $$unnamed~do : real) returns ($$unnamed~dq : real);
function #rmul($$unnamed~ds : real, $$unnamed~dr : real) returns ($$unnamed~dt : real);
function #rdiv($$unnamed~dv : real, $$unnamed~du : real) returns ($$unnamed~dw : real);
function #rmod($$unnamed~dy : real, $$unnamed~dx : real) returns ($$unnamed~dz : real);
function #rLess($$unnamed~eb : real, $$unnamed~ea : real) returns ($$unnamed~ec : bool);
function #rAtmost($$unnamed~ee : real, $$unnamed~ed : real) returns ($$unnamed~ef : bool);
function #rEq($$unnamed~eh : real, $$unnamed~eg : real) returns ($$unnamed~ei : bool);
function #rNeq($$unnamed~ek : real, $$unnamed~ej : real) returns ($$unnamed~el : bool);
function #rAtleast($$unnamed~en : real, $$unnamed~em : real) returns ($$unnamed~eo : bool);
function #rGreater($$unnamed~eq : real, $$unnamed~ep : real) returns ($$unnamed~er : bool);
axiom (forall x : int, y : int :: {(x % y)} {(x / y)} ((x % y) == (x - ((x / y) * y))));
axiom (forall x : int, y : int :: {(x % y)} (((0 <= x) && (0 < y)) ==> ((0 <= (x % y)) && ((x % y) < y))));
axiom (forall x : int, y : int :: {(x % y)} (((0 <= x) && (y < 0)) ==> ((0 <= (x % y)) && ((x % y) < (0 - y)))));
axiom (forall x : int, y : int :: {(x % y)} (((x <= 0) && (0 < y)) ==> (((0 - y) < (x % y)) && ((x % y) <= 0))));
axiom (forall x : int, y : int :: {(x % y)} (((x <= 0) && (y < 0)) ==> ((y < (x % y)) && ((x % y) <= 0))));
axiom (forall x : int, y : int :: {((x + y) % y)} (((0 <= x) && (0 <= y)) ==> (((x + y) % y) == (x % y))));
axiom (forall x : int, y : int :: {((y + x) % y)} (((0 <= x) && (0 <= y)) ==> (((y + x) % y) == (x % y))));
axiom (forall x : int, y : int :: {((x - y) % y)} (((0 <= (x - y)) && (0 <= y)) ==> (((x - y) % y) == (x % y))));
axiom (forall a : int, b : int, d : int :: {(a % d), (b % d)} ((((2 <= d) && ((a % d) == (b % d))) && (a < b)) ==> ((a + d) <= b)));
axiom (forall x : int, y : int :: {#and(x, y)} (((0 <= x) || (0 <= y)) ==> (0 <= #and(x, y))));
axiom (forall x : int, y : int :: {#or(x, y)} (((0 <= x) && (0 <= y)) ==> ((0 <= #or(x, y)) && (#or(x, y) <= (x + y)))));
axiom (forall i : int :: {#shl(i, 0)} (#shl(i, 0) == i));
axiom (forall i : int, j : int :: ((0 <= j) ==> (#shl(i, (j + 1)) == (#shl(i, j) * 2))));
axiom (forall i : int :: {#shr(i, 0)} (#shr(i, 0) == i));
axiom (forall i : int, j : int :: ((0 <= j) ==> (#shr(i, (j + 1)) == (#shr(i, j) / 2))));
function #System.String.IsInterned$System.String$notnull($$unnamed~es : ref) returns ($$unnamed~et : ref);
function #System.String.Equals$System.String($$unnamed~ev : ref, $$unnamed~eu : ref) returns ($$unnamed~ew : bool);
function #System.String.Equals$System.String$System.String($$unnamed~ey : ref, $$unnamed~ex : ref) returns ($$unnamed~ez : bool);
axiom (forall a : ref, b : ref :: {#System.String.Equals$System.String(a, b)} (#System.String.Equals$System.String(a, b) == #System.String.Equals$System.String$System.String(a, b)));
axiom (forall a : ref, b : ref :: {#System.String.Equals$System.String$System.String(a, b)} (#System.String.Equals$System.String$System.String(a, b) == #System.String.Equals$System.String$System.String(b, a)));
axiom (forall a : ref, b : ref :: {#System.String.Equals$System.String$System.String(a, b)} ((((a != null) && (b != null)) && #System.String.Equals$System.String$System.String(a, b)) ==> (#System.String.IsInterned$System.String$notnull(a) == #System.String.IsInterned$System.String$notnull(b))));
const $UnknownRef : ref;
const Chunker.src : <ref>name;
const Chunker.ChunkSize : <int>name;
const Chunker.n : <int>name;
const System.Collections.IEnumerable : name;
const System.IEquatable`1...System.String : name;
const Chunker : name;
const System.Collections.Generic.IEnumerable`1...System.Char : name;
const System.IConvertible : name;
const System.ICloneable : name;
const System.IComparable : name;
const System.IComparable`1...System.String : name;
axiom !IsStaticField(Chunker.src);
axiom IsDirectlyModifiableField(Chunker.src);
axiom (DeclType(Chunker.src) == Chunker);
axiom (AsRefField(Chunker.src, System.String) == Chunker.src);
axiom !IsStaticField(Chunker.n);
axiom IsDirectlyModifiableField(Chunker.n);
axiom (DeclType(Chunker.n) == Chunker);
axiom (AsRangeField(Chunker.n, System.Int32) == Chunker.n);
axiom !IsStaticField(Chunker.ChunkSize);
axiom IsDirectlyModifiableField(Chunker.ChunkSize);
axiom (DeclType(Chunker.ChunkSize) == Chunker);
axiom (AsRangeField(Chunker.ChunkSize, System.Int32) == Chunker.ChunkSize);
function #System.String.Substring$System.Int32$System.Int32($$unnamed~fd<x> : [ref, <x>name]x, $$unnamed~fc : ref, $$unnamed~fb : int, $$unnamed~fa : int) returns ($$unnamed~fe : ref);
function ##System.String.Substring$System.Int32$System.Int32($$unnamed~fh : exposeVersionType, $$unnamed~fg : int, $$unnamed~ff : int) returns ($$unnamed~fi : ref);
axiom (Chunker <: Chunker);
axiom ($BaseClass(Chunker) == System.Object);
axiom ((Chunker <: $BaseClass(Chunker)) && (AsDirectSubClass(Chunker, $BaseClass(Chunker)) == Chunker));
axiom (!$IsImmutable(Chunker) && ($AsMutable(Chunker) == Chunker));
axiom (System.String <: System.String);
axiom ($BaseClass(System.String) == System.Object);
axiom ((System.String <: $BaseClass(System.String)) && (AsDirectSubClass(System.String, $BaseClass(System.String)) == System.String));
axiom ($IsImmutable(System.String) && ($AsImmutable(System.String) == System.String));
axiom (System.IComparable <: System.Object);
axiom $IsMemberlessType(System.IComparable);
axiom (System.String <: System.IComparable);
axiom (System.ICloneable <: System.Object);
axiom $IsMemberlessType(System.ICloneable);
axiom (System.String <: System.ICloneable);
axiom (System.IConvertible <: System.Object);
axiom $IsMemberlessType(System.IConvertible);
axiom (System.String <: System.IConvertible);
axiom (System.IComparable`1...System.String <: System.Object);
axiom $IsMemberlessType(System.IComparable`1...System.String);
axiom (System.String <: System.IComparable`1...System.String);
axiom (System.Collections.Generic.IEnumerable`1...System.Char <: System.Object);
axiom (System.Collections.IEnumerable <: System.Object);
axiom $IsMemberlessType(System.Collections.IEnumerable);
axiom (System.Collections.Generic.IEnumerable`1...System.Char <: System.Collections.IEnumerable);
axiom $IsMemberlessType(System.Collections.Generic.IEnumerable`1...System.Char);
axiom (System.String <: System.Collections.Generic.IEnumerable`1...System.Char);
axiom (System.String <: System.Collections.IEnumerable);
axiom (System.IEquatable`1...System.String <: System.Object);
axiom $IsMemberlessType(System.IEquatable`1...System.String);
axiom (System.String <: System.IEquatable`1...System.String);
axiom (forall $U : name :: {($U <: System.String)} (($U <: System.String) ==> ($U == System.String)));

